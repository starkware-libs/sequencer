// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Felt252 {
    #[prost(bytes = "vec", tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<u8>,
}
/// A hash value representable as a Felt252
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hash {
    #[prost(bytes = "vec", tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<u8>,
}
/// A 256 bit hash value (like Keccak256)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hash256 {
    /// Required to be 32 bytes long
    #[prost(bytes = "vec", tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hashes {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(bytes = "vec", tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerId {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uint128 {
    #[prost(uint64, tag = "1")]
    pub low: u64,
    #[prost(uint64, tag = "2")]
    pub high: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusSignature {
    #[prost(message, optional, tag = "1")]
    pub r: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "2")]
    pub s: ::core::option::Option<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Patricia {
    /// needed to know the height, so as to how many nodes to expect in a proof.
    #[prost(uint64, tag = "1")]
    pub n_leaves: u64,
    /// and also when receiving all leaves, how many to expect
    #[prost(message, optional, tag = "2")]
    pub root: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockId {
    #[prost(uint64, tag = "1")]
    pub number: u64,
    #[prost(message, optional, tag = "2")]
    pub header: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockProof {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// mark the end of a stream of messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fin {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum L1DataAvailabilityMode {
    Calldata = 0,
    Blob = 1,
}
impl L1DataAvailabilityMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            L1DataAvailabilityMode::Calldata => "Calldata",
            L1DataAvailabilityMode::Blob => "Blob",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Calldata" => Some(Self::Calldata),
            "Blob" => Some(Self::Blob),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolitionDomain {
    L1 = 0,
    L2 = 1,
}
impl VolitionDomain {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VolitionDomain::L1 => "L1",
            VolitionDomain::L2 => "L2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "L1" => Some(Self::L1),
            "L2" => Some(Self::L2),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryPoint {
    #[prost(message, optional, tag = "1")]
    pub selector: ::core::option::Option<Felt252>,
    #[prost(uint64, tag = "2")]
    pub offset: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cairo0Class {
    #[prost(string, tag = "1")]
    pub abi: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub externals: ::prost::alloc::vec::Vec<EntryPoint>,
    #[prost(message, repeated, tag = "3")]
    pub l1_handlers: ::prost::alloc::vec::Vec<EntryPoint>,
    #[prost(message, repeated, tag = "4")]
    pub constructors: ::prost::alloc::vec::Vec<EntryPoint>,
    /// Compressed in base64 representation.
    #[prost(string, tag = "5")]
    pub program: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SierraEntryPoint {
    #[prost(uint64, tag = "1")]
    pub index: u64,
    #[prost(message, optional, tag = "2")]
    pub selector: ::core::option::Option<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cairo1EntryPoints {
    #[prost(message, repeated, tag = "1")]
    pub externals: ::prost::alloc::vec::Vec<SierraEntryPoint>,
    #[prost(message, repeated, tag = "2")]
    pub l1_handlers: ::prost::alloc::vec::Vec<SierraEntryPoint>,
    #[prost(message, repeated, tag = "3")]
    pub constructors: ::prost::alloc::vec::Vec<SierraEntryPoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cairo1Class {
    #[prost(string, tag = "1")]
    pub abi: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub entry_points: ::core::option::Option<Cairo1EntryPoints>,
    #[prost(message, repeated, tag = "3")]
    pub program: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(string, tag = "4")]
    pub contract_class_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Class {
    #[prost(uint32, tag = "3")]
    pub domain: u32,
    #[prost(message, optional, tag = "4")]
    pub class_hash: ::core::option::Option<Hash>,
    #[prost(oneof = "class::Class", tags = "1, 2")]
    pub class: ::core::option::Option<class::Class>,
}
/// Nested message and enum types in `Class`.
pub mod class {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Class {
        #[prost(message, tag = "1")]
        Cairo0(super::Cairo0Class),
        #[prost(message, tag = "2")]
        Cairo1(super::Cairo1Class),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// TODO(shahak, alonl): figure out if max_amount should be uint64 or Felt252
    #[prost(uint64, tag = "1")]
    pub max_amount: u64,
    #[prost(message, optional, tag = "2")]
    pub max_price_per_unit: ::core::option::Option<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceBounds {
    #[prost(message, optional, tag = "1")]
    pub l1_gas: ::core::option::Option<ResourceLimits>,
    /// This can be None only in transactions that don't support l2 gas.
    /// Starting from 0.14.0, MempoolTransaction and ConsensusTransaction shouldn't have None here.
    #[prost(message, optional, tag = "2")]
    pub l1_data_gas: ::core::option::Option<ResourceLimits>,
    #[prost(message, optional, tag = "3")]
    pub l2_gas: ::core::option::Option<ResourceLimits>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountSignature {
    #[prost(message, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct L1HandlerV0 {
    #[prost(message, optional, tag = "1")]
    pub nonce: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Address>,
    #[prost(message, optional, tag = "3")]
    pub entry_point_selector: ::core::option::Option<Felt252>,
    #[prost(message, repeated, tag = "4")]
    pub calldata: ::prost::alloc::vec::Vec<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclareV3Common {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<Address>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<AccountSignature>,
    #[prost(message, optional, tag = "4")]
    pub nonce: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "5")]
    pub compiled_class_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "6")]
    pub resource_bounds: ::core::option::Option<ResourceBounds>,
    #[prost(uint64, tag = "7")]
    pub tip: u64,
    #[prost(message, repeated, tag = "8")]
    pub paymaster_data: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, repeated, tag = "9")]
    pub account_deployment_data: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(enumeration = "VolitionDomain", tag = "10")]
    pub nonce_data_availability_mode: i32,
    #[prost(enumeration = "VolitionDomain", tag = "11")]
    pub fee_data_availability_mode: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclareV3WithClass {
    #[prost(message, optional, tag = "1")]
    pub common: ::core::option::Option<DeclareV3Common>,
    #[prost(message, optional, tag = "2")]
    pub class: ::core::option::Option<Cairo1Class>,
}
/// see <https://external.integration.starknet.io/feeder_gateway/get_transaction?transactionHash=0x41906f1c314cca5f43170ea75d3b1904196a10101190d2b12a41cc61cfd17c>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeV3 {
    #[prost(message, optional, tag = "1")]
    pub sender: ::core::option::Option<Address>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<AccountSignature>,
    #[prost(message, repeated, tag = "3")]
    pub calldata: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, optional, tag = "4")]
    pub resource_bounds: ::core::option::Option<ResourceBounds>,
    #[prost(uint64, tag = "5")]
    pub tip: u64,
    #[prost(message, repeated, tag = "6")]
    pub paymaster_data: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, repeated, tag = "7")]
    pub account_deployment_data: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(enumeration = "VolitionDomain", tag = "8")]
    pub nonce_data_availability_mode: i32,
    #[prost(enumeration = "VolitionDomain", tag = "9")]
    pub fee_data_availability_mode: i32,
    #[prost(message, optional, tag = "10")]
    pub nonce: ::core::option::Option<Felt252>,
}
/// see <https://external.integration.starknet.io/feeder_gateway/get_transaction?transactionHash=0x29fd7881f14380842414cdfdd8d6c0b1f2174f8916edcfeb1ede1eb26ac3ef0>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployAccountV3 {
    #[prost(message, optional, tag = "1")]
    pub signature: ::core::option::Option<AccountSignature>,
    #[prost(message, optional, tag = "2")]
    pub class_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "3")]
    pub nonce: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "4")]
    pub address_salt: ::core::option::Option<Felt252>,
    #[prost(message, repeated, tag = "5")]
    pub calldata: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, optional, tag = "6")]
    pub resource_bounds: ::core::option::Option<ResourceBounds>,
    #[prost(uint64, tag = "7")]
    pub tip: u64,
    #[prost(message, repeated, tag = "8")]
    pub paymaster_data: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(enumeration = "VolitionDomain", tag = "9")]
    pub nonce_data_availability_mode: i32,
    #[prost(enumeration = "VolitionDomain", tag = "10")]
    pub fee_data_availability_mode: i32,
}
/// Contains all variants of mempool and an L1Handler variant to cover all transactions that can be
/// in a new block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusTransaction {
    #[prost(message, optional, tag = "5")]
    pub transaction_hash: ::core::option::Option<Hash>,
    #[prost(oneof = "consensus_transaction::Txn", tags = "1, 2, 3, 4")]
    pub txn: ::core::option::Option<consensus_transaction::Txn>,
}
/// Nested message and enum types in `ConsensusTransaction`.
pub mod consensus_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Txn {
        #[prost(message, tag = "1")]
        DeclareV3(super::DeclareV3WithClass),
        #[prost(message, tag = "2")]
        DeployAccountV3(super::DeployAccountV3),
        #[prost(message, tag = "3")]
        InvokeV3(super::InvokeV3),
        #[prost(message, tag = "4")]
        L1Handler(super::L1HandlerV0),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vote {
    /// We use a type field to distinguish between prevotes and precommits instead of different
    /// messages, to make sure the data, and therefore the signatures, are unambiguous between
    /// Prevote and Precommit.
    #[prost(enumeration = "vote::VoteType", tag = "2")]
    pub vote_type: i32,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(uint32, tag = "4")]
    pub round: u32,
    /// This is optional since a vote can be NIL.
    #[prost(message, optional, tag = "5")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "6")]
    pub voter: ::core::option::Option<Address>,
}
/// Nested message and enum types in `Vote`.
pub mod vote {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VoteType {
        Prevote = 0,
        Precommit = 1,
    }
    impl VoteType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VoteType::Prevote => "Prevote",
                VoteType::Precommit => "Precommit",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Prevote" => Some(Self::Prevote),
                "Precommit" => Some(Self::Precommit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamMessage {
    #[prost(bytes = "vec", tag = "3")]
    pub stream_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub message_id: u64,
    #[prost(oneof = "stream_message::Message", tags = "1, 2")]
    pub message: ::core::option::Option<stream_message::Message>,
}
/// Nested message and enum types in `StreamMessage`.
pub mod stream_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(bytes, tag = "1")]
        Content(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "2")]
        Fin(super::Fin),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalInit {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(uint32, tag = "2")]
    pub round: u32,
    #[prost(uint32, optional, tag = "3")]
    pub valid_round: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub proposer: ::core::option::Option<Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInfo {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    #[prost(message, optional, tag = "3")]
    pub builder: ::core::option::Option<Address>,
    #[prost(enumeration = "L1DataAvailabilityMode", tag = "4")]
    pub l1_da_mode: i32,
    #[prost(message, optional, tag = "5")]
    pub l2_gas_price_fri: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "6")]
    pub l1_gas_price_wei: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "7")]
    pub l1_data_gas_price_wei: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "8")]
    pub eth_to_fri_rate: ::core::option::Option<Uint128>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionBatch {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<ConsensusTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalFin {
    /// Identifies a Starknet block based on the content streamed in the proposal.
    #[prost(message, optional, tag = "1")]
    pub proposal_commitment: ::core::option::Option<Hash>,
}
/// Network format:
/// 1. First message is ProposalInit
/// 2. Last message is ProposalFin
///
/// Empty block - no other messages sent.
///
/// Block with transactions:
/// 3. block_info is sent once
/// 4. transactions is sent repeatedly
/// 5. executed_transaction_count is sent once
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalPart {
    #[prost(oneof = "proposal_part::Message", tags = "1, 2, 3, 4, 5")]
    pub message: ::core::option::Option<proposal_part::Message>,
}
/// Nested message and enum types in `ProposalPart`.
pub mod proposal_part {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Init(super::ProposalInit),
        #[prost(message, tag = "2")]
        Fin(super::ProposalFin),
        #[prost(message, tag = "3")]
        BlockInfo(super::BlockInfo),
        #[prost(message, tag = "4")]
        Transactions(super::TransactionBatch),
        #[prost(uint64, tag = "5")]
        ExecutedTransactionCount(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyAndChallenge {
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "2")]
    pub challenge: ::core::option::Option<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedChallengeAndIdentity {
    #[prost(message, repeated, tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateDiffCommitment {
    #[prost(uint64, tag = "1")]
    pub state_diff_length: u64,
    #[prost(message, optional, tag = "2")]
    pub root: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Iteration {
    #[prost(enumeration = "iteration::Direction", tag = "3")]
    pub direction: i32,
    #[prost(uint64, tag = "4")]
    pub limit: u64,
    /// to allow interleaving from several nodes
    #[prost(uint64, tag = "5")]
    pub step: u64,
    #[prost(oneof = "iteration::Start", tags = "1, 2")]
    pub start: ::core::option::Option<iteration::Start>,
}
/// Nested message and enum types in `Iteration`.
pub mod iteration {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        Forward = 0,
        Backward = 1,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::Forward => "Forward",
                Direction::Backward => "Backward",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Forward" => Some(Self::Forward),
                "Backward" => Some(Self::Backward),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Start {
        #[prost(uint64, tag = "1")]
        BlockNumber(u64),
        #[prost(message, tag = "2")]
        Header(super::Hash),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageToL1 {
    #[prost(message, optional, tag = "2")]
    pub from_address: ::core::option::Option<Felt252>,
    #[prost(message, repeated, tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, optional, tag = "4")]
    pub to_address: ::core::option::Option<EthereumAddress>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EthereumAddress {
    #[prost(bytes = "vec", tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Receipt {
    #[prost(oneof = "receipt::Type", tags = "1, 2, 3, 4, 5")]
    pub r#type: ::core::option::Option<receipt::Type>,
}
/// Nested message and enum types in `Receipt`.
pub mod receipt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionResources {
        #[prost(message, optional, tag = "1")]
        pub builtins: ::core::option::Option<execution_resources::BuiltinCounter>,
        #[prost(uint32, tag = "2")]
        pub steps: u32,
        #[prost(uint32, tag = "3")]
        pub memory_holes: u32,
        #[prost(message, optional, tag = "4")]
        pub da_gas_consumed: ::core::option::Option<execution_resources::GasVector>,
        #[prost(message, optional, tag = "5")]
        pub gas_consumed: ::core::option::Option<execution_resources::GasVector>,
    }
    /// Nested message and enum types in `ExecutionResources`.
    pub mod execution_resources {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BuiltinCounter {
            #[prost(uint32, tag = "1")]
            pub bitwise: u32,
            #[prost(uint32, tag = "2")]
            pub ecdsa: u32,
            #[prost(uint32, tag = "3")]
            pub ec_op: u32,
            #[prost(uint32, tag = "4")]
            pub pedersen: u32,
            #[prost(uint32, tag = "5")]
            pub range_check: u32,
            #[prost(uint32, tag = "6")]
            pub poseidon: u32,
            #[prost(uint32, tag = "7")]
            pub keccak: u32,
            /// TODO(alonl): add the missing builtins
            #[prost(uint32, tag = "8")]
            pub output: u32,
        }
        /// TODO(alonl): remove GasVector and unsplit gas_consumed and da_gas_consumed
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GasVector {
            #[prost(uint64, tag = "1")]
            pub l1_gas: u64,
            #[prost(uint64, tag = "2")]
            pub l1_data_gas: u64,
            #[prost(uint64, tag = "3")]
            pub l2_gas: u64,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Common {
        #[prost(message, optional, tag = "2")]
        pub actual_fee: ::core::option::Option<super::Felt252>,
        #[prost(enumeration = "super::PriceUnit", tag = "3")]
        pub price_unit: i32,
        #[prost(message, repeated, tag = "4")]
        pub messages_sent: ::prost::alloc::vec::Vec<super::MessageToL1>,
        #[prost(message, optional, tag = "5")]
        pub execution_resources: ::core::option::Option<ExecutionResources>,
        #[prost(string, optional, tag = "6")]
        pub revert_reason: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Invoke {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<Common>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct L1Handler {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<Common>,
        #[prost(message, optional, tag = "2")]
        pub msg_hash: ::core::option::Option<super::Hash256>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Declare {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<Common>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Deploy {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<Common>,
        #[prost(message, optional, tag = "2")]
        pub contract_address: ::core::option::Option<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeployAccount {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<Common>,
        #[prost(message, optional, tag = "2")]
        pub contract_address: ::core::option::Option<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Invoke(Invoke),
        #[prost(message, tag = "2")]
        L1Handler(L1Handler),
        #[prost(message, tag = "3")]
        Declare(Declare),
        #[prost(message, tag = "4")]
        DeprecatedDeploy(Deploy),
        #[prost(message, tag = "5")]
        DeployAccount(DeployAccount),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PriceUnit {
    Wei = 0,
    Fri = 1,
}
impl PriceUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PriceUnit::Wei => "Wei",
            PriceUnit::Fri => "Fri",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Wei" => Some(Self::Wei),
            "Fri" => Some(Self::Fri),
            _ => None,
        }
    }
}
/// TBD: can support a flag to return tx hashes only, good for standalone mempool to remove them,
/// or any node that keeps track of transaction streaming in the consensus.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionsRequest {
    #[prost(message, optional, tag = "1")]
    pub iteration: ::core::option::Option<Iteration>,
}
/// Responses are sent ordered by the order given in the request. The order inside each block is
/// according to the execution order.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionsResponse {
    #[prost(oneof = "transactions_response::TransactionMessage", tags = "1, 2")]
    pub transaction_message: ::core::option::Option<
        transactions_response::TransactionMessage,
    >,
}
/// Nested message and enum types in `TransactionsResponse`.
pub mod transactions_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TransactionMessage {
        #[prost(message, tag = "1")]
        TransactionWithReceipt(super::TransactionWithReceipt),
        /// Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its transactions.
        #[prost(message, tag = "2")]
        Fin(super::Fin),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionWithReceipt {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionInBlock>,
    #[prost(message, optional, tag = "2")]
    pub receipt: ::core::option::Option<Receipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInBlock {
    #[prost(message, optional, tag = "12")]
    pub transaction_hash: ::core::option::Option<Hash>,
    #[prost(
        oneof = "transaction_in_block::Txn",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11"
    )]
    pub txn: ::core::option::Option<transaction_in_block::Txn>,
}
/// Nested message and enum types in `TransactionInBlock`.
pub mod transaction_in_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeclareV0WithoutClass {
        #[prost(message, optional, tag = "1")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "2")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "3")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, optional, tag = "4")]
        pub class_hash: ::core::option::Option<super::Hash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeclareV1WithoutClass {
        #[prost(message, optional, tag = "1")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "2")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "3")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, optional, tag = "4")]
        pub class_hash: ::core::option::Option<super::Hash>,
        #[prost(message, optional, tag = "5")]
        pub nonce: ::core::option::Option<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeclareV2WithoutClass {
        #[prost(message, optional, tag = "1")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "2")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "3")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, optional, tag = "4")]
        pub class_hash: ::core::option::Option<super::Hash>,
        #[prost(message, optional, tag = "5")]
        pub nonce: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "6")]
        pub compiled_class_hash: ::core::option::Option<super::Hash>,
    }
    /// see <https://external.integration.starknet.io/feeder_gateway/get_transaction?transactionHash=0x41d1f5206ef58a443e7d3d1ca073171ec25fa75313394318fc83a074a6631c3>
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeclareV3WithoutClass {
        #[prost(message, optional, tag = "1")]
        pub common: ::core::option::Option<super::DeclareV3Common>,
        #[prost(message, optional, tag = "2")]
        pub class_hash: ::core::option::Option<super::Hash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Deploy {
        #[prost(message, optional, tag = "1")]
        pub class_hash: ::core::option::Option<super::Hash>,
        #[prost(message, optional, tag = "2")]
        pub address_salt: ::core::option::Option<super::Felt252>,
        #[prost(message, repeated, tag = "3")]
        pub calldata: ::prost::alloc::vec::Vec<super::Felt252>,
        #[prost(uint32, tag = "4")]
        pub version: u32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeployAccountV1 {
        #[prost(message, optional, tag = "1")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "2")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, optional, tag = "3")]
        pub class_hash: ::core::option::Option<super::Hash>,
        #[prost(message, optional, tag = "4")]
        pub nonce: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "5")]
        pub address_salt: ::core::option::Option<super::Felt252>,
        #[prost(message, repeated, tag = "6")]
        pub calldata: ::prost::alloc::vec::Vec<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvokeV0 {
        #[prost(message, optional, tag = "1")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "2")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, optional, tag = "3")]
        pub address: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "4")]
        pub entry_point_selector: ::core::option::Option<super::Felt252>,
        #[prost(message, repeated, tag = "5")]
        pub calldata: ::prost::alloc::vec::Vec<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvokeV1 {
        #[prost(message, optional, tag = "1")]
        pub sender: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "2")]
        pub max_fee: ::core::option::Option<super::Felt252>,
        #[prost(message, optional, tag = "3")]
        pub signature: ::core::option::Option<super::AccountSignature>,
        #[prost(message, repeated, tag = "4")]
        pub calldata: ::prost::alloc::vec::Vec<super::Felt252>,
        #[prost(message, optional, tag = "5")]
        pub nonce: ::core::option::Option<super::Felt252>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Txn {
        #[prost(message, tag = "1")]
        DeclareV0(DeclareV0WithoutClass),
        #[prost(message, tag = "2")]
        DeclareV1(DeclareV1WithoutClass),
        #[prost(message, tag = "3")]
        DeclareV2(DeclareV2WithoutClass),
        #[prost(message, tag = "4")]
        DeclareV3(DeclareV3WithoutClass),
        #[prost(message, tag = "5")]
        Deploy(Deploy),
        #[prost(message, tag = "6")]
        DeployAccountV1(DeployAccountV1),
        #[prost(message, tag = "7")]
        DeployAccountV3(super::DeployAccountV3),
        #[prost(message, tag = "8")]
        InvokeV0(InvokeV0),
        #[prost(message, tag = "9")]
        InvokeV1(InvokeV1),
        #[prost(message, tag = "10")]
        InvokeV3(super::InvokeV3),
        #[prost(message, tag = "11")]
        L1Handler(super::L1HandlerV0),
    }
}
/// Doesn't contain L1Handler, as those don't need to be propagated and can be downloaded from L1.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MempoolTransaction {
    #[prost(message, optional, tag = "4")]
    pub transaction_hash: ::core::option::Option<Hash>,
    #[prost(oneof = "mempool_transaction::Txn", tags = "1, 2, 3")]
    pub txn: ::core::option::Option<mempool_transaction::Txn>,
}
/// Nested message and enum types in `MempoolTransaction`.
pub mod mempool_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Txn {
        #[prost(message, tag = "1")]
        DeclareV3(super::DeclareV3WithClass),
        #[prost(message, tag = "2")]
        DeployAccountV3(super::DeployAccountV3),
        #[prost(message, tag = "3")]
        InvokeV3(super::InvokeV3),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MempoolTransactionBatch {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<MempoolTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassesRequest {
    #[prost(message, optional, tag = "1")]
    pub iteration: ::core::option::Option<Iteration>,
}
/// Responses are sent ordered by the order given in the request.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassesResponse {
    #[prost(oneof = "classes_response::ClassMessage", tags = "1, 2")]
    pub class_message: ::core::option::Option<classes_response::ClassMessage>,
}
/// Nested message and enum types in `ClassesResponse`.
pub mod classes_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClassMessage {
        #[prost(message, tag = "1")]
        Class(super::Class),
        /// Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its classes.
        #[prost(message, tag = "2")]
        Fin(super::Fin),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, optional, tag = "1")]
    pub transaction_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "3")]
    pub from_address: ::core::option::Option<Felt252>,
    #[prost(message, repeated, tag = "4")]
    pub keys: ::prost::alloc::vec::Vec<Felt252>,
    #[prost(message, repeated, tag = "5")]
    pub data: ::prost::alloc::vec::Vec<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsRequest {
    #[prost(message, optional, tag = "1")]
    pub iteration: ::core::option::Option<Iteration>,
}
/// Responses are sent ordered by the order given in the request.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsResponse {
    #[prost(oneof = "events_response::EventMessage", tags = "1, 2")]
    pub event_message: ::core::option::Option<events_response::EventMessage>,
}
/// Nested message and enum types in `EventsResponse`.
pub mod events_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventMessage {
        #[prost(message, tag = "1")]
        Event(super::Event),
        /// Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its events.
        #[prost(message, tag = "2")]
        Fin(super::Fin),
    }
}
/// Note: commitments may change to be for the previous blocks like comet/tendermint
/// hash of block header sent to L1
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedBlockHeader {
    ///   For the structure of the block hash, see <https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/header/#block_hash>
    #[prost(message, optional, tag = "1")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "2")]
    pub parent_hash: ::core::option::Option<Hash>,
    /// This can be deduced from context. We can consider removing this field.
    #[prost(uint64, tag = "3")]
    pub number: u64,
    /// Encoded in Unix time.
    #[prost(uint64, tag = "4")]
    pub time: u64,
    #[prost(message, optional, tag = "5")]
    pub sequencer_address: ::core::option::Option<Address>,
    /// Patricia root of contract and class patricia tries. Each of those tries are of height 251. Same as in L1. Later more trees will be included
    #[prost(message, optional, tag = "6")]
    pub state_root: ::core::option::Option<Hash>,
    /// The state diff commitment returned  by the Starknet Feeder Gateway
    #[prost(message, optional, tag = "7")]
    pub state_diff_commitment: ::core::option::Option<StateDiffCommitment>,
    /// For more info, see <https://community.starknet.io/t/introducing-p2p-authentication-and-mismatch-resolution-in-v0-12-2/97993>
    /// The leaves contain a hash of the transaction hash and transaction signature.
    ///
    /// By order of execution. TBD: required? the client can execute (powerful machine) and match state diff
    #[prost(message, optional, tag = "8")]
    pub transactions: ::core::option::Option<Patricia>,
    /// By order of issuance. TBD: in receipts?
    #[prost(message, optional, tag = "9")]
    pub events: ::core::option::Option<Patricia>,
    /// By order of issuance. This is a patricia root. No need for length because it's the same length as transactions.
    #[prost(message, optional, tag = "10")]
    pub receipts: ::core::option::Option<Hash>,
    /// Starknet version
    #[prost(string, tag = "11")]
    pub protocol_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub l1_gas_price_fri: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "13")]
    pub l1_gas_price_wei: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "14")]
    pub l1_data_gas_price_fri: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "15")]
    pub l1_data_gas_price_wei: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "16")]
    pub l2_gas_price_fri: ::core::option::Option<Uint128>,
    #[prost(message, optional, tag = "17")]
    pub l2_gas_price_wei: ::core::option::Option<Uint128>,
    #[prost(uint64, tag = "18")]
    pub l2_gas_consumed: u64,
    #[prost(message, optional, tag = "19")]
    pub next_l2_gas_price: ::core::option::Option<Uint128>,
    #[prost(enumeration = "L1DataAvailabilityMode", tag = "20")]
    pub l1_data_availability_mode: i32,
    /// for now, we assume a small consensus, so this fits in 1M. Else, these will be repeated and extracted from this message.
    ///
    /// can be more explicit here about the signature structure as this is not part of account abstraction
    #[prost(message, repeated, tag = "21")]
    pub signatures: ::prost::alloc::vec::Vec<ConsensusSignature>,
}
/// sent to all peers (except the ones this was received from, if any).
/// for a fraction of peers, also send the GetBlockHeaders response (as if they asked for it for this block)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlock {
    #[prost(oneof = "new_block::MaybeFull", tags = "1, 2")]
    pub maybe_full: ::core::option::Option<new_block::MaybeFull>,
}
/// Nested message and enum types in `NewBlock`.
pub mod new_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MaybeFull {
        #[prost(message, tag = "1")]
        Id(super::BlockId),
        #[prost(message, tag = "2")]
        Header(super::BlockHeadersResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeadersRequest {
    #[prost(message, optional, tag = "1")]
    pub iteration: ::core::option::Option<Iteration>,
}
/// Responses are sent ordered by the order given in the request.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeadersResponse {
    #[prost(oneof = "block_headers_response::HeaderMessage", tags = "1, 2")]
    pub header_message: ::core::option::Option<block_headers_response::HeaderMessage>,
}
/// Nested message and enum types in `BlockHeadersResponse`.
pub mod block_headers_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum HeaderMessage {
        #[prost(message, tag = "1")]
        Header(super::SignedBlockHeader),
        /// Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its header.
        #[prost(message, tag = "2")]
        Fin(super::Fin),
    }
}
/// optimized for flat storage, not through a trie (not sharing key prefixes)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractStoredValue {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Felt252>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Felt252>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractDiff {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    /// Present only if the nonce was updated
    #[prost(message, optional, tag = "2")]
    pub nonce: ::core::option::Option<Felt252>,
    /// Present only if the contract was deployed or replaced in this block.
    #[prost(message, optional, tag = "3")]
    pub class_hash: ::core::option::Option<Hash>,
    #[prost(message, repeated, tag = "4")]
    pub values: ::prost::alloc::vec::Vec<ContractStoredValue>,
    #[prost(enumeration = "VolitionDomain", tag = "5")]
    pub domain: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclaredClass {
    #[prost(message, optional, tag = "1")]
    pub class_hash: ::core::option::Option<Hash>,
    /// Present only if the class is Cairo1
    #[prost(message, optional, tag = "2")]
    pub compiled_class_hash: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateDiffsRequest {
    #[prost(message, optional, tag = "1")]
    pub iteration: ::core::option::Option<Iteration>,
}
/// Responses are sent ordered by the order given in the request.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateDiffsResponse {
    /// All of the messages related to a block need to be sent before a message from the next block is sent.
    #[prost(oneof = "state_diffs_response::StateDiffMessage", tags = "1, 2, 3")]
    pub state_diff_message: ::core::option::Option<
        state_diffs_response::StateDiffMessage,
    >,
}
/// Nested message and enum types in `StateDiffsResponse`.
pub mod state_diffs_response {
    /// All of the messages related to a block need to be sent before a message from the next block is sent.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StateDiffMessage {
        /// Multiple contract diffs for the same contract may appear continuously if the diff is too large or if it's more convenient.
        #[prost(message, tag = "1")]
        ContractDiff(super::ContractDiff),
        #[prost(message, tag = "2")]
        DeclaredClass(super::DeclaredClass),
        /// Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its state diff.
        #[prost(message, tag = "3")]
        Fin(super::Fin),
    }
}
