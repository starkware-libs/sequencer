{
  "base_layer_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "base_layer_config.node_url": {
    "description": "Initial ethereum node URL. A schema to match to Infura node: https://mainnet.infura.io/v3/<your_api_key>, but any other node can be used. May be be replaced during runtime if becomes inoperative",
    "privacy": "Private",
    "value": "https://mainnet.infura.io/v3/%3Cyour_api_key%3E"
  },
  "base_layer_config.prague_blob_gas_calc": {
    "description": "If true use the blob gas calculcation from the Pectra upgrade. If false use the EIP 4844 calculation.",
    "privacy": "Public",
    "value": true
  },
  "base_layer_config.starknet_contract_address": {
    "description": "Starknet contract address in ethereum.",
    "privacy": "Public",
    "value": "0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4"
  },
  "base_layer_config.timeout_millis": {
    "description": "The timeout (milliseconds) for a query of the L1 base layer",
    "privacy": "Public",
    "value": 1000
  },
  "batcher_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.l1_gas": {
    "description": "An upper bound on the total l1_gas used in a block.",
    "privacy": "Public",
    "value": 2500000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.message_segment_length": {
    "description": "An upper bound on the message segment length in a block.",
    "privacy": "Public",
    "value": 3700
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_events": {
    "description": "An upper bound on the total number of events generated in a block.",
    "privacy": "Public",
    "value": 5000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_txs": {
    "description": "An upper bound on the total number of transactions in a block.",
    "privacy": "Public",
    "value": 600
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.proving_gas": {
    "description": "An upper bound on the total builtins and steps gas usage used in a block.",
    "privacy": "Public",
    "value": 5000000000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.sierra_gas": {
    "description": "An upper bound on the total sierra_gas used in a block.",
    "privacy": "Public",
    "value": 4000000000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.state_diff_size": {
    "description": "An upper bound on the total state diff size in a block.",
    "privacy": "Public",
    "value": 4000
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.add_mod": {
    "description": "Add_mod gas weight.",
    "privacy": "Public",
    "value": 312
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.bitwise": {
    "description": "Bitwise gas weight.",
    "privacy": "Public",
    "value": 583
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.ec_op": {
    "description": "Ec_op gas weight.",
    "privacy": "Public",
    "value": 714875
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.ecdsa": {
    "description": "Ecdsa gas weight.",
    "privacy": "Public",
    "value": 1666666
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.keccak": {
    "description": "Keccak gas weight.",
    "privacy": "Public",
    "value": 510707
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.mul_mod": {
    "description": "Mul_mod gas weight.",
    "privacy": "Public",
    "value": 604
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.pedersen": {
    "description": "Pedersen gas weight.",
    "privacy": "Public",
    "value": 4769
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.poseidon": {
    "description": "Poseidon gas weight.",
    "privacy": "Public",
    "value": 6250
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.range_check": {
    "description": "Range_check gas weight.",
    "privacy": "Public",
    "value": 70
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.range_check96": {
    "description": "range_check96 gas weight.",
    "privacy": "Public",
    "value": 56
  },
  "batcher_config.block_builder_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.execute_config.n_workers": {
    "description": "Number of parallel transaction execution workers.",
    "privacy": "Public",
    "value": 1
  },
  "batcher_config.block_builder_config.execute_config.stack_size": {
    "description": "The thread stack size (proportional to the maximal gas of a transaction).",
    "privacy": "Public",
    "value": 62914560
  },
  "batcher_config.block_builder_config.n_concurrent_txs": {
    "description": "Number of transactions in each request from the tx_provider.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.block_builder_config.tx_polling_interval_millis": {
    "description": "Time to wait (in milliseconds) between transaction requests when the previous request returned no transactions.",
    "privacy": "Public",
    "value": 10
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.channel_size": {
    "description": "The size of the compilation request channel.",
    "privacy": "Public",
    "value": 2000
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.native_classes_whitelist": {
    "description": "Contracts for Cairo Specifies whether to execute all class hashes or only a limited selection using Cairo native contracts. If limited, a specific list of class hashes is provided. compilation.",
    "privacy": "Public",
    "value": "All"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.panic_on_compilation_failure": {
    "description": "Whether to panic on compilation failure.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.run_cairo_native": {
    "description": "Enables Cairo native execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.wait_on_native_compilation": {
    "description": "Block Sequencer main program while compiling sierra, for testing.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.contract_cache_size": {
    "description": "The size of the global contract cache.",
    "privacy": "Public",
    "value": 600
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.compiler_binary_path": {
    "description": "The path to the Sierra-to-Native compiler binary.",
    "privacy": "Public",
    "value": ""
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.compiler_binary_path.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_cpu_time": {
    "description": "Limitation of compilation cpu time (seconds).",
    "privacy": "Public",
    "value": 600
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_cpu_time.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_file_size": {
    "description": "Limitation of compiled Cairo Native file size (bytes).",
    "privacy": "Public",
    "value": 52428800
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_file_size.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_memory_usage": {
    "description": "Limitation of compilation process's virtual memory (bytes).",
    "privacy": "Public",
    "value": 16106127360
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_memory_usage.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.optimization_level": {
    "description": "The level of optimization to apply during compilation.",
    "privacy": "Public",
    "value": 2
  },
  "batcher_config.input_stream_content_buffer_size": {
    "description": "Sets the buffer size for the input transaction channel. Adding more transactions beyond this limit will block until space is available.",
    "privacy": "Public",
    "value": 400
  },
  "batcher_config.max_l1_handler_txs_per_block_proposal": {
    "description": "The maximum number of L1 handler transactions to include in a block proposal.",
    "privacy": "Public",
    "value": 3
  },
  "batcher_config.outstream_content_buffer_size": {
    "description": "The maximum number of items to include in a single get_proposal_content response.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.pre_confirmed_block_writer_config.channel_buffer_capacity": {
    "description": "The capacity of the channel buffer for receiving pre-confirmed transactions.",
    "privacy": "Public",
    "value": 1000
  },
  "batcher_config.pre_confirmed_block_writer_config.write_block_interval_millis": {
    "description": "Time interval (ms) between writing pre-confirmed blocks. Writes occur only when block data changes.",
    "privacy": "Public",
    "value": 50
  },
  "batcher_config.pre_confirmed_cende_config.recorder_url": {
    "description": "The URL of the Pythonic cende_recorder",
    "pointer_target": "recorder_url",
    "privacy": "Private"
  },
  "batcher_config.storage.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.storage.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.storage.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "batcher_config.storage.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "batcher_config.storage.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "/data/batcher"
  },
  "batcher_config.storage.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "batcher_config.storage.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "batcher_config.storage.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "StateOnly"
  },
  "chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "class_manager_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "class_manager_config.class_manager_config.cached_class_storage_config.class_cache_size": {
    "description": "Contract classes cache size.",
    "privacy": "Public",
    "value": 10
  },
  "class_manager_config.class_manager_config.cached_class_storage_config.deprecated_class_cache_size": {
    "description": "Deprecated contract classes cache size.",
    "privacy": "Public",
    "value": 10
  },
  "class_manager_config.class_manager_config.max_compiled_contract_class_object_size": {
    "description": "Limitation of compiled contract class object size.",
    "privacy": "Public",
    "value": 4089446
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.class_hash_db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.class_hash_db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.class_hash_db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.class_hash_db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.class_hash_db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory.",
    "privacy": "Public",
    "value": "/data/class_hash_storage"
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1048576
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 1024
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1073741824
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "StateOnly"
  },
  "class_manager_config.class_storage_config.persistent_root": {
    "description": "Path to the node's class storage directory.",
    "privacy": "Public",
    "value": "/data/classes"
  },
  "components.batcher.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.batcher.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.batcher.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.batcher.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.batcher.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.batcher.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.batcher.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.batcher.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.batcher.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.batcher.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.batcher.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.batcher.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.class_manager.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.class_manager.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.class_manager.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.class_manager.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.class_manager.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.class_manager.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.class_manager.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.class_manager.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.class_manager.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.class_manager.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.class_manager.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.class_manager.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.consensus_manager.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.gateway.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.gateway.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.gateway.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.gateway.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.gateway.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.gateway.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.gateway.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.gateway.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.gateway.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.gateway.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.gateway.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.gateway.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.http_server.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.l1_endpoint_monitor.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_endpoint_monitor.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.l1_endpoint_monitor.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.l1_endpoint_monitor.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.l1_endpoint_monitor.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.l1_endpoint_monitor.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_endpoint_monitor.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.l1_endpoint_monitor.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.l1_endpoint_monitor.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_endpoint_monitor.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.l1_endpoint_monitor.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.l1_endpoint_monitor.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.l1_gas_price_provider.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_gas_price_provider.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.l1_gas_price_provider.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.l1_gas_price_provider.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.l1_gas_price_provider.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.l1_gas_price_provider.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_gas_price_provider.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.l1_gas_price_provider.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.l1_gas_price_provider.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_gas_price_provider.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.l1_gas_price_provider.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.l1_gas_price_provider.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.l1_gas_price_scraper.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.l1_provider.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_provider.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.l1_provider.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.l1_provider.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.l1_provider.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.l1_provider.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_provider.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.l1_provider.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.l1_provider.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_provider.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.l1_provider.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.l1_provider.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.l1_scraper.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.mempool.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.mempool.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.mempool.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.mempool.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.mempool.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.mempool.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.mempool.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.mempool.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.mempool.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.mempool_p2p.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool_p2p.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.mempool_p2p.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.mempool_p2p.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.mempool_p2p.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.mempool_p2p.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool_p2p.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.mempool_p2p.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.mempool_p2p.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool_p2p.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.mempool_p2p.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.mempool_p2p.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.monitoring_endpoint.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.sierra_compiler.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.sierra_compiler.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.sierra_compiler.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.sierra_compiler.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.sierra_compiler.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.sierra_compiler.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.sierra_compiler.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.sierra_compiler.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.sierra_compiler.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.sierra_compiler.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.sierra_compiler.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.sierra_compiler.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.state_sync.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.state_sync.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.state_sync.local_server_config.channel_capacity": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 1024
  },
  "components.state_sync.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 128
  },
  "components.state_sync.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.state_sync.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 10
  },
  "components.state_sync.remote_client_config.idle_timeout_ms": {
    "description": "The duration in milliseconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 30000
  },
  "components.state_sync.remote_client_config.initial_retry_delay_ms": {
    "description": "Initial delay before first retry in milliseconds",
    "privacy": "Public",
    "value": 1
  },
  "components.state_sync.remote_client_config.log_attempt_interval_ms": {
    "description": "Number of attempts between failure log messages",
    "privacy": "Public",
    "value": 10
  },
  "components.state_sync.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 150
  },
  "components.state_sync.remote_client_config.retry_interval_ms": {
    "description": "The duration in milliseconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 1000
  },
  "components.state_sync.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "consensus_manager_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "consensus_manager_config.assume_no_malicious_validators": {
    "description": "Assumes all validators are honest. If true, uses 1/2 votes to get quorum. Use with caution!",
    "privacy": "Public",
    "value": false
  },
  "consensus_manager_config.broadcast_buffer_size": {
    "description": "The buffer size for the broadcast channel.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.cende_config.recorder_url": {
    "description": "The URL of the Pythonic cende_recorder",
    "pointer_target": "recorder_url",
    "privacy": "Private"
  },
  "consensus_manager_config.cende_config.skip_write_height": {
    "description": "A height that the consensus can skip writing to Aerospike. Needed for booting up (no previous height blob to write) or to handle extreme cases (all the nodes failed).",
    "privacy": "Public",
    "value": 0
  },
  "consensus_manager_config.cende_config.skip_write_height.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.consensus_manager_config.future_height_limit": {
    "description": "How many heights in the future should we cache.",
    "privacy": "Public",
    "value": 10
  },
  "consensus_manager_config.consensus_manager_config.future_height_round_limit": {
    "description": "How many rounds should we cache for future heights.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.consensus_manager_config.future_round_limit": {
    "description": "How many rounds in the future (for current height) should we cache.",
    "privacy": "Public",
    "value": 10
  },
  "consensus_manager_config.consensus_manager_config.startup_delay": {
    "description": "Delay (seconds) before starting consensus to give time for network peering.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_manager_config.sync_retry_interval": {
    "description": "The duration (seconds) between sync attempts.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_manager_config.timeouts.precommit_timeout": {
    "description": "The timeout (seconds) for a precommit.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_manager_config.timeouts.prevote_timeout": {
    "description": "The timeout (seconds) for a prevote.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_manager_config.timeouts.proposal_timeout": {
    "description": "The timeout (seconds) for a proposal.",
    "privacy": "Public",
    "value": 3.0
  },
  "consensus_manager_config.consensus_manager_config.validator_id": {
    "description": "The validator id of the node.",
    "pointer_target": "validator_id",
    "privacy": "Public"
  },
  "consensus_manager_config.context_config.block_timestamp_window_seconds": {
    "description": "Maximum allowed deviation (seconds) of a proposed block's timestamp from the current time.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.context_config.build_proposal_margin_millis": {
    "description": "Safety margin (in ms) to make sure that the batcher completes building the proposal with enough time for the Fin to be checked by validators.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.context_config.builder_address": {
    "description": "The address of the contract that builds the block.",
    "privacy": "Public",
    "value": "0x0"
  },
  "consensus_manager_config.context_config.chain_id": {
    "description": "The chain id of the Starknet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.context_config.constant_l2_gas_price": {
    "description": "If true, sets STRK gas price to its minimum price from the versioned constants.",
    "privacy": "Public",
    "value": false
  },
  "consensus_manager_config.context_config.l1_da_mode": {
    "description": "The data availability mode, true: Blob, false: Calldata.",
    "privacy": "Public",
    "value": true
  },
  "consensus_manager_config.context_config.l1_data_gas_price_multiplier_ppt": {
    "description": "Part per thousand of multiplicative factor to apply to the data gas price, to enable fine-tuning of the price charged to end users.",
    "privacy": "Public",
    "value": 135
  },
  "consensus_manager_config.context_config.l1_gas_tip_wei": {
    "description": "This additional gas is added to the L1 gas price.",
    "privacy": "Public",
    "value": 1000000000
  },
  "consensus_manager_config.context_config.max_l1_data_gas_price_wei": {
    "description": "The maximum L1 data gas price in wei.",
    "privacy": "Public",
    "value": 1000000000000000000
  },
  "consensus_manager_config.context_config.max_l1_gas_price_wei": {
    "description": "The maximum L1 gas price in wei.",
    "privacy": "Public",
    "value": 200000000000
  },
  "consensus_manager_config.context_config.min_l1_data_gas_price_wei": {
    "description": "The minimum L1 data gas price in wei.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.context_config.min_l1_gas_price_wei": {
    "description": "The minimum L1 gas price in wei.",
    "privacy": "Public",
    "value": 1000000000
  },
  "consensus_manager_config.context_config.num_validators": {
    "description": "The number of validators.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.context_config.proposal_buffer_size": {
    "description": "The buffer size for streaming outbound proposals.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.context_config.validate_proposal_margin_millis": {
    "description": "Safety margin (in ms) to make sure that consensus determines when to timeout validating a proposal.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.immediate_active_height": {
    "description": "The height at which the node may actively participate in consensus.",
    "privacy": "Public",
    "value": 0
  },
  "consensus_manager_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.network_config.broadcasted_message_metadata_buffer_size": {
    "description": "The size of the buffer that holds the metadata of the broadcasted messages.",
    "privacy": "Public",
    "value": 100000
  },
  "consensus_manager_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.network_config.reported_peer_ids_buffer_size": {
    "description": "The size of the buffer that holds the reported peer ids.",
    "privacy": "Public",
    "value": 100000
  },
  "consensus_manager_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "consensus_manager_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.proposals_topic": {
    "description": "The topic for consensus proposals.",
    "privacy": "Public",
    "value": "consensus_proposals"
  },
  "consensus_manager_config.revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "pointer_target": "revert_config.revert_up_to_and_including",
    "privacy": "Public"
  },
  "consensus_manager_config.revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "pointer_target": "revert_config.should_revert",
    "privacy": "Public"
  },
  "consensus_manager_config.stream_handler_config.channel_buffer_capacity": {
    "description": "The capacity of the channel buffer for stream messages.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.stream_handler_config.max_streams": {
    "description": "The maximum number of streams that can be open at the same time.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.votes_topic": {
    "description": "The topic for consensus votes.",
    "privacy": "Public",
    "value": "consensus_votes"
  },
  "eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "gateway_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "gateway_config.authorized_declarer_accounts": {
    "description": "Authorized declarer accounts. If set, only these accounts can declare new contracts. Addresses are in hex format and separated by a comma with no space.",
    "privacy": "Public",
    "value": ""
  },
  "gateway_config.authorized_declarer_accounts.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "gateway_config.block_declare": {
    "description": "If true, the gateway will block declare transactions.",
    "privacy": "Public",
    "value": false
  },
  "gateway_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.max_allowed_nonce_gap": {
    "description": "The maximum allowed gap between the account nonce and the transaction nonce.",
    "privacy": "Public",
    "value": 50
  },
  "gateway_config.stateful_tx_validator_config.max_nonce_for_validation_skip": {
    "description": "Maximum nonce for which the validation is skipped.",
    "privacy": "Public",
    "value": "0x1"
  },
  "gateway_config.stateful_tx_validator_config.min_gas_price_percentage": {
    "description": "Minimum gas price as percentage of threshold to accept transactions.",
    "privacy": "Public",
    "value": 100
  },
  "gateway_config.stateful_tx_validator_config.reject_future_declare_txs": {
    "description": "If true, rejects declare transactions with future nonces.",
    "privacy": "Public",
    "value": true
  },
  "gateway_config.stateful_tx_validator_config.validate_resource_bounds": {
    "description": "If true, ensures the max L2 gas price exceeds (a configurable percentage of) the base gas price of the previous block.",
    "pointer_target": "validate_resource_bounds",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateless_tx_validator_config.max_calldata_length": {
    "description": "Limitation of calldata length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.max_contract_bytecode_size": {
    "description": "Limitation of contract class bytecode size.",
    "privacy": "Public",
    "value": 81920
  },
  "gateway_config.stateless_tx_validator_config.max_contract_class_object_size": {
    "description": "Limitation of contract class object size.",
    "privacy": "Public",
    "value": 4089446
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 5
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "gateway_config.stateless_tx_validator_config.max_signature_length": {
    "description": "Limitation of signature length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.min_gas_price": {
    "description": "Minimum gas price for transactions.",
    "privacy": "Public",
    "value": 3000000000
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 0
  },
  "gateway_config.stateless_tx_validator_config.validate_resource_bounds": {
    "description": "If true, ensures that at least one resource bound (L1, L2, or L1 data) is greater than zero.",
    "pointer_target": "validate_resource_bounds",
    "privacy": "Public"
  },
  "http_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "http_server_config.ip": {
    "description": "The http server ip.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "http_server_config.port": {
    "description": "The http server port.",
    "privacy": "Public",
    "value": 8080
  },
  "l1_endpoint_monitor_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "l1_endpoint_monitor_config.ordered_l1_endpoint_urls": {
    "description": "Ordered list of L1 endpoint URLs, used in order, cyclically, switching if the current one is non-operational.",
    "privacy": "Private",
    "value": "https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY"
  },
  "l1_endpoint_monitor_config.timeout_millis": {
    "description": "The timeout (milliseconds) for a query of the L1 base layer",
    "privacy": "Public",
    "value": 1000
  },
  "l1_gas_price_provider_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "l1_gas_price_provider_config.eth_to_strk_oracle_config.lag_interval_seconds": {
    "description": "The size of the interval (seconds) that the eth to strk rate is taken on. The lag refers to the fact that the interval `[T, T+k)` contains the conversion rate for queries in the interval `[T+k, T+2k)`. Should be configured in alignment with relevant query parameters in `url_header_list`, if required.",
    "privacy": "Public",
    "value": 1
  },
  "l1_gas_price_provider_config.eth_to_strk_oracle_config.max_cache_size": {
    "description": "The maximum number of cached conversion rates.",
    "privacy": "Public",
    "value": 100
  },
  "l1_gas_price_provider_config.eth_to_strk_oracle_config.query_timeout_sec": {
    "description": "The timeout (seconds) for the query to the eth to strk oracle.",
    "privacy": "Public",
    "value": 3
  },
  "l1_gas_price_provider_config.eth_to_strk_oracle_config.url_header_list": {
    "description": "A list of Url+HTTP headers for the eth to strk oracle. The url is followed by a comma and then headers as key^value pairs, separated by commas. For example: `https://api.example.com/api,key1^value1,key2^value2`. Each URL+headers is separated by a pipe `|` character. The `timestamp` parameter is appended dynamically when making requests, in order to have a stable mapping from block timestamp to conversion rate. ",
    "privacy": "Private",
    "value": "https://api.example.com/api"
  },
  "l1_gas_price_provider_config.lag_margin_seconds": {
    "description": "Difference between the time of the block from L1 used to calculate the gas price and the time of the L2 block this price is used in",
    "privacy": "Public",
    "value": 60
  },
  "l1_gas_price_provider_config.max_time_gap_seconds": {
    "description": "Maximum valid time gap between the requested timestamp and the last price sample in seconds",
    "privacy": "Public",
    "value": 900
  },
  "l1_gas_price_provider_config.number_of_blocks_for_mean": {
    "description": "Number of blocks to use for the mean gas price calculation",
    "privacy": "Public",
    "value": 300
  },
  "l1_gas_price_provider_config.storage_limit": {
    "description": "Maximum number of L1 blocks to keep cached",
    "privacy": "Public",
    "value": 3000
  },
  "l1_gas_price_scraper_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "l1_gas_price_scraper_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "l1_gas_price_scraper_config.finality": {
    "description": "Number of blocks to wait for finality in L1",
    "privacy": "Public",
    "value": 0
  },
  "l1_gas_price_scraper_config.number_of_blocks_for_mean": {
    "description": "Number of blocks to use for the mean gas price calculation",
    "privacy": "Public",
    "value": 300
  },
  "l1_gas_price_scraper_config.polling_interval": {
    "description": "The duration (seconds) between each scraping attempt of L1",
    "privacy": "Public",
    "value": 1
  },
  "l1_gas_price_scraper_config.starting_block": {
    "description": "Starting block to scrape from",
    "privacy": "Public",
    "value": 0
  },
  "l1_gas_price_scraper_config.starting_block.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_gas_price_scraper_config.startup_num_blocks_multiplier": {
    "description": "How many sets of config.num_blocks_for_mean blocks to go back on the chain when starting to scrape.",
    "privacy": "Public",
    "value": 2
  },
  "l1_provider_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "l1_provider_config.bootstrap_catch_up_height_override": {
    "description": "Override height at which the provider should catch up to the bootstrapper.",
    "privacy": "Public",
    "value": 0
  },
  "l1_provider_config.bootstrap_catch_up_height_override.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_provider_config.dummy_mode": {
    "description": "When true, the L1 provider operates in dummy mode, always responding with trivial truthy responses without connecting to actual L1.",
    "privacy": "Public",
    "value": false
  },
  "l1_provider_config.l1_handler_cancellation_timelock_seconds": {
    "description": "How long to allow a transaction requested for cancellation to be validated against (proposals are banned upon receiving a cancellation request).",
    "privacy": "Public",
    "value": 300
  },
  "l1_provider_config.new_l1_handler_cooldown_seconds": {
    "description": "How long to wait before allowing new L1 handler transactions to be proposed (validation is available immediately).",
    "privacy": "Public",
    "value": 245
  },
  "l1_provider_config.provider_startup_height_override": {
    "description": "Override height at which the provider should start",
    "privacy": "Public",
    "value": 0
  },
  "l1_provider_config.provider_startup_height_override.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_provider_config.startup_sync_sleep_retry_interval_seconds": {
    "description": "Interval in seconds between each retry of syncing with L2 during startup.",
    "privacy": "Public",
    "value": 2
  },
  "l1_scraper_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "l1_scraper_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "l1_scraper_config.finality": {
    "description": "Number of blocks to wait for finality",
    "privacy": "Public",
    "value": 0
  },
  "l1_scraper_config.polling_interval_seconds": {
    "description": "Interval in Seconds between each scraping attempt of L1.",
    "privacy": "Public",
    "value": 120
  },
  "l1_scraper_config.startup_rewind_time_seconds": {
    "description": "Duration in seconds to rewind from latest L1 block when starting scraping.",
    "privacy": "Public",
    "value": 3600
  },
  "mempool_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "mempool_config.capacity_in_bytes": {
    "description": "Maximum size of the mempool, in bytes.",
    "privacy": "Public",
    "value": 1073741824
  },
  "mempool_config.committed_nonce_retention_block_count": {
    "description": "Number of latest committed blocks for which committed account nonces are retained.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_config.declare_delay": {
    "description": "Time to wait before allowing a Declare transaction to be returned, in seconds.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_config.enable_fee_escalation": {
    "description": "If true, transactions can be replaced with higher fee transactions.",
    "privacy": "Public",
    "value": true
  },
  "mempool_config.fee_escalation_percentage": {
    "description": "Percentage increase for tip and max gas price to enable transaction replacement.",
    "privacy": "Public",
    "value": 10
  },
  "mempool_config.transaction_ttl": {
    "description": "Time-to-live for transactions in the mempool, in seconds.",
    "privacy": "Public",
    "value": 60
  },
  "mempool_config.validate_resource_bounds": {
    "description": "If true, only transactions with max L2 gas price per unit bound that are above the threshold are inserted into the priority queue. If false, all transactions are inserted into the priority queue.",
    "pointer_target": "validate_resource_bounds",
    "privacy": "Public"
  },
  "mempool_p2p_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "mempool_p2p_config.max_transaction_batch_size": {
    "description": "Maximum number of transactions in each batch.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_p2p_config.network_buffer_size": {
    "description": "Network buffer size.",
    "privacy": "Public",
    "value": 10000
  },
  "mempool_p2p_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.broadcasted_message_metadata_buffer_size": {
    "description": "The size of the buffer that holds the metadata of the broadcasted messages.",
    "privacy": "Public",
    "value": 100000
  },
  "mempool_p2p_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_p2p_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_p2p_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "mempool_p2p_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 11111
  },
  "mempool_p2p_config.network_config.reported_peer_ids_buffer_size": {
    "description": "The size of the buffer that holds the reported peer ids.",
    "privacy": "Public",
    "value": 100000
  },
  "mempool_p2p_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "mempool_p2p_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.transaction_batch_rate_millis": {
    "description": "Maximum time until a transaction batch is closed and propagated in milliseconds.",
    "privacy": "Public",
    "value": 1000
  },
  "monitoring_config.collect_metrics": {
    "description": "Indicating if metrics should be recorded.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_config.collect_profiling_metrics": {
    "description": "Indicating if profiling metrics should be collected.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "monitoring_endpoint_config.collect_metrics": {
    "description": "If true, collect and return metrics in the monitoring endpoint.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.collect_profiling_metrics": {
    "description": "If true, collect and return profiling metrics in the monitoring endpoint.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.ip": {
    "description": "The monitoring endpoint ip address.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "monitoring_endpoint_config.port": {
    "description": "The monitoring endpoint port.",
    "privacy": "Public",
    "value": 8082
  },
  "recorder_url": {
    "description": "The URL of the Pythonic cende_recorder",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "privacy": "TemporaryValue",
    "value": 18446744073709551615
  },
  "revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "sierra_compiler_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "sierra_compiler_config.max_bytecode_size": {
    "description": "Limitation of compiled CASM bytecode size (felts).",
    "privacy": "Public",
    "value": 81920
  },
  "sierra_compiler_config.max_memory_usage": {
    "description": "Limitation of compilation process's virtual memory (bytes).",
    "privacy": "Public",
    "value": 5368709120
  },
  "sierra_compiler_config.max_memory_usage.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "starknet_url": {
    "description": "URL for communicating with Starknet.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "state_sync_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "state_sync_config.central_sync_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.central_sync_client_config.central_source_config.class_cache_size": {
    "description": "Size of class cache, must be a positive integer.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.central_sync_client_config.central_source_config.concurrent_requests": {
    "description": "Maximum number of concurrent requests to Starknet feeder-gateway for getting a type of data (for example, blocks).",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.central_source_config.http_headers": {
    "description": "'k1:v1 k2:v2 ...' headers for SN-client.",
    "privacy": "Private",
    "value": ""
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_classes_to_download": {
    "description": "Maximum number of classes to download at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_state_updates_to_download": {
    "description": "Maximum number of state updates to download at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_state_updates_to_store_in_memory": {
    "description": "Maximum number of state updates to store in memory at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.max_retries": {
    "description": "Maximum number of retries before the node stops retrying.",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.retry_base_millis": {
    "description": "Base waiting time after a failed request. After that, the time increases exponentially.",
    "privacy": "Public",
    "value": 30
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.retry_max_delay_millis": {
    "description": "Max waiting time after a failed request.",
    "privacy": "Public",
    "value": 30000
  },
  "state_sync_config.central_sync_client_config.central_source_config.starknet_url": {
    "description": "Starknet feeder-gateway URL. It should match chain_id.",
    "pointer_target": "starknet_url",
    "privacy": "Public"
  },
  "state_sync_config.central_sync_client_config.sync_config.base_layer_propagation_sleep_duration": {
    "description": "Time in seconds to poll the base layer to get the latest proved block.",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.sync_config.block_propagation_sleep_duration": {
    "description": "Time in seconds before checking for a new block after the node is synchronized.",
    "privacy": "Public",
    "value": 2
  },
  "state_sync_config.central_sync_client_config.sync_config.blocks_max_stream_size": {
    "description": "Max amount of blocks to download in a stream.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.central_sync_client_config.sync_config.collect_pending_data": {
    "description": "Whether to collect data on pending blocks.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.central_sync_client_config.sync_config.recoverable_error_sleep_duration": {
    "description": "Waiting time in seconds before restarting synchronization after a recoverable error.",
    "privacy": "Public",
    "value": 3
  },
  "state_sync_config.central_sync_client_config.sync_config.state_updates_max_stream_size": {
    "description": "Max amount of state updates to download in a stream.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.central_sync_client_config.sync_config.store_sierras_and_casms": {
    "description": "Whether to store sierras and casms to the storage. This allows maintaining backward-compatibility with native-blockifier",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.central_sync_client_config.sync_config.verify_blocks": {
    "description": "Whether to verify incoming blocks.",
    "privacy": "Public",
    "value": true
  },
  "state_sync_config.network_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "state_sync_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.broadcasted_message_metadata_buffer_size": {
    "description": "The size of the buffer that holds the metadata of the broadcasted messages.",
    "privacy": "Public",
    "value": 100000
  },
  "state_sync_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "state_sync_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 12345
  },
  "state_sync_config.network_config.reported_peer_ids_buffer_size": {
    "description": "The size of the buffer that holds the reported peer ids.",
    "privacy": "Public",
    "value": 100000
  },
  "state_sync_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "state_sync_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.p2p_sync_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "state_sync_config.p2p_sync_client_config.buffer_size": {
    "description": "Size of the buffer for read from the storage and for incoming responses.",
    "privacy": "Public",
    "value": 100000
  },
  "state_sync_config.p2p_sync_client_config.num_block_classes_per_query": {
    "description": "The maximum amount of block's classes to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_state_diffs_per_query": {
    "description": "The maximum amount of block's state diffs to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_transactions_per_query": {
    "description": "The maximum amount of blocks to ask their transactions from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_headers_per_query": {
    "description": "The maximum amount of headers to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 10000
  },
  "state_sync_config.p2p_sync_client_config.wait_period_for_new_data": {
    "description": "Time in millisseconds to wait when a query returned with partial data before sending a new query",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.p2p_sync_client_config.wait_period_for_other_protocol": {
    "description": "Time in millisseconds to wait for a dependency protocol to advance (e.g.state diff sync depends on header sync)",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "pointer_target": "revert_config.revert_up_to_and_including",
    "privacy": "Public"
  },
  "state_sync_config.revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "pointer_target": "revert_config.should_revert",
    "privacy": "Public"
  },
  "state_sync_config.rpc_config.apollo_gateway_retry_config.max_retries": {
    "description": "For communicating with Starknet gateway, maximum number of retries before the node stops retrying.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.rpc_config.apollo_gateway_retry_config.retry_base_millis": {
    "description": "For communicating with Starknet gateway, base waiting time after a failed request. After that, the time increases exponentially.",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.rpc_config.apollo_gateway_retry_config.retry_max_delay_millis": {
    "description": "For communicating with Starknet gateway, max waiting time after a failed request.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.rpc_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.rpc_config.collect_metrics": {
    "description": "If true, collect metrics for the rpc.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.rpc_config.execution_config.default_initial_gas_cost": {
    "description": "The initial gas cost for a transaction",
    "privacy": "Public",
    "value": 10000000000
  },
  "state_sync_config.rpc_config.execution_config.eth_fee_contract_address": {
    "description": "The eth fee token address to receive fees",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "state_sync_config.rpc_config.execution_config.strk_fee_contract_address": {
    "description": "The strk fee token address to receive fees",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "state_sync_config.rpc_config.ip": {
    "description": "The JSON RPC server ip.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "state_sync_config.rpc_config.max_events_chunk_size": {
    "description": "Maximum chunk size supported by the node in get_events requests.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.rpc_config.max_events_keys": {
    "description": "Maximum number of keys supported by the node in get_events requests.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.rpc_config.port": {
    "description": "The JSON RPC server port.",
    "privacy": "Public",
    "value": 8090
  },
  "state_sync_config.rpc_config.starknet_url": {
    "description": "URL for communicating with Starknet in write_api methods.",
    "pointer_target": "starknet_url",
    "privacy": "Public"
  },
  "state_sync_config.storage_config.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.storage_config.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.storage_config.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "state_sync_config.storage_config.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "state_sync_config.storage_config.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "/data/state_sync"
  },
  "state_sync_config.storage_config.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "state_sync_config.storage_config.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "state_sync_config.storage_config.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "FullArchive"
  },
  "strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "validate_resource_bounds": {
    "description": "Indicates that validations related to resource bounds are applied. It should be set to false during a system bootstrap.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "validator_id": {
    "description": "The ID of the validator. Also the address of this validator as a starknet contract.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 10000000
  },
  "versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "privacy": "TemporaryValue",
    "value": 1000
  },
  "versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "privacy": "TemporaryValue",
    "value": 50
  },
  "versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 1000000
  }
}
