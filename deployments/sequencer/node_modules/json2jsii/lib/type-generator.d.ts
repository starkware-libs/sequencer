import { JSONSchema4 } from 'json-schema';
import { Code } from './code';
export interface TypeGeneratorOptions {
    /**
     * Patterns of type FQNs to exclude.
     * @default - include all types
     */
    readonly exclude?: string[];
    /**
     * Schema definitions for resolving $refs
     * @default - $refs are not supported
     */
    readonly definitions?: {
        [def: string]: JSONSchema4;
    };
    /**
     * Generate `toJson_Xyz` functions for all types which convert data objects
     * back to schema-compatible JSON.
     *
     * These functions are required since property names in generated structs are
     * camel cased in order to be compatible with JSII, and this is a lossy
     * conversion, so the toJson functions are required to convert the data back
     * to a schema-compatible data objects.
     *
     * @default true
     */
    readonly toJson?: boolean;
    /**
     * When set to true, enums are sanitized from the 'null' literal value,
     * allowing typing the property as an enum, instead of the underlying type.
     *
     * Note that switching this from 'false' to 'true' is a breaking change in
     * the generated code as it might change a property type.
     *
     * @default false
     */
    readonly sanitizeEnums?: boolean;
    /**
     * Given a definition name, render the type name to be emitted by that definition.
     *
     * When `emitType` is invoked, the type name to be emitted is provided by the caller.
     * However, for complex types containing references to other types, we infer the type name of the reference
     * by looking at the definition name of the `$ref` attribute.
     *
     * This function provides a way to control how those definition names translate into type name.
     *
     * For example, if a complex type references a namespaced definition like `api.group.Foo`, we'd like to control
     * how to translate `api.group.Foo`, which is an illegal typename, into a legal one.
     *
     * @default - Only dot namespacing is handled by default. Elements between dots are pascal cased and concatenated.
     */
    readonly renderTypeName?: (def: string) => string;
}
/**
 * Generates typescript types from JSON schemas.
 */
export declare class TypeGenerator {
    /**
     * Convert all-caps acronyms (e.g. "VPC", "FooBARZooFIGoo") to pascal case
     * (e.g. "Vpc", "FooBarZooFiGoo").
     */
    static normalizeTypeName(typeName: string): string;
    /**
     * Renders a JSII struct (and accompanying types) from a JSON schema.
     *
     * If you wish to render multiple top-level structs or include custom types,
     * create a new instance of `TypeGenerator` manually.
     *
     * @param structName The name of the JSII struct (TypeScript interface).
     * @param schema The JSON schema (top level schema must include "properties")
     * @returns Generated TypeScript source code that includes the top-level
     * struct and all other types.
     */
    static forStruct(structName: string, schema: JSONSchema4, options?: TypeGeneratorOptions): TypeGenerator;
    private readonly typesToEmit;
    private readonly emittedTypes;
    private readonly emittedProperties;
    private readonly exclude;
    private readonly definitions;
    private readonly toJson;
    private readonly sanitizeEnums;
    private readonly renderTypeName;
    /**
     *
     * @param schema Schema definitions
     * @param options
     */
    constructor(options?: TypeGeneratorOptions);
    /**
     * Adds a JSON schema definition for a type name. This method does not emit the type
     * but rather just registers the definition that will get resolved if this type is `$ref`ed.
     *
     * @param typeName The name of the type.
     * @param def The JSON schema definition for this type
     */
    addDefinition(typeName: string, def: JSONSchema4): void;
    /**
     * Overrides the definition of `fromTypeName` such that any references to it
     * will be resolved as `toTypeName`. Bear in mind that the type name specified
     * in `to` must either be defined as a definition (`addDefinition()`) _or_
     * emitted as a custom type (`emitCustomType()`).
     */
    addAlias(from: string, to: string): void;
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitType(typeName: string, def?: JSONSchema4, structFqn?: string): string;
    /**
     * Many schemas define a type as an array of types to indicate union types.
     * To avoid having the type generator be aware of that, we transform those types
     * into their corresponding typescript definitions.
     * --------------------------------------------------
     *
     * Strictly speaking, these definitions are meant to allow the liternal 'null' value
     * to be used in addition to the actual types. However, since union types are not supported
     * in jsii, allowing this would mean falling back to 'any' and loosing all type safety for such
     * properties. Transforming it into a single concrete optional type provides both type safety and
     * the option to omit the property. What it doesn't allow is explicitly passing 'null', which might
     * be desired in some cases. For now we prefer type safety over that.
     *
     * 1. ['null', '<type>'] -> optional '<type>'
     * 2. ['null', '<type1>', '<type2>'] -> optional 'any'
     *
     * This is the normal jsii conversion, nothing much we can do here.
     *
     * 3. ['<type1>', '<type2>'] -> 'any'
     */
    private maybeTransformTypeArray;
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    private emitTypeInternal;
    /**
     * Registers a custom type and emits it. This will override any existing
     * definitions for this type name.
     *
     * @param typeName The name of the type emitted by this handler.
     * @param emitter A function that will be called to emit the code and returns
     * information about the emitted type.
     */
    emitCustomType(typeName: string, emitter: TypeEmitter | CodeEmitter): void;
    /**
     * @deprecated use `emitCustomType()`
     */
    addCode(typeName: string, emitter: TypeEmitter | CodeEmitter): void;
    /**
     * Renders all emitted types to a string.
     *
     * Use `renderToCode()` in order to render output to an existing `Code` object.
     */
    render(): string;
    /**
     * Writes all types to a `CodeMaker` with an open file.
     * Use this method in case you need to add those type to an existing file.
     * @param code The `CodeMaker` instance.
     */
    renderToCode(code: Code): void;
    /**
     * @deprecated use `renderToCode()`
     */
    emitCode(code: Code): void;
    /**
     * @deprecated use `emitType()`
     */
    addType(typeName: string, def?: JSONSchema4, structFqn?: string): string;
    /**
     * Emits an array.
     */
    private emitArray;
    /**
     * @returns true if this definition can be represented as a union or false if it cannot
     */
    private tryEmitUnion;
    private emitStruct;
    private propertyFqn;
    private emitProperty;
    private emitEnum;
    private emitDescription;
    private typeForProperty;
    private typeForRef;
    private typeForArray;
    private resolveReference;
    private isPropertyRequired;
    private isExcluded;
}
interface EmittedType {
    /**
     * The JavaScript type to emit.
     */
    readonly type: string;
    /**
     * Returns the code to convert a statement `s` back to JSON.
     */
    readonly toJson: (code: string) => string;
}
type TypeEmitter = (code: Code) => EmittedType;
type CodeEmitter = (code: Code) => void;
export {};
