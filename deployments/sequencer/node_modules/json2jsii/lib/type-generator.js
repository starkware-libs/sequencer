"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenerator = void 0;
const camelcase_1 = __importDefault(require("camelcase"));
const snake_case_1 = require("snake-case");
const allowlist_1 = require("./allowlist");
const code_1 = require("./code");
const tojson_1 = require("./tojson");
const PRIMITIVE_TYPES = ['string', 'number', 'integer', 'boolean'];
const DEFINITIONS_PREFIX = '#/definitions/';
const DEFAULT_RENDER_TYPE_NAME = (s) => s.split('.').map(x => pascalCase(x)).join('');
/**
 * Generates typescript types from JSON schemas.
 */
class TypeGenerator {
    /**
     * Convert all-caps acronyms (e.g. "VPC", "FooBARZooFIGoo") to pascal case
     * (e.g. "Vpc", "FooBarZooFiGoo").
     */
    static normalizeTypeName(typeName) {
        // Handle kebab-case first
        const stage1 = typeName.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
        // start with the full string and then use the regex to match all-caps sequences.
        const re = /([A-Z]+)(?:[^a-z]|$)/g;
        let result = stage1;
        let m;
        do {
            m = re.exec(stage1);
            if (m) {
                const before = result.slice(0, m.index); // all the text before the sequence
                const cap = m[1]; // group #1 matches the all-caps sequence we are after
                const pascal = cap[0] + cap.slice(1).toLowerCase(); // convert to pascal case by lowercasing all but the first char
                const after = result.slice(m.index + pascal.length); // all the text after the sequence
                result = before + pascal + after; // concat
            }
        } while (m);
        result = result.replace(/^./, result[0].toUpperCase()); // ensure first letter is capitalized
        return result;
    }
    /**
     * Renders a JSII struct (and accompanying types) from a JSON schema.
     *
     * If you wish to render multiple top-level structs or include custom types,
     * create a new instance of `TypeGenerator` manually.
     *
     * @param structName The name of the JSII struct (TypeScript interface).
     * @param schema The JSON schema (top level schema must include "properties")
     * @returns Generated TypeScript source code that includes the top-level
     * struct and all other types.
     */
    static forStruct(structName, schema, options = {}) {
        const gen = new TypeGenerator({ definitions: schema.definitions, ...options });
        gen.emitType(structName, schema);
        return gen;
    }
    /**
     *
     * @param schema Schema definitions
     * @param options
     */
    constructor(options = {}) {
        var _a, _b, _c, _d, _e;
        this.typesToEmit = {};
        this.emittedTypes = {};
        this.emittedProperties = new Set();
        this.exclude = (_a = options.exclude) !== null && _a !== void 0 ? _a : [];
        this.definitions = {};
        this.toJson = (_b = options.toJson) !== null && _b !== void 0 ? _b : true;
        this.sanitizeEnums = (_c = options.sanitizeEnums) !== null && _c !== void 0 ? _c : false;
        this.renderTypeName = (_d = options.renderTypeName) !== null && _d !== void 0 ? _d : DEFAULT_RENDER_TYPE_NAME;
        for (const [typeName, def] of Object.entries((_e = options.definitions) !== null && _e !== void 0 ? _e : {})) {
            this.addDefinition(typeName, def);
        }
    }
    /**
     * Adds a JSON schema definition for a type name. This method does not emit the type
     * but rather just registers the definition that will get resolved if this type is `$ref`ed.
     *
     * @param typeName The name of the type.
     * @param def The JSON schema definition for this type
     */
    addDefinition(typeName, def) {
        this.definitions[typeName] = def;
    }
    /**
     * Overrides the definition of `fromTypeName` such that any references to it
     * will be resolved as `toTypeName`. Bear in mind that the type name specified
     * in `to` must either be defined as a definition (`addDefinition()`) _or_
     * emitted as a custom type (`emitCustomType()`).
     */
    addAlias(from, to) {
        this.addDefinition(from, { $ref: `#/definitions/${to}` });
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitType(typeName, def, structFqn = typeName) {
        return this.emitTypeInternal(typeName, def, structFqn).type;
    }
    /**
     * Many schemas define a type as an array of types to indicate union types.
     * To avoid having the type generator be aware of that, we transform those types
     * into their corresponding typescript definitions.
     * --------------------------------------------------
     *
     * Strictly speaking, these definitions are meant to allow the liternal 'null' value
     * to be used in addition to the actual types. However, since union types are not supported
     * in jsii, allowing this would mean falling back to 'any' and loosing all type safety for such
     * properties. Transforming it into a single concrete optional type provides both type safety and
     * the option to omit the property. What it doesn't allow is explicitly passing 'null', which might
     * be desired in some cases. For now we prefer type safety over that.
     *
     * 1. ['null', '<type>'] -> optional '<type>'
     * 2. ['null', '<type1>', '<type2>'] -> optional 'any'
     *
     * This is the normal jsii conversion, nothing much we can do here.
     *
     * 3. ['<type1>', '<type2>'] -> 'any'
     */
    maybeTransformTypeArray(def) {
        if (!Array.isArray(def.type)) {
            return;
        }
        const nullType = def.type.some(t => t === 'null');
        const nonNullTypes = new Set(def.type.filter(t => t !== 'null'));
        if (nullType) {
            def.required = false;
        }
        if (nonNullTypes.size === 0) {
            def.type = 'null';
        }
        else {
            // if its a union of non null types we use 'any' to be jsii compliant
            def.type = nonNullTypes.size > 1 ? 'any' : nonNullTypes.values().next().value;
        }
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitTypeInternal(typeName, def, structFqn = typeName) {
        if (!def) {
            def = this.definitions[typeName];
            if (!def) {
                throw new Error(`unable to find schema definition for ${typeName}`);
            }
        }
        this.maybeTransformTypeArray(def);
        if (def.enum && this.sanitizeEnums) {
            // santizie enums from liternal 'null' because they prevent emitting the enum
            // and instead cause a fallback to 'string'. we assume the optionality of the enum
            // covers the 'null' value.
            def.enum = def.enum.filter(d => d !== null);
        }
        // callers expect that emit a type named `typeName` so we can't change it here
        // but at least we can verify it's correct.
        if (TypeGenerator.normalizeTypeName(typeName) !== typeName) {
            throw new Error(`${typeName} must be normalized before calling emitType`);
        }
        if (structFqn.startsWith(DEFINITIONS_PREFIX)) {
            structFqn = structFqn.substring(DEFINITIONS_PREFIX.length);
        }
        if (this.isExcluded(structFqn)) {
            throw new Error(`Type ${structFqn} cannot be added since it matches one of the exclusion patterns`);
        }
        // complex type
        if (def.$ref) {
            return this.typeForRef(def);
        }
        // unions (unless this is a struct, and then we just ignore the constraints)
        if (def.oneOf || def.anyOf) {
            const asUnion = this.tryEmitUnion(typeName, def, structFqn);
            if (asUnion) {
                return asUnion;
            }
            // carry on, we can't represent this schema as a union (yet?)
        }
        // dates
        if (def.format === 'date-time') {
            if (def.type && def.type !== 'string') {
                throw new Error('date-time must be a string');
            }
            return { type: 'Date', toJson: x => `${x}?.toISOString()` };
        }
        // enums
        if (def.enum && Array.isArray(def.enum) && def.enum.length > 0 && def.enum.every(x => ['string', 'number'].includes(typeof (x)))) {
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            return this.emitEnum(typeName, def, structFqn);
        }
        // struct
        if (def.properties) {
            if (def.type && def.type !== 'object') {
                throw new Error('for "properties", if "type" is specified it has to be an "object"');
            }
            return this.emitStruct(typeName, def, structFqn);
        }
        // map
        if (def.additionalProperties && typeof (def.additionalProperties) === 'object') {
            if (def.type && def.type !== 'object') {
                throw new Error('for "additionalProperties", if "type" is specified it has to be an "object"');
            }
            const et = this.typeForProperty(typeName, def.additionalProperties);
            const toJson = (x) => `((${x}) === undefined) ? undefined : (Object.entries(${x}).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: ${et.toJson('i[1]')} }), {}))`;
            return { type: `{ [key: string]: ${et.type} }`, toJson };
        }
        switch (def.type) {
            case 'string':
                return { type: 'string', toJson: x => x };
            case 'number':
            case 'integer':
                return { type: 'number', toJson: x => x };
            case 'boolean':
                return { type: 'boolean', toJson: (x) => x };
            case 'array': {
                return this.emitArray(typeName, def);
            }
        }
        return { type: 'any', toJson: x => x };
    }
    /**
     * Registers a custom type and emits it. This will override any existing
     * definitions for this type name.
     *
     * @param typeName The name of the type emitted by this handler.
     * @param emitter A function that will be called to emit the code and returns
     * information about the emitted type.
     */
    emitCustomType(typeName, emitter) {
        if (typeName in this.emittedTypes) {
            return;
        }
        this.typesToEmit[typeName] = code => {
            const result = emitter(code);
            if (typeof (result) === 'object') {
                return result;
            }
            else {
                return { type: typeName, toJson: x => x };
            }
        };
    }
    /**
     * @deprecated use `emitCustomType()`
     */
    addCode(typeName, emitter) {
        return this.emitCustomType(typeName, emitter);
    }
    /**
     * Renders all emitted types to a string.
     *
     * Use `renderToCode()` in order to render output to an existing `Code` object.
     */
    render() {
        const code = new code_1.Code();
        this.renderToCode(code);
        return code.render();
    }
    /**
     * Writes all types to a `CodeMaker` with an open file.
     * Use this method in case you need to add those type to an existing file.
     * @param code The `CodeMaker` instance.
     */
    renderToCode(code) {
        while (Object.keys(this.typesToEmit).length) {
            const name = Object.keys(this.typesToEmit)[0];
            const emitter = this.typesToEmit[name];
            const emittedType = emitter(code);
            code.line();
            delete this.typesToEmit[name];
            this.emittedTypes[name] = emittedType;
        }
    }
    /**
     * @deprecated use `renderToCode()`
     */
    emitCode(code) {
        return this.renderToCode(code);
    }
    /**
     * @deprecated use `emitType()`
     */
    addType(typeName, def, structFqn = typeName) {
        return this.emitType(typeName, def, structFqn);
    }
    /**
     * Emits an array.
     */
    emitArray(typeName, def) {
        const et = this.typeForArray(typeName, def);
        return { type: `${et.type}[]`, toJson: x => `${x}?.map(y => ${et.toJson('y')})` };
    }
    /**
     * @returns true if this definition can be represented as a union or false if it cannot
     */
    tryEmitUnion(typeName, def, fqn) {
        const options = new Array();
        for (const option of def.oneOf || def.anyOf || []) {
            if (!supportedUnionOptionType(option.type)) {
                return undefined;
            }
            const type = option.type === 'integer' ? 'number' : option.type;
            options.push(type);
        }
        const emitted = { type: typeName, toJson: x => `${x}?.value` };
        this.addCode(typeName, code => {
            this.emitDescription(code, fqn, def.description);
            code.openBlock(`export class ${typeName}`);
            const possibleTypes = [];
            for (const type of options) {
                possibleTypes.push(type);
                const methodName = 'from' + type[0].toUpperCase() + type.substr(1);
                code.openBlock(`public static ${methodName}(value: ${type}): ${typeName}`);
                code.line(`return new ${typeName}(value);`);
                code.closeBlock();
            }
            code.openBlock(`private constructor(public readonly value: ${possibleTypes.join(' | ')})`);
            code.closeBlock();
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitStruct(typeName, structDef, structFqn) {
        const toJson = new tojson_1.ToJsonFunction(typeName);
        const emitted = {
            type: typeName,
            toJson: x => `${toJson.functionName}(${x})`,
        };
        this.emitCustomType(typeName, code => {
            this.emitDescription(code, structFqn, structDef.description);
            code.openBlock(`export interface ${typeName}`);
            for (const [propName, propSpec] of Object.entries(structDef.properties || {})) {
                this.emitProperty(code, propName, propSpec, structFqn, structDef, toJson);
            }
            code.closeBlock();
            if (this.toJson) {
                toJson.emit(code);
            }
            return emitted;
        });
        return emitted;
    }
    propertyFqn(structFqn, propName) {
        return `${structFqn}.${propName}`;
    }
    emitProperty(code, name, propDef, structFqn, structDef, toJson) {
        const originalName = name;
        // if the name starts with '$' (like $ref or $schema), we remove the "$"
        // and it's the same deal - will produce invalid output
        if (name.startsWith('$')) {
            name = name.substring(1);
        }
        // convert the name to camel case so it's compatible with JSII
        name = (0, camelcase_1.default)(name);
        const propertyFqn = this.propertyFqn(structFqn, name);
        if (this.emittedProperties.has(propertyFqn)) {
            // can happen if two properties have different casing that results
            // in the same camelCase string.
            return;
        }
        this.emitDescription(code, `${structFqn}#${originalName}`, propDef.description);
        const propertyType = this.typeForProperty(`${structFqn}.${name}`, propDef);
        const required = this.isPropertyRequired(originalName, structDef);
        const optional = required ? '' : '?';
        code.line(`readonly ${name}${optional}: ${propertyType.type};`);
        code.line();
        toJson.addField(originalName, name, propertyType.toJson);
        this.emittedProperties.add(propertyFqn);
    }
    emitEnum(typeName, def, structFqn) {
        const emitted = {
            type: typeName,
            toJson: x => x,
        };
        this.emitCustomType(typeName, code => {
            if (!def.enum || def.enum.length === 0) {
                throw new Error(`definition is not an enum: ${JSON.stringify(def)}`);
            }
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            this.emitDescription(code, structFqn, def.description);
            code.openBlock(`export enum ${typeName}`);
            const processedValues = new Set();
            for (const value of def.enum) {
                if (!['string', 'number'].includes(typeof (value))) {
                    throw new Error('only enums with string or number values are supported');
                }
                let memberName = (0, snake_case_1.snakeCase)(rewriteNamedSymbols(`${value}`).replace(/[^a-z0-9]/gi, '_')).split('_').filter(x => x).join('_').toUpperCase();
                // If enums of same value exists, then we choose one of them and skip adding others
                // since that would cause conflict
                const lowerCaseValue = value === null || value === void 0 ? void 0 : value.toString().toLowerCase();
                if (lowerCaseValue && !processedValues.has(lowerCaseValue)) {
                    processedValues.add(lowerCaseValue);
                }
                else {
                    continue;
                }
                // if member name starts with a non-alpha character, add a prefix so it becomes a symbol
                if (!/^[A-Z].*/i.test(memberName)) {
                    memberName = 'VALUE_' + memberName;
                }
                code.line(`/** ${value} */`);
                code.line(`${memberName} = ${JSON.stringify(value)},`);
            }
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitDescription(code, fqn, description, annotations = {}) {
        code.line('/**');
        if (description) {
            description = description.replace(/\*\//g, '_/');
            for (const dline of description.split('\n').map(x => x.trim())) {
                code.line(` * ${dline}`);
            }
            const extractDefault = /Defaults?\W+(to|is)\W+(.+)/g.exec(description);
            const def = extractDefault && extractDefault[2];
            if (def) {
                annotations.default = def;
            }
            code.line(' *');
        }
        annotations.schema = fqn;
        for (const [type, value] of Object.entries(annotations)) {
            code.line(` * @${type} ${value}`);
        }
        code.line(' */');
    }
    typeForProperty(propertyFqn, def) {
        const subtype = TypeGenerator.normalizeTypeName(DEFAULT_RENDER_TYPE_NAME(propertyFqn));
        return this.emitTypeInternal(subtype, def, subtype);
    }
    typeForRef(def) {
        const prefix = '#/definitions/';
        if (!def.$ref || !def.$ref.startsWith(prefix)) {
            throw new Error(`invalid $ref ${JSON.stringify(def)}`);
        }
        if (this.isExcluded(def.$ref)) {
            return { type: 'any', toJson: x => x };
        }
        const typeName = TypeGenerator.normalizeTypeName(this.renderTypeName(def.$ref.substring(prefix.length)));
        // if we already emitted a type with this type name, just return it
        const emitted = this.emittedTypes[typeName];
        if (emitted) {
            return emitted;
        }
        const schema = this.resolveReference(def);
        return this.emitTypeInternal(typeName, schema, def.$ref);
    }
    typeForArray(propertyFqn, def) {
        if (!def.items || typeof (def.items) !== 'object') {
            // Falling back to an array of any type
            def.items = {};
        }
        return this.typeForProperty(propertyFqn, def.items);
    }
    resolveReference(def) {
        const ref = def.$ref;
        if (!ref || !ref.startsWith(DEFINITIONS_PREFIX)) {
            throw new Error('expecting a local reference');
        }
        const lookup = ref.substr(DEFINITIONS_PREFIX.length);
        const found = this.definitions[lookup];
        if (!found) {
            throw new Error(`unable to find a definition for the $ref "${lookup}"`);
        }
        return found;
    }
    isPropertyRequired(property, structDef) {
        return Array.isArray(structDef.required) && structDef.required.includes(property);
    }
    isExcluded(fqn) {
        for (const pattern of this.exclude) {
            const re = new RegExp(pattern);
            if (re.test(fqn)) {
                return true;
            }
        }
        return false;
    }
}
exports.TypeGenerator = TypeGenerator;
function supportedUnionOptionType(type) {
    return type && (typeof (type) === 'string' && PRIMITIVE_TYPES.includes(type));
}
function pascalCase(s) {
    return (0, camelcase_1.default)(s, { pascalCase: true });
}
function rewriteNamedSymbols(input) {
    const ret = new Array();
    let cursor = 0;
    while (cursor < input.length) {
        const [prefixName, prefixLen] = longestPrefixMatch(input, cursor, allowlist_1.NAMED_SYMBOLS);
        if (prefixName) {
            const prefix = `_${prefixName}_`.split('');
            ret.push(...prefix);
            cursor += prefixLen;
        }
        else {
            ret.push(input.charAt(cursor));
            cursor += 1;
        }
    }
    // Remove underscores if its only prefix to be returned
    if (ret[0] === '_') {
        ret.unshift('VALUE');
    }
    if (ret[ret.length - 1] === '_') {
        ret.pop();
    }
    return ret.join('');
}
function longestPrefixMatch(input, index, lookupTable) {
    let ret;
    let longest = 0;
    for (const [name, value] of Object.entries(lookupTable)) {
        if (hasSubStringAt(input, index, value) && value.length > longest && !isExemptPattern(input, index)) {
            ret = name;
            longest = value.length;
        }
    }
    return [ret, longest];
}
function hasSubStringAt(input, index, substring) {
    if (index == input.indexOf(substring, index)) {
        return true;
    }
    return false;
}
function isExemptPattern(input, index) {
    const exemptPatterns = [
        // 9.9, 9.
        /(?<=\d)\.\d/,
    ];
    return exemptPatterns.some((p) => testRegexAt(p, input, index));
}
function testRegexAt(regex, input, index) {
    const re = new RegExp(regex, 'y');
    re.lastIndex = index;
    return re.test(input);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1nZW5lcmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZS1nZW5lcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMERBQWtDO0FBRWxDLDJDQUF1QztBQUN2QywyQ0FBNEM7QUFDNUMsaUNBQThCO0FBQzlCLHFDQUEwQztBQUcxQyxNQUFNLGVBQWUsR0FBRyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ25FLE1BQU0sa0JBQWtCLEdBQUcsZ0JBQWdCLENBQUM7QUFDNUMsTUFBTSx3QkFBd0IsR0FBRyxDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUF3RDlGOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBQ3hCOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxRQUFnQjtRQUU5QywwQkFBMEI7UUFDMUIsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdEcsaUZBQWlGO1FBQ2pGLE1BQU0sRUFBRSxHQUFHLHVCQUF1QixDQUFDO1FBQ25DLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNwQixJQUFJLENBQUMsQ0FBQztRQUNOLEdBQUc7WUFDRCxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQixJQUFJLENBQUMsRUFBRTtnQkFDTCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxtQ0FBbUM7Z0JBQzVFLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHNEQUFzRDtnQkFDeEUsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQywrREFBK0Q7Z0JBQ25ILE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxrQ0FBa0M7Z0JBQ3ZGLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLFNBQVM7YUFDNUM7U0FDRixRQUFRLENBQUMsRUFBRTtRQUVaLE1BQU0sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLHFDQUFxQztRQUM3RixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBa0IsRUFBRSxNQUFtQixFQUFFLFVBQWdDLEVBQUU7UUFDakcsTUFBTSxHQUFHLEdBQUcsSUFBSSxhQUFhLENBQUMsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDL0UsR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDakMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBV0Q7Ozs7T0FJRztJQUNILFlBQVksVUFBZ0MsRUFBRzs7UUFkOUIsZ0JBQVcsR0FBb0MsRUFBRyxDQUFDO1FBQ25ELGlCQUFZLEdBQWdDLEVBQUUsQ0FBQztRQUMvQyxzQkFBaUIsR0FBZ0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQWExRCxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQUEsT0FBTyxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBQSxPQUFPLENBQUMsTUFBTSxtQ0FBSSxJQUFJLENBQUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFBLE9BQU8sQ0FBQyxhQUFhLG1DQUFJLEtBQUssQ0FBQztRQUNwRCxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQUEsT0FBTyxDQUFDLGNBQWMsbUNBQUksd0JBQXdCLENBQUM7UUFFekUsS0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBQSxPQUFPLENBQUMsV0FBVyxtQ0FBSSxFQUFFLENBQUMsRUFBRTtZQUN2RSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNuQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxhQUFhLENBQUMsUUFBZ0IsRUFBRSxHQUFnQjtRQUNyRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxRQUFRLENBQUMsSUFBWSxFQUFFLEVBQVU7UUFDdEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLFFBQVEsQ0FBQyxRQUFnQixFQUFFLEdBQWlCLEVBQUUsWUFBb0IsUUFBUTtRQUMvRSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSyx1QkFBdUIsQ0FBQyxHQUFnQjtRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsT0FBTztTQUNSO1FBRUQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUM7UUFDbEQsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztRQUVqRSxJQUFJLFFBQVEsRUFBRTtZQUNaLEdBQUcsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1NBQ3RCO1FBRUQsSUFBSSxZQUFZLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUMzQixHQUFHLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQztTQUNuQjthQUFNO1lBQ0wscUVBQXFFO1lBQ3JFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQztTQUMvRTtJQUVILENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ssZ0JBQWdCLENBQUMsUUFBZ0IsRUFBRSxHQUFpQixFQUFFLFlBQW9CLFFBQVE7UUFDeEYsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1IsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsUUFBUSxFQUFFLENBQUMsQ0FBQzthQUNyRTtTQUNGO1FBRUQsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ2xDLDZFQUE2RTtZQUM3RSxrRkFBa0Y7WUFDbEYsMkJBQTJCO1lBQzNCLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7U0FDN0M7UUFFRCw4RUFBOEU7UUFDOUUsMkNBQTJDO1FBQzNDLElBQUksYUFBYSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUMxRCxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsUUFBUSw2Q0FBNkMsQ0FBQyxDQUFDO1NBQzNFO1FBRUQsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDNUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDNUQ7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLFNBQVMsaUVBQWlFLENBQUMsQ0FBQztTQUNyRztRQUVELGVBQWU7UUFDZixJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDN0I7UUFFRCw0RUFBNEU7UUFDNUUsSUFBSSxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7WUFFMUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzVELElBQUksT0FBTyxFQUFFO2dCQUNYLE9BQU8sT0FBTyxDQUFDO2FBQ2hCO1lBRUQsNkRBQTZEO1NBQzlEO1FBRUQsUUFBUTtRQUNSLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxXQUFXLEVBQUU7WUFDOUIsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7YUFDL0M7WUFFRCxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUM3RDtRQUVELFFBQVE7UUFDUixJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDL0gsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxFQUFFO2dCQUMzRixNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7YUFDMUU7WUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNoRDtRQUVELFNBQVM7UUFDVCxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUU7WUFDbEIsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLG1FQUFtRSxDQUFDLENBQUM7YUFDdEY7WUFFRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNsRDtRQUVELE1BQU07UUFDTixJQUFJLEdBQUcsQ0FBQyxvQkFBb0IsSUFBSSxPQUFNLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLEtBQUssUUFBUSxFQUFFO1lBQzdFLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO2FBQ2hHO1lBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDcEUsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxrRUFBa0UsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUUsV0FBVyxDQUFDO1lBQ3ZMLE9BQU8sRUFBRSxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQyxJQUFJLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUMxRDtRQUVELFFBQVEsR0FBRyxDQUFDLElBQUksRUFBRTtZQUNoQixLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFNUMsS0FBSyxRQUFRLENBQUM7WUFDZCxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFNUMsS0FBSyxTQUFTO2dCQUNaLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFL0MsS0FBSyxPQUFPLENBQUMsQ0FBQztnQkFDWixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQ3RDO1NBQ0Y7UUFFRCxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLGNBQWMsQ0FBQyxRQUFnQixFQUFFLE9BQWtDO1FBQ3hFLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDakMsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTtZQUNsQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDN0IsSUFBSSxPQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUMvQixPQUFPLE1BQU0sQ0FBQzthQUNmO2lCQUFNO2dCQUNMLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO2FBQzNDO1FBQ0gsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTyxDQUFDLFFBQWdCLEVBQUUsT0FBa0M7UUFDakUsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU07UUFDWCxNQUFNLElBQUksR0FBRyxJQUFJLFdBQUksRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxZQUFZLENBQUMsSUFBVTtRQUM1QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sRUFBRTtZQUMzQyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUM7U0FDdkM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRLENBQUMsSUFBVTtRQUN4QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTyxDQUFDLFFBQWdCLEVBQUUsR0FBaUIsRUFBRSxZQUFvQixRQUFRO1FBQzlFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNLLFNBQVMsQ0FBQyxRQUFnQixFQUFFLEdBQWdCO1FBQ2xELE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDcEYsQ0FBQztJQUVEOztPQUVHO0lBQ0ssWUFBWSxDQUFDLFFBQWdCLEVBQUUsR0FBZ0IsRUFBRSxHQUFXO1FBQ2xFLE1BQU0sT0FBTyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7UUFDcEMsS0FBSyxNQUFNLE1BQU0sSUFBSSxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRSxFQUFFO1lBQ2pELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzFDLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1lBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNoRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BCO1FBRUQsTUFBTSxPQUFPLEdBQWdCLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFFNUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUVqRCxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBQzNDLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUV6QixLQUFLLE1BQU0sSUFBSSxJQUFJLE9BQU8sRUFBRTtnQkFDMUIsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDekIsTUFBTSxVQUFVLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixVQUFVLFdBQVcsSUFBSSxNQUFNLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBQzNFLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxRQUFRLFVBQVUsQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDbkI7WUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLDhDQUE4QyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzRixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFbEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBRWxCLE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVPLFVBQVUsQ0FBQyxRQUFnQixFQUFFLFNBQXNCLEVBQUUsU0FBaUI7UUFDNUUsTUFBTSxNQUFNLEdBQUcsSUFBSSx1QkFBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzVDLE1BQU0sT0FBTyxHQUFnQjtZQUMzQixJQUFJLEVBQUUsUUFBUTtZQUNkLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLFlBQVksSUFBSSxDQUFDLEdBQUc7U0FDNUMsQ0FBQztRQUVGLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFO1lBRW5DLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDN0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUUvQyxLQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUM3RSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDM0U7WUFFRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFbEIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNmLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbkI7WUFFRCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxXQUFXLENBQUMsU0FBaUIsRUFBRSxRQUFnQjtRQUNyRCxPQUFPLEdBQUcsU0FBUyxJQUFJLFFBQVEsRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBVSxFQUFFLElBQVksRUFBRSxPQUFvQixFQUFFLFNBQWlCLEVBQUUsU0FBc0IsRUFBRSxNQUFzQjtRQUNwSSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUM7UUFFMUIsd0VBQXdFO1FBQ3hFLHVEQUF1RDtRQUN2RCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDeEIsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUI7UUFFRCw4REFBOEQ7UUFDOUQsSUFBSSxHQUFHLElBQUEsbUJBQVMsRUFBQyxJQUFJLENBQUMsQ0FBQztRQUV2QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUV0RCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDM0Msa0VBQWtFO1lBQ2xFLGdDQUFnQztZQUNoQyxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxHQUFHLFNBQVMsSUFBSSxZQUFZLEVBQUUsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDaEYsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLFNBQVMsSUFBSSxJQUFJLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMzRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFFckMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksR0FBRyxRQUFRLEtBQUssWUFBWSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRVosTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFTyxRQUFRLENBQUMsUUFBZ0IsRUFBRSxHQUFnQixFQUFFLFNBQWlCO1FBQ3BFLE1BQU0sT0FBTyxHQUFnQjtZQUMzQixJQUFJLEVBQUUsUUFBUTtZQUNkLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDZixDQUFDO1FBRUYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFFbkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN0RTtZQUVELElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsRUFBRTtnQkFDM0YsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO2FBQzFFO1lBRUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUV2RCxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUUxQyxNQUFNLGVBQWUsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1lBRTFDLEtBQUssTUFBTSxLQUFLLElBQUksR0FBRyxDQUFDLElBQUksRUFBRTtnQkFDNUIsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO2lCQUMxRTtnQkFFRCxJQUFJLFVBQVUsR0FBRyxJQUFBLHNCQUFTLEVBQUMsbUJBQW1CLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUUxSSxtRkFBbUY7Z0JBQ25GLGtDQUFrQztnQkFDbEMsTUFBTSxjQUFjLEdBQUcsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFFBQVEsR0FBRyxXQUFXLEVBQUUsQ0FBQztnQkFDdkQsSUFBSSxjQUFjLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFO29CQUMxRCxlQUFlLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2lCQUNyQztxQkFBTTtvQkFDTCxTQUFTO2lCQUNWO2dCQUVELHdGQUF3RjtnQkFDeEYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQ2pDLFVBQVUsR0FBRyxRQUFRLEdBQUcsVUFBVSxDQUFDO2lCQUNwQztnQkFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLENBQUMsQ0FBQztnQkFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN4RDtZQUVELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUVsQixPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxlQUFlLENBQUMsSUFBVSxFQUFFLEdBQVcsRUFBRSxXQUFvQixFQUFFLGNBQTBDLEVBQUc7UUFDbEgsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVqQixJQUFJLFdBQVcsRUFBRTtZQUNmLFdBQVcsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUVqRCxLQUFLLE1BQU0sS0FBSyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUU7Z0JBQzlELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQzFCO1lBRUQsTUFBTSxjQUFjLEdBQUcsNkJBQTZCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3ZFLE1BQU0sR0FBRyxHQUFHLGNBQWMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEQsSUFBSSxHQUFHLEVBQUU7Z0JBQ1AsV0FBVyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7YUFDM0I7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO1FBRUQsV0FBVyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFFekIsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ25DO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRU8sZUFBZSxDQUFDLFdBQW1CLEVBQUUsR0FBZ0I7UUFDM0QsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLGlCQUFpQixDQUFDLHdCQUF3QixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDdkYsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sVUFBVSxDQUFDLEdBQWdCO1FBQ2pDLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDO1FBQ2hDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDN0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDeEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzdCLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQ3hDO1FBRUQsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV6RyxtRUFBbUU7UUFDbkUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QyxJQUFJLE9BQU8sRUFBRTtZQUNYLE9BQU8sT0FBTyxDQUFDO1NBQ2hCO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFTyxZQUFZLENBQUMsV0FBbUIsRUFBRSxHQUFnQjtRQUN4RCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxPQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUNoRCx1Q0FBdUM7WUFDdkMsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7U0FDaEI7UUFFRCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsR0FBZ0I7UUFDdkMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQy9DLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDckQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUN6RTtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGtCQUFrQixDQUFDLFFBQWdCLEVBQUUsU0FBc0I7UUFDakUsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBRU8sVUFBVSxDQUFDLEdBQVc7UUFDNUIsS0FBSyxNQUFNLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xDLE1BQU0sRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQy9CLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDaEIsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBRUY7QUF0bEJELHNDQXNsQkM7QUFFRCxTQUFTLHdCQUF3QixDQUFDLElBQVM7SUFDekMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLGVBQWUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMvRSxDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLElBQUEsbUJBQVMsRUFBQyxDQUFDLEVBQUUsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBY0QsU0FBUyxtQkFBbUIsQ0FBQyxLQUFhO0lBQ3hDLE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFFaEMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsT0FBTyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUM1QixNQUFNLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUseUJBQWEsQ0FBQyxDQUFDO1FBQ2pGLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxNQUFNLEdBQUcsSUFBSSxVQUFVLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0MsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1lBQ3BCLE1BQU0sSUFBSSxTQUFTLENBQUM7U0FDckI7YUFBTTtZQUNMLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sSUFBSSxDQUFDLENBQUM7U0FDYjtLQUNGO0lBRUQsdURBQXVEO0lBQ3ZELElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtRQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7S0FBRTtJQUM3QyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtRQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUFFO0lBRS9DLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxLQUFhLEVBQUUsS0FBYSxFQUFFLFdBQW1DO0lBQzNGLElBQUksR0FBdUIsQ0FBQztJQUM1QixJQUFJLE9BQU8sR0FBVyxDQUFDLENBQUM7SUFFeEIsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDdkQsSUFBSSxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDbkcsR0FBRyxHQUFHLElBQUksQ0FBQztZQUNYLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1NBQ3hCO0tBQ0Y7SUFDRCxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFhLEVBQUUsS0FBYSxFQUFFLFNBQWlCO0lBQ3JFLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFO1FBQzVDLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxLQUFhLEVBQUUsS0FBYTtJQUNuRCxNQUFNLGNBQWMsR0FBRztRQUNyQixVQUFVO1FBQ1YsYUFBYTtLQUNkLENBQUM7SUFFRixPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLEtBQWEsRUFBRSxLQUFhLEVBQUUsS0FBYTtJQUM5RCxNQUFNLEVBQUUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbEMsRUFBRSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFFckIsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2FtZWxDYXNlIGZyb20gJ2NhbWVsY2FzZSc7XG5pbXBvcnQgeyBKU09OU2NoZW1hNCB9IGZyb20gJ2pzb24tc2NoZW1hJztcbmltcG9ydCB7IHNuYWtlQ2FzZSB9IGZyb20gJ3NuYWtlLWNhc2UnO1xuaW1wb3J0IHsgTkFNRURfU1lNQk9MUyB9IGZyb20gJy4vYWxsb3dsaXN0JztcbmltcG9ydCB7IENvZGUgfSBmcm9tICcuL2NvZGUnO1xuaW1wb3J0IHsgVG9Kc29uRnVuY3Rpb24gfSBmcm9tICcuL3RvanNvbic7XG5cblxuY29uc3QgUFJJTUlUSVZFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2ludGVnZXInLCAnYm9vbGVhbiddO1xuY29uc3QgREVGSU5JVElPTlNfUFJFRklYID0gJyMvZGVmaW5pdGlvbnMvJztcbmNvbnN0IERFRkFVTFRfUkVOREVSX1RZUEVfTkFNRSA9IChzOiBzdHJpbmcpID0+IHMuc3BsaXQoJy4nKS5tYXAoeCA9PiBwYXNjYWxDYXNlKHgpKS5qb2luKCcnKTtcblxuZXhwb3J0IGludGVyZmFjZSBUeXBlR2VuZXJhdG9yT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQYXR0ZXJucyBvZiB0eXBlIEZRTnMgdG8gZXhjbHVkZS5cbiAgICogQGRlZmF1bHQgLSBpbmNsdWRlIGFsbCB0eXBlc1xuICAgKi9cbiAgcmVhZG9ubHkgZXhjbHVkZT86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBTY2hlbWEgZGVmaW5pdGlvbnMgZm9yIHJlc29sdmluZyAkcmVmc1xuICAgKiBAZGVmYXVsdCAtICRyZWZzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAqL1xuICByZWFkb25seSBkZWZpbml0aW9ucz86IHsgW2RlZjogc3RyaW5nXTogSlNPTlNjaGVtYTQgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYHRvSnNvbl9YeXpgIGZ1bmN0aW9ucyBmb3IgYWxsIHR5cGVzIHdoaWNoIGNvbnZlcnQgZGF0YSBvYmplY3RzXG4gICAqIGJhY2sgdG8gc2NoZW1hLWNvbXBhdGlibGUgSlNPTi5cbiAgICpcbiAgICogVGhlc2UgZnVuY3Rpb25zIGFyZSByZXF1aXJlZCBzaW5jZSBwcm9wZXJ0eSBuYW1lcyBpbiBnZW5lcmF0ZWQgc3RydWN0cyBhcmVcbiAgICogY2FtZWwgY2FzZWQgaW4gb3JkZXIgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEpTSUksIGFuZCB0aGlzIGlzIGEgbG9zc3lcbiAgICogY29udmVyc2lvbiwgc28gdGhlIHRvSnNvbiBmdW5jdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGNvbnZlcnQgdGhlIGRhdGEgYmFja1xuICAgKiB0byBhIHNjaGVtYS1jb21wYXRpYmxlIGRhdGEgb2JqZWN0cy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdG9Kc29uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hlbiBzZXQgdG8gdHJ1ZSwgZW51bXMgYXJlIHNhbml0aXplZCBmcm9tIHRoZSAnbnVsbCcgbGl0ZXJhbCB2YWx1ZSxcbiAgICogYWxsb3dpbmcgdHlwaW5nIHRoZSBwcm9wZXJ0eSBhcyBhbiBlbnVtLCBpbnN0ZWFkIG9mIHRoZSB1bmRlcmx5aW5nIHR5cGUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzd2l0Y2hpbmcgdGhpcyBmcm9tICdmYWxzZScgdG8gJ3RydWUnIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGluXG4gICAqIHRoZSBnZW5lcmF0ZWQgY29kZSBhcyBpdCBtaWdodCBjaGFuZ2UgYSBwcm9wZXJ0eSB0eXBlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2FuaXRpemVFbnVtcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgZGVmaW5pdGlvbiBuYW1lLCByZW5kZXIgdGhlIHR5cGUgbmFtZSB0byBiZSBlbWl0dGVkIGJ5IHRoYXQgZGVmaW5pdGlvbi5cbiAgICpcbiAgICogV2hlbiBgZW1pdFR5cGVgIGlzIGludm9rZWQsIHRoZSB0eXBlIG5hbWUgdG8gYmUgZW1pdHRlZCBpcyBwcm92aWRlZCBieSB0aGUgY2FsbGVyLlxuICAgKiBIb3dldmVyLCBmb3IgY29tcGxleCB0eXBlcyBjb250YWluaW5nIHJlZmVyZW5jZXMgdG8gb3RoZXIgdHlwZXMsIHdlIGluZmVyIHRoZSB0eXBlIG5hbWUgb2YgdGhlIHJlZmVyZW5jZVxuICAgKiBieSBsb29raW5nIGF0IHRoZSBkZWZpbml0aW9uIG5hbWUgb2YgdGhlIGAkcmVmYCBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYSB3YXkgdG8gY29udHJvbCBob3cgdGhvc2UgZGVmaW5pdGlvbiBuYW1lcyB0cmFuc2xhdGUgaW50byB0eXBlIG5hbWUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiBhIGNvbXBsZXggdHlwZSByZWZlcmVuY2VzIGEgbmFtZXNwYWNlZCBkZWZpbml0aW9uIGxpa2UgYGFwaS5ncm91cC5Gb29gLCB3ZSdkIGxpa2UgdG8gY29udHJvbFxuICAgKiBob3cgdG8gdHJhbnNsYXRlIGBhcGkuZ3JvdXAuRm9vYCwgd2hpY2ggaXMgYW4gaWxsZWdhbCB0eXBlbmFtZSwgaW50byBhIGxlZ2FsIG9uZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBPbmx5IGRvdCBuYW1lc3BhY2luZyBpcyBoYW5kbGVkIGJ5IGRlZmF1bHQuIEVsZW1lbnRzIGJldHdlZW4gZG90cyBhcmUgcGFzY2FsIGNhc2VkIGFuZCBjb25jYXRlbmF0ZWQuXG4gICAqL1xuICByZWFkb25seSByZW5kZXJUeXBlTmFtZT86IChkZWY6IHN0cmluZykgPT4gc3RyaW5nO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0eXBlc2NyaXB0IHR5cGVzIGZyb20gSlNPTiBzY2hlbWFzLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZUdlbmVyYXRvciB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbC1jYXBzIGFjcm9ueW1zIChlLmcuIFwiVlBDXCIsIFwiRm9vQkFSWm9vRklHb29cIikgdG8gcGFzY2FsIGNhc2VcbiAgICogKGUuZy4gXCJWcGNcIiwgXCJGb29CYXJab29GaUdvb1wiKS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplVHlwZU5hbWUodHlwZU5hbWU6IHN0cmluZykge1xuXG4gICAgLy8gSGFuZGxlIGtlYmFiLWNhc2UgZmlyc3RcbiAgICBjb25zdCBzdGFnZTEgPSB0eXBlTmFtZS5zcGxpdCgnLScpLm1hcCh3b3JkID0+IHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKS5qb2luKCcnKTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGZ1bGwgc3RyaW5nIGFuZCB0aGVuIHVzZSB0aGUgcmVnZXggdG8gbWF0Y2ggYWxsLWNhcHMgc2VxdWVuY2VzLlxuICAgIGNvbnN0IHJlID0gLyhbQS1aXSspKD86W15hLXpdfCQpL2c7XG4gICAgbGV0IHJlc3VsdCA9IHN0YWdlMTtcbiAgICBsZXQgbTtcbiAgICBkbyB7XG4gICAgICBtID0gcmUuZXhlYyhzdGFnZTEpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0gcmVzdWx0LnNsaWNlKDAsIG0uaW5kZXgpOyAvLyBhbGwgdGhlIHRleHQgYmVmb3JlIHRoZSBzZXF1ZW5jZVxuICAgICAgICBjb25zdCBjYXAgPSBtWzFdOyAvLyBncm91cCAjMSBtYXRjaGVzIHRoZSBhbGwtY2FwcyBzZXF1ZW5jZSB3ZSBhcmUgYWZ0ZXJcbiAgICAgICAgY29uc3QgcGFzY2FsID0gY2FwWzBdICsgY2FwLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7IC8vIGNvbnZlcnQgdG8gcGFzY2FsIGNhc2UgYnkgbG93ZXJjYXNpbmcgYWxsIGJ1dCB0aGUgZmlyc3QgY2hhclxuICAgICAgICBjb25zdCBhZnRlciA9IHJlc3VsdC5zbGljZShtLmluZGV4ICsgcGFzY2FsLmxlbmd0aCk7IC8vIGFsbCB0aGUgdGV4dCBhZnRlciB0aGUgc2VxdWVuY2VcbiAgICAgICAgcmVzdWx0ID0gYmVmb3JlICsgcGFzY2FsICsgYWZ0ZXI7IC8vIGNvbmNhdFxuICAgICAgfVxuICAgIH0gd2hpbGUgKG0pO1xuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL14uLywgcmVzdWx0WzBdLnRvVXBwZXJDYXNlKCkpOyAvLyBlbnN1cmUgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgSlNJSSBzdHJ1Y3QgKGFuZCBhY2NvbXBhbnlpbmcgdHlwZXMpIGZyb20gYSBKU09OIHNjaGVtYS5cbiAgICpcbiAgICogSWYgeW91IHdpc2ggdG8gcmVuZGVyIG11bHRpcGxlIHRvcC1sZXZlbCBzdHJ1Y3RzIG9yIGluY2x1ZGUgY3VzdG9tIHR5cGVzLFxuICAgKiBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYFR5cGVHZW5lcmF0b3JgIG1hbnVhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0gc3RydWN0TmFtZSBUaGUgbmFtZSBvZiB0aGUgSlNJSSBzdHJ1Y3QgKFR5cGVTY3JpcHQgaW50ZXJmYWNlKS5cbiAgICogQHBhcmFtIHNjaGVtYSBUaGUgSlNPTiBzY2hlbWEgKHRvcCBsZXZlbCBzY2hlbWEgbXVzdCBpbmNsdWRlIFwicHJvcGVydGllc1wiKVxuICAgKiBAcmV0dXJucyBHZW5lcmF0ZWQgVHlwZVNjcmlwdCBzb3VyY2UgY29kZSB0aGF0IGluY2x1ZGVzIHRoZSB0b3AtbGV2ZWxcbiAgICogc3RydWN0IGFuZCBhbGwgb3RoZXIgdHlwZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZvclN0cnVjdChzdHJ1Y3ROYW1lOiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYTQsIG9wdGlvbnM6IFR5cGVHZW5lcmF0b3JPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBnZW4gPSBuZXcgVHlwZUdlbmVyYXRvcih7IGRlZmluaXRpb25zOiBzY2hlbWEuZGVmaW5pdGlvbnMsIC4uLm9wdGlvbnMgfSk7XG4gICAgZ2VuLmVtaXRUeXBlKHN0cnVjdE5hbWUsIHNjaGVtYSk7XG4gICAgcmV0dXJuIGdlbjtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgdHlwZXNUb0VtaXQ6IHsgW25hbWU6IHN0cmluZ106IFR5cGVFbWl0dGVyIH0gPSB7IH07XG4gIHByaXZhdGUgcmVhZG9ubHkgZW1pdHRlZFR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBFbWl0dGVkVHlwZT4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBlbWl0dGVkUHJvcGVydGllczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhjbHVkZTogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmaW5pdGlvbnM6IHsgW2RlZjogc3RyaW5nXTogSlNPTlNjaGVtYTQgfTtcbiAgcHJpdmF0ZSByZWFkb25seSB0b0pzb246IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgc2FuaXRpemVFbnVtczogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJUeXBlTmFtZTogKGRlZjogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBUeXBlR2VuZXJhdG9yT3B0aW9ucyA9IHsgfSkge1xuICAgIHRoaXMuZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSA/PyBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgdGhpcy50b0pzb24gPSBvcHRpb25zLnRvSnNvbiA/PyB0cnVlO1xuICAgIHRoaXMuc2FuaXRpemVFbnVtcyA9IG9wdGlvbnMuc2FuaXRpemVFbnVtcyA/PyBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclR5cGVOYW1lID0gb3B0aW9ucy5yZW5kZXJUeXBlTmFtZSA/PyBERUZBVUxUX1JFTkRFUl9UWVBFX05BTUU7XG5cbiAgICBmb3IgKGNvbnN0IFt0eXBlTmFtZSwgZGVmXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLmRlZmluaXRpb25zID8/IHt9KSkge1xuICAgICAgdGhpcy5hZGREZWZpbml0aW9uKHR5cGVOYW1lLCBkZWYpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgSlNPTiBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgYSB0eXBlIG5hbWUuIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVtaXQgdGhlIHR5cGVcbiAgICogYnV0IHJhdGhlciBqdXN0IHJlZ2lzdGVycyB0aGUgZGVmaW5pdGlvbiB0aGF0IHdpbGwgZ2V0IHJlc29sdmVkIGlmIHRoaXMgdHlwZSBpcyBgJHJlZmBlZC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGVOYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGVmIFRoZSBKU09OIHNjaGVtYSBkZWZpbml0aW9uIGZvciB0aGlzIHR5cGVcbiAgICovXG4gIHB1YmxpYyBhZGREZWZpbml0aW9uKHR5cGVOYW1lOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpIHtcbiAgICB0aGlzLmRlZmluaXRpb25zW3R5cGVOYW1lXSA9IGRlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGRlZmluaXRpb24gb2YgYGZyb21UeXBlTmFtZWAgc3VjaCB0aGF0IGFueSByZWZlcmVuY2VzIHRvIGl0XG4gICAqIHdpbGwgYmUgcmVzb2x2ZWQgYXMgYHRvVHlwZU5hbWVgLiBCZWFyIGluIG1pbmQgdGhhdCB0aGUgdHlwZSBuYW1lIHNwZWNpZmllZFxuICAgKiBpbiBgdG9gIG11c3QgZWl0aGVyIGJlIGRlZmluZWQgYXMgYSBkZWZpbml0aW9uIChgYWRkRGVmaW5pdGlvbigpYCkgX29yX1xuICAgKiBlbWl0dGVkIGFzIGEgY3VzdG9tIHR5cGUgKGBlbWl0Q3VzdG9tVHlwZSgpYCkuXG4gICAqL1xuICBwdWJsaWMgYWRkQWxpYXMoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKSB7XG4gICAgdGhpcy5hZGREZWZpbml0aW9uKGZyb20sIHsgJHJlZjogYCMvZGVmaW5pdGlvbnMvJHt0b31gIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSB0eXBlIGJhc2VkIG9uIGEgSlNPTiBzY2hlbWEuIElmIGBkZWZgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiBkZWZpbml0aW9uIG9mIHRoZSB0eXBlIHdpbGwgYmUgbG9va2VkIHVwIGluIHRoZSBgZGVmaW5pdGlvbnNgIHByb3ZpZGVkXG4gICAqIGR1cmluZyBpbml0aWFsaXphdGlvbiBvciB2aWEgYGFkZERlZmluaXRpb24oKWAuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgbmFtZSBvZiB0aCB0eXBlXG4gICAqIEBwYXJhbSBkZWYgSlNPTiBzY2hlbWEuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBzY2hlbWEgaXMgbG9va2VkIHVwIGZyb21cbiAgICogYGRlZmluaXRpb25zYCBiYXNlZCBvbiB0aGUgdHlwZSBuYW1lXG4gICAqIEBwYXJhbSBzdHJ1Y3RGcW4gRlFOIGZvciB0aGUgdHlwZSAoZGVmYXVsdHMgdG8gYHR5cGVOYW1lYClcbiAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHR5cGUgKG5vdCBhbHdheXMgdGhlIHNhbWUgYXMgYHR5cGVOYW1lYClcbiAgICovXG4gIHB1YmxpYyBlbWl0VHlwZSh0eXBlTmFtZTogc3RyaW5nLCBkZWY/OiBKU09OU2NoZW1hNCwgc3RydWN0RnFuOiBzdHJpbmcgPSB0eXBlTmFtZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGVJbnRlcm5hbCh0eXBlTmFtZSwgZGVmLCBzdHJ1Y3RGcW4pLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogTWFueSBzY2hlbWFzIGRlZmluZSBhIHR5cGUgYXMgYW4gYXJyYXkgb2YgdHlwZXMgdG8gaW5kaWNhdGUgdW5pb24gdHlwZXMuXG4gICAqIFRvIGF2b2lkIGhhdmluZyB0aGUgdHlwZSBnZW5lcmF0b3IgYmUgYXdhcmUgb2YgdGhhdCwgd2UgdHJhbnNmb3JtIHRob3NlIHR5cGVzXG4gICAqIGludG8gdGhlaXIgY29ycmVzcG9uZGluZyB0eXBlc2NyaXB0IGRlZmluaXRpb25zLlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBTdHJpY3RseSBzcGVha2luZywgdGhlc2UgZGVmaW5pdGlvbnMgYXJlIG1lYW50IHRvIGFsbG93IHRoZSBsaXRlcm5hbCAnbnVsbCcgdmFsdWVcbiAgICogdG8gYmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aGUgYWN0dWFsIHR5cGVzLiBIb3dldmVyLCBzaW5jZSB1bmlvbiB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgKiBpbiBqc2lpLCBhbGxvd2luZyB0aGlzIHdvdWxkIG1lYW4gZmFsbGluZyBiYWNrIHRvICdhbnknIGFuZCBsb29zaW5nIGFsbCB0eXBlIHNhZmV0eSBmb3Igc3VjaFxuICAgKiBwcm9wZXJ0aWVzLiBUcmFuc2Zvcm1pbmcgaXQgaW50byBhIHNpbmdsZSBjb25jcmV0ZSBvcHRpb25hbCB0eXBlIHByb3ZpZGVzIGJvdGggdHlwZSBzYWZldHkgYW5kXG4gICAqIHRoZSBvcHRpb24gdG8gb21pdCB0aGUgcHJvcGVydHkuIFdoYXQgaXQgZG9lc24ndCBhbGxvdyBpcyBleHBsaWNpdGx5IHBhc3NpbmcgJ251bGwnLCB3aGljaCBtaWdodFxuICAgKiBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMuIEZvciBub3cgd2UgcHJlZmVyIHR5cGUgc2FmZXR5IG92ZXIgdGhhdC5cbiAgICpcbiAgICogMS4gWydudWxsJywgJzx0eXBlPiddIC0+IG9wdGlvbmFsICc8dHlwZT4nXG4gICAqIDIuIFsnbnVsbCcsICc8dHlwZTE+JywgJzx0eXBlMj4nXSAtPiBvcHRpb25hbCAnYW55J1xuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBub3JtYWwganNpaSBjb252ZXJzaW9uLCBub3RoaW5nIG11Y2ggd2UgY2FuIGRvIGhlcmUuXG4gICAqXG4gICAqIDMuIFsnPHR5cGUxPicsICc8dHlwZTI+J10gLT4gJ2FueSdcbiAgICovXG4gIHByaXZhdGUgbWF5YmVUcmFuc2Zvcm1UeXBlQXJyYXkoZGVmOiBKU09OU2NoZW1hNCkge1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZi50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxUeXBlID0gZGVmLnR5cGUuc29tZSh0ID0+IHQgPT09ICdudWxsJyk7XG4gICAgY29uc3Qgbm9uTnVsbFR5cGVzID0gbmV3IFNldChkZWYudHlwZS5maWx0ZXIodCA9PiB0ICE9PSAnbnVsbCcpKTtcblxuICAgIGlmIChudWxsVHlwZSkge1xuICAgICAgZGVmLnJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vbk51bGxUeXBlcy5zaXplID09PSAwKSB7XG4gICAgICBkZWYudHlwZSA9ICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgaXRzIGEgdW5pb24gb2Ygbm9uIG51bGwgdHlwZXMgd2UgdXNlICdhbnknIHRvIGJlIGpzaWkgY29tcGxpYW50XG4gICAgICBkZWYudHlwZSA9IG5vbk51bGxUeXBlcy5zaXplID4gMSA/ICdhbnknIDogbm9uTnVsbFR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgdHlwZSBiYXNlZCBvbiBhIEpTT04gc2NoZW1hLiBJZiBgZGVmYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogZGVmaW5pdGlvbiBvZiB0aGUgdHlwZSB3aWxsIGJlIGxvb2tlZCB1cCBpbiB0aGUgYGRlZmluaXRpb25zYCBwcm92aWRlZFxuICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb3IgdmlhIGBhZGREZWZpbml0aW9uKClgLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgVGhlIG5hbWUgb2YgdGggdHlwZVxuICAgKiBAcGFyYW0gZGVmIEpTT04gc2NoZW1hLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc2NoZW1hIGlzIGxvb2tlZCB1cCBmcm9tXG4gICAqIGBkZWZpbml0aW9uc2AgYmFzZWQgb24gdGhlIHR5cGUgbmFtZVxuICAgKiBAcGFyYW0gc3RydWN0RnFuIEZRTiBmb3IgdGhlIHR5cGUgKGRlZmF1bHRzIHRvIGB0eXBlTmFtZWApXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB0eXBlIChub3QgYWx3YXlzIHRoZSBzYW1lIGFzIGB0eXBlTmFtZWApXG4gICAqL1xuICBwcml2YXRlIGVtaXRUeXBlSW50ZXJuYWwodHlwZU5hbWU6IHN0cmluZywgZGVmPzogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nID0gdHlwZU5hbWUpOiBFbWl0dGVkVHlwZSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGRlZiA9IHRoaXMuZGVmaW5pdGlvbnNbdHlwZU5hbWVdO1xuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgJHt0eXBlTmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1heWJlVHJhbnNmb3JtVHlwZUFycmF5KGRlZik7XG5cbiAgICBpZiAoZGVmLmVudW0gJiYgdGhpcy5zYW5pdGl6ZUVudW1zKSB7XG4gICAgICAvLyBzYW50aXppZSBlbnVtcyBmcm9tIGxpdGVybmFsICdudWxsJyBiZWNhdXNlIHRoZXkgcHJldmVudCBlbWl0dGluZyB0aGUgZW51bVxuICAgICAgLy8gYW5kIGluc3RlYWQgY2F1c2UgYSBmYWxsYmFjayB0byAnc3RyaW5nJy4gd2UgYXNzdW1lIHRoZSBvcHRpb25hbGl0eSBvZiB0aGUgZW51bVxuICAgICAgLy8gY292ZXJzIHRoZSAnbnVsbCcgdmFsdWUuXG4gICAgICBkZWYuZW51bSA9IGRlZi5lbnVtLmZpbHRlcihkID0+IGQgIT09IG51bGwpO1xuICAgIH1cblxuICAgIC8vIGNhbGxlcnMgZXhwZWN0IHRoYXQgZW1pdCBhIHR5cGUgbmFtZWQgYHR5cGVOYW1lYCBzbyB3ZSBjYW4ndCBjaGFuZ2UgaXQgaGVyZVxuICAgIC8vIGJ1dCBhdCBsZWFzdCB3ZSBjYW4gdmVyaWZ5IGl0J3MgY29ycmVjdC5cbiAgICBpZiAoVHlwZUdlbmVyYXRvci5ub3JtYWxpemVUeXBlTmFtZSh0eXBlTmFtZSkgIT09IHR5cGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZU5hbWV9IG11c3QgYmUgbm9ybWFsaXplZCBiZWZvcmUgY2FsbGluZyBlbWl0VHlwZWApO1xuICAgIH1cblxuICAgIGlmIChzdHJ1Y3RGcW4uc3RhcnRzV2l0aChERUZJTklUSU9OU19QUkVGSVgpKSB7XG4gICAgICBzdHJ1Y3RGcW4gPSBzdHJ1Y3RGcW4uc3Vic3RyaW5nKERFRklOSVRJT05TX1BSRUZJWC5sZW5ndGgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRXhjbHVkZWQoc3RydWN0RnFuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlICR7c3RydWN0RnFufSBjYW5ub3QgYmUgYWRkZWQgc2luY2UgaXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGV4Y2x1c2lvbiBwYXR0ZXJuc2ApO1xuICAgIH1cblxuICAgIC8vIGNvbXBsZXggdHlwZVxuICAgIGlmIChkZWYuJHJlZikge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZUZvclJlZihkZWYpO1xuICAgIH1cblxuICAgIC8vIHVuaW9ucyAodW5sZXNzIHRoaXMgaXMgYSBzdHJ1Y3QsIGFuZCB0aGVuIHdlIGp1c3QgaWdub3JlIHRoZSBjb25zdHJhaW50cylcbiAgICBpZiAoZGVmLm9uZU9mIHx8IGRlZi5hbnlPZikge1xuXG4gICAgICBjb25zdCBhc1VuaW9uID0gdGhpcy50cnlFbWl0VW5pb24odHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgICAgIGlmIChhc1VuaW9uKSB7XG4gICAgICAgIHJldHVybiBhc1VuaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBjYXJyeSBvbiwgd2UgY2FuJ3QgcmVwcmVzZW50IHRoaXMgc2NoZW1hIGFzIGEgdW5pb24gKHlldD8pXG4gICAgfVxuXG4gICAgLy8gZGF0ZXNcbiAgICBpZiAoZGVmLmZvcm1hdCA9PT0gJ2RhdGUtdGltZScpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiBkZWYudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRlLXRpbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB0eXBlOiAnRGF0ZScsIHRvSnNvbjogeCA9PiBgJHt4fT8udG9JU09TdHJpbmcoKWAgfTtcbiAgICB9XG5cbiAgICAvLyBlbnVtc1xuICAgIGlmIChkZWYuZW51bSAmJiBBcnJheS5pc0FycmF5KGRlZi5lbnVtKSAmJiBkZWYuZW51bS5sZW5ndGggPiAwICYmIGRlZi5lbnVtLmV2ZXJ5KHggPT4gWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mKHgpKSkpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiAhKGRlZi50eXBlID09PSAnc3RyaW5nJyB8fCBkZWYudHlwZSA9PT0gJ251bWJlcicgfHwgZGVmLnR5cGUgPT09ICdpbnRlZ2VyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGVudW1zIHdpdGggc3RyaW5nIG9yIG51bWJlciB2YWx1ZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0RW51bSh0eXBlTmFtZSwgZGVmLCBzdHJ1Y3RGcW4pO1xuICAgIH1cblxuICAgIC8vIHN0cnVjdFxuICAgIGlmIChkZWYucHJvcGVydGllcykge1xuICAgICAgaWYgKGRlZi50eXBlICYmIGRlZi50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvciBcInByb3BlcnRpZXNcIiwgaWYgXCJ0eXBlXCIgaXMgc3BlY2lmaWVkIGl0IGhhcyB0byBiZSBhbiBcIm9iamVjdFwiJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXRTdHJ1Y3QodHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgICB9XG5cbiAgICAvLyBtYXBcbiAgICBpZiAoZGVmLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmIHR5cGVvZihkZWYuYWRkaXRpb25hbFByb3BlcnRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGRlZi50eXBlICYmIGRlZi50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvciBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGlmIFwidHlwZVwiIGlzIHNwZWNpZmllZCBpdCBoYXMgdG8gYmUgYW4gXCJvYmplY3RcIicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBldCA9IHRoaXMudHlwZUZvclByb3BlcnR5KHR5cGVOYW1lLCBkZWYuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgY29uc3QgdG9Kc29uID0gKHg6IHN0cmluZykgPT4gYCgoJHt4fSkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMoJHt4fSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06ICR7ZXQudG9Kc29uKCdpWzFdJykgfSB9KSwge30pKWA7XG4gICAgICByZXR1cm4geyB0eXBlOiBgeyBba2V5OiBzdHJpbmddOiAke2V0LnR5cGV9IH1gLCB0b0pzb24gfTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRlZi50eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4geyB0eXBlOiAnc3RyaW5nJywgdG9Kc29uOiB4ID0+IHggfTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICByZXR1cm4geyB0eXBlOiAnbnVtYmVyJywgdG9Kc29uOiB4ID0+IHggfTtcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdib29sZWFuJywgdG9Kc29uOiAoeCkgPT4geCB9O1xuXG4gICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdEFycmF5KHR5cGVOYW1lLCBkZWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdhbnknLCB0b0pzb246IHggPT4geCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGN1c3RvbSB0eXBlIGFuZCBlbWl0cyBpdC4gVGhpcyB3aWxsIG92ZXJyaWRlIGFueSBleGlzdGluZ1xuICAgKiBkZWZpbml0aW9ucyBmb3IgdGhpcyB0eXBlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSBlbWl0dGVkIGJ5IHRoaXMgaGFuZGxlci5cbiAgICogQHBhcmFtIGVtaXR0ZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGVtaXQgdGhlIGNvZGUgYW5kIHJldHVybnNcbiAgICogaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVtaXR0ZWQgdHlwZS5cbiAgICovXG4gIHB1YmxpYyBlbWl0Q3VzdG9tVHlwZSh0eXBlTmFtZTogc3RyaW5nLCBlbWl0dGVyOiBUeXBlRW1pdHRlciB8IENvZGVFbWl0dGVyKSB7XG4gICAgaWYgKHR5cGVOYW1lIGluIHRoaXMuZW1pdHRlZFR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50eXBlc1RvRW1pdFt0eXBlTmFtZV0gPSBjb2RlID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVtaXR0ZXIoY29kZSk7XG4gICAgICBpZiAodHlwZW9mKHJlc3VsdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlTmFtZSwgdG9Kc29uOiB4ID0+IHggfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZW1pdEN1c3RvbVR5cGUoKWBcbiAgICovXG4gIHB1YmxpYyBhZGRDb2RlKHR5cGVOYW1lOiBzdHJpbmcsIGVtaXR0ZXI6IFR5cGVFbWl0dGVyIHwgQ29kZUVtaXR0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0Q3VzdG9tVHlwZSh0eXBlTmFtZSwgZW1pdHRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhbGwgZW1pdHRlZCB0eXBlcyB0byBhIHN0cmluZy5cbiAgICpcbiAgICogVXNlIGByZW5kZXJUb0NvZGUoKWAgaW4gb3JkZXIgdG8gcmVuZGVyIG91dHB1dCB0byBhbiBleGlzdGluZyBgQ29kZWAgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIHJlbmRlcigpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvZGUgPSBuZXcgQ29kZSgpO1xuICAgIHRoaXMucmVuZGVyVG9Db2RlKGNvZGUpO1xuICAgIHJldHVybiBjb2RlLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhbGwgdHlwZXMgdG8gYSBgQ29kZU1ha2VyYCB3aXRoIGFuIG9wZW4gZmlsZS5cbiAgICogVXNlIHRoaXMgbWV0aG9kIGluIGNhc2UgeW91IG5lZWQgdG8gYWRkIHRob3NlIHR5cGUgdG8gYW4gZXhpc3RpbmcgZmlsZS5cbiAgICogQHBhcmFtIGNvZGUgVGhlIGBDb2RlTWFrZXJgIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHJlbmRlclRvQ29kZShjb2RlOiBDb2RlKSB7XG4gICAgd2hpbGUgKE9iamVjdC5rZXlzKHRoaXMudHlwZXNUb0VtaXQpLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmFtZSA9IE9iamVjdC5rZXlzKHRoaXMudHlwZXNUb0VtaXQpWzBdO1xuICAgICAgY29uc3QgZW1pdHRlciA9IHRoaXMudHlwZXNUb0VtaXRbbmFtZV07XG4gICAgICBjb25zdCBlbWl0dGVkVHlwZSA9IGVtaXR0ZXIoY29kZSk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnR5cGVzVG9FbWl0W25hbWVdO1xuICAgICAgdGhpcy5lbWl0dGVkVHlwZXNbbmFtZV0gPSBlbWl0dGVkVHlwZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByZW5kZXJUb0NvZGUoKWBcbiAgICovXG4gIHB1YmxpYyBlbWl0Q29kZShjb2RlOiBDb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9Db2RlKGNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZW1pdFR5cGUoKWBcbiAgICovXG4gIHB1YmxpYyBhZGRUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIGRlZj86IEpTT05TY2hlbWE0LCBzdHJ1Y3RGcW46IHN0cmluZyA9IHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGUodHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBhcnJheS5cbiAgICovXG4gIHByaXZhdGUgZW1pdEFycmF5KHR5cGVOYW1lOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpOiBFbWl0dGVkVHlwZSB7XG4gICAgY29uc3QgZXQgPSB0aGlzLnR5cGVGb3JBcnJheSh0eXBlTmFtZSwgZGVmKTtcbiAgICByZXR1cm4geyB0eXBlOiBgJHtldC50eXBlfVtdYCwgdG9Kc29uOiB4ID0+IGAke3h9Py5tYXAoeSA9PiAke2V0LnRvSnNvbigneScpfSlgIH07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGRlZmluaXRpb24gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgdW5pb24gb3IgZmFsc2UgaWYgaXQgY2Fubm90XG4gICAqL1xuICBwcml2YXRlIHRyeUVtaXRVbmlvbih0eXBlTmFtZTogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0LCBmcW46IHN0cmluZyk6IEVtaXR0ZWRUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBvcHRpb25zID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub25lT2YgfHwgZGVmLmFueU9mIHx8IFtdKSB7XG4gICAgICBpZiAoIXN1cHBvcnRlZFVuaW9uT3B0aW9uVHlwZShvcHRpb24udHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbi50eXBlID09PSAnaW50ZWdlcicgPyAnbnVtYmVyJyA6IG9wdGlvbi50eXBlO1xuICAgICAgb3B0aW9ucy5wdXNoKHR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVtaXR0ZWQ6IEVtaXR0ZWRUeXBlID0geyB0eXBlOiB0eXBlTmFtZSwgdG9Kc29uOiB4ID0+IGAke3h9Py52YWx1ZWAgfTtcblxuICAgIHRoaXMuYWRkQ29kZSh0eXBlTmFtZSwgY29kZSA9PiB7XG4gICAgICB0aGlzLmVtaXREZXNjcmlwdGlvbihjb2RlLCBmcW4sIGRlZi5kZXNjcmlwdGlvbik7XG5cbiAgICAgIGNvZGUub3BlbkJsb2NrKGBleHBvcnQgY2xhc3MgJHt0eXBlTmFtZX1gKTtcbiAgICAgIGNvbnN0IHBvc3NpYmxlVHlwZXMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgcG9zc2libGVUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICBjb25zdCBtZXRob2ROYW1lID0gJ2Zyb20nICsgdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSk7XG4gICAgICAgIGNvZGUub3BlbkJsb2NrKGBwdWJsaWMgc3RhdGljICR7bWV0aG9kTmFtZX0odmFsdWU6ICR7dHlwZX0pOiAke3R5cGVOYW1lfWApO1xuICAgICAgICBjb2RlLmxpbmUoYHJldHVybiBuZXcgJHt0eXBlTmFtZX0odmFsdWUpO2ApO1xuICAgICAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5vcGVuQmxvY2soYHByaXZhdGUgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHZhbHVlOiAke3Bvc3NpYmxlVHlwZXMuam9pbignIHwgJyl9KWApO1xuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbWl0dGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0U3RydWN0KHR5cGVOYW1lOiBzdHJpbmcsIHN0cnVjdERlZjogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nKTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IHRvSnNvbiA9IG5ldyBUb0pzb25GdW5jdGlvbih0eXBlTmFtZSk7XG4gICAgY29uc3QgZW1pdHRlZDogRW1pdHRlZFR5cGUgPSB7XG4gICAgICB0eXBlOiB0eXBlTmFtZSxcbiAgICAgIHRvSnNvbjogeCA9PiBgJHt0b0pzb24uZnVuY3Rpb25OYW1lfSgke3h9KWAsXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdEN1c3RvbVR5cGUodHlwZU5hbWUsIGNvZGUgPT4ge1xuXG4gICAgICB0aGlzLmVtaXREZXNjcmlwdGlvbihjb2RlLCBzdHJ1Y3RGcW4sIHN0cnVjdERlZi5kZXNjcmlwdGlvbik7XG4gICAgICBjb2RlLm9wZW5CbG9jayhgZXhwb3J0IGludGVyZmFjZSAke3R5cGVOYW1lfWApO1xuXG4gICAgICBmb3IgKGNvbnN0IFtwcm9wTmFtZSwgcHJvcFNwZWNdIG9mIE9iamVjdC5lbnRyaWVzKHN0cnVjdERlZi5wcm9wZXJ0aWVzIHx8IHt9KSkge1xuICAgICAgICB0aGlzLmVtaXRQcm9wZXJ0eShjb2RlLCBwcm9wTmFtZSwgcHJvcFNwZWMsIHN0cnVjdEZxbiwgc3RydWN0RGVmLCB0b0pzb24pO1xuICAgICAgfVxuXG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgICAgaWYgKHRoaXMudG9Kc29uKSB7XG4gICAgICAgIHRvSnNvbi5lbWl0KGNvZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbWl0dGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9wZXJ0eUZxbihzdHJ1Y3RGcW46IHN0cmluZywgcHJvcE5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBgJHtzdHJ1Y3RGcW59LiR7cHJvcE5hbWV9YDtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdFByb3BlcnR5KGNvZGU6IENvZGUsIG5hbWU6IHN0cmluZywgcHJvcERlZjogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nLCBzdHJ1Y3REZWY6IEpTT05TY2hlbWE0LCB0b0pzb246IFRvSnNvbkZ1bmN0aW9uKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gbmFtZTtcblxuICAgIC8vIGlmIHRoZSBuYW1lIHN0YXJ0cyB3aXRoICckJyAobGlrZSAkcmVmIG9yICRzY2hlbWEpLCB3ZSByZW1vdmUgdGhlIFwiJFwiXG4gICAgLy8gYW5kIGl0J3MgdGhlIHNhbWUgZGVhbCAtIHdpbGwgcHJvZHVjZSBpbnZhbGlkIG91dHB1dFxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdGhlIG5hbWUgdG8gY2FtZWwgY2FzZSBzbyBpdCdzIGNvbXBhdGlibGUgd2l0aCBKU0lJXG4gICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcblxuICAgIGNvbnN0IHByb3BlcnR5RnFuID0gdGhpcy5wcm9wZXJ0eUZxbihzdHJ1Y3RGcW4sIG5hbWUpO1xuXG4gICAgaWYgKHRoaXMuZW1pdHRlZFByb3BlcnRpZXMuaGFzKHByb3BlcnR5RnFuKSkge1xuICAgICAgLy8gY2FuIGhhcHBlbiBpZiB0d28gcHJvcGVydGllcyBoYXZlIGRpZmZlcmVudCBjYXNpbmcgdGhhdCByZXN1bHRzXG4gICAgICAvLyBpbiB0aGUgc2FtZSBjYW1lbENhc2Ugc3RyaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdERlc2NyaXB0aW9uKGNvZGUsIGAke3N0cnVjdEZxbn0jJHtvcmlnaW5hbE5hbWV9YCwgcHJvcERlZi5kZXNjcmlwdGlvbik7XG4gICAgY29uc3QgcHJvcGVydHlUeXBlID0gdGhpcy50eXBlRm9yUHJvcGVydHkoYCR7c3RydWN0RnFufS4ke25hbWV9YCwgcHJvcERlZik7XG4gICAgY29uc3QgcmVxdWlyZWQgPSB0aGlzLmlzUHJvcGVydHlSZXF1aXJlZChvcmlnaW5hbE5hbWUsIHN0cnVjdERlZik7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSByZXF1aXJlZCA/ICcnIDogJz8nO1xuXG4gICAgY29kZS5saW5lKGByZWFkb25seSAke25hbWV9JHtvcHRpb25hbH06ICR7cHJvcGVydHlUeXBlLnR5cGV9O2ApO1xuICAgIGNvZGUubGluZSgpO1xuXG4gICAgdG9Kc29uLmFkZEZpZWxkKG9yaWdpbmFsTmFtZSwgbmFtZSwgcHJvcGVydHlUeXBlLnRvSnNvbik7XG4gICAgdGhpcy5lbWl0dGVkUHJvcGVydGllcy5hZGQocHJvcGVydHlGcW4pO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0RW51bSh0eXBlTmFtZTogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0LCBzdHJ1Y3RGcW46IHN0cmluZyk6IEVtaXR0ZWRUeXBlIHtcbiAgICBjb25zdCBlbWl0dGVkOiBFbWl0dGVkVHlwZSA9IHtcbiAgICAgIHR5cGU6IHR5cGVOYW1lLFxuICAgICAgdG9Kc29uOiB4ID0+IHgsXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdEN1c3RvbVR5cGUodHlwZU5hbWUsIGNvZGUgPT4ge1xuXG4gICAgICBpZiAoIWRlZi5lbnVtIHx8IGRlZi5lbnVtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlZmluaXRpb24gaXMgbm90IGFuIGVudW06ICR7SlNPTi5zdHJpbmdpZnkoZGVmKX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZi50eXBlICYmICEoZGVmLnR5cGUgPT09ICdzdHJpbmcnIHx8IGRlZi50eXBlID09PSAnbnVtYmVyJyB8fCBkZWYudHlwZSA9PT0gJ2ludGVnZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgZW51bXMgd2l0aCBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlcyBhcmUgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdERlc2NyaXB0aW9uKGNvZGUsIHN0cnVjdEZxbiwgZGVmLmRlc2NyaXB0aW9uKTtcblxuICAgICAgY29kZS5vcGVuQmxvY2soYGV4cG9ydCBlbnVtICR7dHlwZU5hbWV9YCk7XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NlZFZhbHVlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRlZi5lbnVtKSB7XG4gICAgICAgIGlmICghWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mKHZhbHVlKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgZW51bXMgd2l0aCBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlcyBhcmUgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWVtYmVyTmFtZSA9IHNuYWtlQ2FzZShyZXdyaXRlTmFtZWRTeW1ib2xzKGAke3ZhbHVlfWApLnJlcGxhY2UoL1teYS16MC05XS9naSwgJ18nKSkuc3BsaXQoJ18nKS5maWx0ZXIoeCA9PiB4KS5qb2luKCdfJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAvLyBJZiBlbnVtcyBvZiBzYW1lIHZhbHVlIGV4aXN0cywgdGhlbiB3ZSBjaG9vc2Ugb25lIG9mIHRoZW0gYW5kIHNraXAgYWRkaW5nIG90aGVyc1xuICAgICAgICAvLyBzaW5jZSB0aGF0IHdvdWxkIGNhdXNlIGNvbmZsaWN0XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZVZhbHVlID0gdmFsdWU/LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZVZhbHVlICYmICFwcm9jZXNzZWRWYWx1ZXMuaGFzKGxvd2VyQ2FzZVZhbHVlKSkge1xuICAgICAgICAgIHByb2Nlc3NlZFZhbHVlcy5hZGQobG93ZXJDYXNlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggYSBub24tYWxwaGEgY2hhcmFjdGVyLCBhZGQgYSBwcmVmaXggc28gaXQgYmVjb21lcyBhIHN5bWJvbFxuICAgICAgICBpZiAoIS9eW0EtWl0uKi9pLnRlc3QobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICBtZW1iZXJOYW1lID0gJ1ZBTFVFXycgKyBtZW1iZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5saW5lKGAvKiogJHt2YWx1ZX0gKi9gKTtcbiAgICAgICAgY29kZS5saW5lKGAke21lbWJlck5hbWV9ID0gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LGApO1xuICAgICAgfVxuXG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW1pdHRlZDtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdERlc2NyaXB0aW9uKGNvZGU6IENvZGUsIGZxbjogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZywgYW5ub3RhdGlvbnM6IHsgW3R5cGU6IHN0cmluZ106IHN0cmluZyB9ID0geyB9KSB7XG4gICAgY29kZS5saW5lKCcvKionKTtcblxuICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKC9cXCpcXC8vZywgJ18vJyk7XG5cbiAgICAgIGZvciAoY29uc3QgZGxpbmUgb2YgZGVzY3JpcHRpb24uc3BsaXQoJ1xcbicpLm1hcCh4ID0+IHgudHJpbSgpKSkge1xuICAgICAgICBjb2RlLmxpbmUoYCAqICR7ZGxpbmV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhY3REZWZhdWx0ID0gL0RlZmF1bHRzP1xcVysodG98aXMpXFxXKyguKykvZy5leGVjKGRlc2NyaXB0aW9uKTtcbiAgICAgIGNvbnN0IGRlZiA9IGV4dHJhY3REZWZhdWx0ICYmIGV4dHJhY3REZWZhdWx0WzJdO1xuICAgICAgaWYgKGRlZikge1xuICAgICAgICBhbm5vdGF0aW9ucy5kZWZhdWx0ID0gZGVmO1xuICAgICAgfVxuXG4gICAgICBjb2RlLmxpbmUoJyAqJyk7XG4gICAgfVxuXG4gICAgYW5ub3RhdGlvbnMuc2NoZW1hID0gZnFuO1xuXG4gICAgZm9yIChjb25zdCBbdHlwZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFubm90YXRpb25zKSkge1xuICAgICAgY29kZS5saW5lKGAgKiBAJHt0eXBlfSAke3ZhbHVlfWApO1xuICAgIH1cblxuICAgIGNvZGUubGluZSgnICovJyk7XG4gIH1cblxuICBwcml2YXRlIHR5cGVGb3JQcm9wZXJ0eShwcm9wZXJ0eUZxbjogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0KTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBUeXBlR2VuZXJhdG9yLm5vcm1hbGl6ZVR5cGVOYW1lKERFRkFVTFRfUkVOREVSX1RZUEVfTkFNRShwcm9wZXJ0eUZxbikpO1xuICAgIHJldHVybiB0aGlzLmVtaXRUeXBlSW50ZXJuYWwoc3VidHlwZSwgZGVmLCBzdWJ0eXBlKTtcbiAgfVxuXG4gIHByaXZhdGUgdHlwZUZvclJlZihkZWY6IEpTT05TY2hlbWE0KTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IHByZWZpeCA9ICcjL2RlZmluaXRpb25zLyc7XG4gICAgaWYgKCFkZWYuJHJlZiB8fCAhZGVmLiRyZWYuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgJHJlZiAke0pTT04uc3RyaW5naWZ5KGRlZil9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFeGNsdWRlZChkZWYuJHJlZikpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6ICdhbnknLCB0b0pzb246IHggPT4geCB9O1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVOYW1lID0gVHlwZUdlbmVyYXRvci5ub3JtYWxpemVUeXBlTmFtZSh0aGlzLnJlbmRlclR5cGVOYW1lKGRlZi4kcmVmLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKSkpO1xuXG4gICAgLy8gaWYgd2UgYWxyZWFkeSBlbWl0dGVkIGEgdHlwZSB3aXRoIHRoaXMgdHlwZSBuYW1lLCBqdXN0IHJldHVybiBpdFxuICAgIGNvbnN0IGVtaXR0ZWQgPSB0aGlzLmVtaXR0ZWRUeXBlc1t0eXBlTmFtZV07XG4gICAgaWYgKGVtaXR0ZWQpIHtcbiAgICAgIHJldHVybiBlbWl0dGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZVJlZmVyZW5jZShkZWYpO1xuICAgIHJldHVybiB0aGlzLmVtaXRUeXBlSW50ZXJuYWwodHlwZU5hbWUsIHNjaGVtYSwgZGVmLiRyZWYpO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlRm9yQXJyYXkocHJvcGVydHlGcW46IHN0cmluZywgZGVmOiBKU09OU2NoZW1hNCk6IEVtaXR0ZWRUeXBlIHtcbiAgICBpZiAoIWRlZi5pdGVtcyB8fCB0eXBlb2YoZGVmLml0ZW1zKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIEZhbGxpbmcgYmFjayB0byBhbiBhcnJheSBvZiBhbnkgdHlwZVxuICAgICAgZGVmLml0ZW1zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudHlwZUZvclByb3BlcnR5KHByb3BlcnR5RnFuLCBkZWYuaXRlbXMpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlUmVmZXJlbmNlKGRlZjogSlNPTlNjaGVtYTQpOiBKU09OU2NoZW1hNCB7XG4gICAgY29uc3QgcmVmID0gZGVmLiRyZWY7XG4gICAgaWYgKCFyZWYgfHwgIXJlZi5zdGFydHNXaXRoKERFRklOSVRJT05TX1BSRUZJWCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGEgbG9jYWwgcmVmZXJlbmNlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9va3VwID0gcmVmLnN1YnN0cihERUZJTklUSU9OU19QUkVGSVgubGVuZ3RoKTtcbiAgICBjb25zdCBmb3VuZCA9IHRoaXMuZGVmaW5pdGlvbnNbbG9va3VwXTtcbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgdGhlICRyZWYgXCIke2xvb2t1cH1cImApO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIHByaXZhdGUgaXNQcm9wZXJ0eVJlcXVpcmVkKHByb3BlcnR5OiBzdHJpbmcsIHN0cnVjdERlZjogSlNPTlNjaGVtYTQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHJ1Y3REZWYucmVxdWlyZWQpICYmIHN0cnVjdERlZi5yZXF1aXJlZC5pbmNsdWRlcyhwcm9wZXJ0eSk7XG4gIH1cblxuICBwcml2YXRlIGlzRXhjbHVkZWQoZnFuOiBzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5leGNsdWRlKSB7XG4gICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgICBpZiAocmUudGVzdChmcW4pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRlZFVuaW9uT3B0aW9uVHlwZSh0eXBlOiBhbnkpOiB0eXBlIGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlICYmICh0eXBlb2YodHlwZSkgPT09ICdzdHJpbmcnICYmIFBSSU1JVElWRV9UWVBFUy5pbmNsdWRlcyh0eXBlKSk7XG59XG5cbmZ1bmN0aW9uIHBhc2NhbENhc2Uoczogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNhbWVsQ2FzZShzLCB7IHBhc2NhbENhc2U6IHRydWUgfSk7XG59XG5cbmludGVyZmFjZSBFbWl0dGVkVHlwZSB7XG4gIC8qKlxuICAgKiBUaGUgSmF2YVNjcmlwdCB0eXBlIHRvIGVtaXQuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvZGUgdG8gY29udmVydCBhIHN0YXRlbWVudCBgc2AgYmFjayB0byBKU09OLlxuICAgKi9cbiAgcmVhZG9ubHkgdG9Kc29uOiAoY29kZTogc3RyaW5nKSA9PiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHJld3JpdGVOYW1lZFN5bWJvbHMoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgbGV0IGN1cnNvciA9IDA7XG4gIHdoaWxlIChjdXJzb3IgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBjb25zdCBbcHJlZml4TmFtZSwgcHJlZml4TGVuXSA9IGxvbmdlc3RQcmVmaXhNYXRjaChpbnB1dCwgY3Vyc29yLCBOQU1FRF9TWU1CT0xTKTtcbiAgICBpZiAocHJlZml4TmFtZSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gYF8ke3ByZWZpeE5hbWV9X2Auc3BsaXQoJycpO1xuICAgICAgcmV0LnB1c2goLi4ucHJlZml4KTtcbiAgICAgIGN1cnNvciArPSBwcmVmaXhMZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGlucHV0LmNoYXJBdChjdXJzb3IpKTtcbiAgICAgIGN1cnNvciArPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB1bmRlcnNjb3JlcyBpZiBpdHMgb25seSBwcmVmaXggdG8gYmUgcmV0dXJuZWRcbiAgaWYgKHJldFswXSA9PT0gJ18nKSB7IHJldC51bnNoaWZ0KCdWQUxVRScpOyB9XG4gIGlmIChyZXRbcmV0Lmxlbmd0aCAtIDFdID09PSAnXycpIHsgcmV0LnBvcCgpOyB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gbG9uZ2VzdFByZWZpeE1hdGNoKGlucHV0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIGxvb2t1cFRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogW3N0cmluZyB8IHVuZGVmaW5lZCwgbnVtYmVyXSB7XG4gIGxldCByZXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgbGV0IGxvbmdlc3Q6IG51bWJlciA9IDA7XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGxvb2t1cFRhYmxlKSkge1xuICAgIGlmIChoYXNTdWJTdHJpbmdBdChpbnB1dCwgaW5kZXgsIHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiBsb25nZXN0ICYmICFpc0V4ZW1wdFBhdHRlcm4oaW5wdXQsIGluZGV4KSkge1xuICAgICAgcmV0ID0gbmFtZTtcbiAgICAgIGxvbmdlc3QgPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBbcmV0LCBsb25nZXN0XTtcbn1cblxuZnVuY3Rpb24gaGFzU3ViU3RyaW5nQXQoaW5wdXQ6IHN0cmluZywgaW5kZXg6IG51bWJlciwgc3Vic3RyaW5nOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKGluZGV4ID09IGlucHV0LmluZGV4T2Yoc3Vic3RyaW5nLCBpbmRleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeGVtcHRQYXR0ZXJuKGlucHV0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgZXhlbXB0UGF0dGVybnMgPSBbXG4gICAgLy8gOS45LCA5LlxuICAgIC8oPzw9XFxkKVxcLlxcZC8sXG4gIF07XG5cbiAgcmV0dXJuIGV4ZW1wdFBhdHRlcm5zLnNvbWUoKHApID0+IHRlc3RSZWdleEF0KHAsIGlucHV0LCBpbmRleCkpO1xufVxuXG5mdW5jdGlvbiB0ZXN0UmVnZXhBdChyZWdleDogUmVnRXhwLCBpbnB1dDogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChyZWdleCwgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gaW5kZXg7XG5cbiAgcmV0dXJuIHJlLnRlc3QoaW5wdXQpO1xufVxuXG50eXBlIFR5cGVFbWl0dGVyID0gKGNvZGU6IENvZGUpID0+IEVtaXR0ZWRUeXBlO1xudHlwZSBDb2RlRW1pdHRlciA9IChjb2RlOiBDb2RlKSA9PiB2b2lkO1xuIl19