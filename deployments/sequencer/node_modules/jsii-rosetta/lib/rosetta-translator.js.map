{"version":3,"file":"rosetta-translator.js","sourceRoot":"","sources":["../src/rosetta-translator.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fs } from 'node:fs';\nimport * as spec from '@jsii/spec';\n\nimport { TypeFingerprinter } from './jsii/fingerprinting';\nimport { TARGET_LANGUAGES } from './languages';\nimport * as logging from './logging';\nimport { TypeScriptSnippet, completeSource } from './snippet';\nimport {\n  collectDependencies,\n  validateAvailableDependencies,\n  prepareDependencyDirectory,\n  expandWithTransitiveDependencies,\n} from './snippet-dependencies';\nimport { snippetKey } from './tablets/key';\nimport { LanguageTablet, TranslatedSnippet } from './tablets/tablets';\nimport { translateAll, TranslateAllResult } from './translate_all';\n\nexport interface RosettaTranslatorOptions {\n  /**\n   * Assemblies to use for fingerprinting\n   *\n   * The set of assemblies here are used to invalidate the cache. Any types that are\n   * used in snippets are looked up in this set of assemblies. If found, their type\n   * information is fingerprinted and compared to the type information at the time\n   * compilation of the cached sample. If different, this is considered to be a cache\n   * miss.\n   *\n   * You must use the same set of assemblies when generating and reading the cache\n   * file, otherwise the fingerprint is guaranteed to be different and the cache will\n   * be useless (e.g. if you generate the cache WITH assembly information but\n   * read it without, or vice versa).\n   *\n   * @default No assemblies.\n   */\n  readonly assemblies?: spec.Assembly[];\n\n  /**\n   * Whether to include compiler diagnostics in the compilation results.\n   *\n   * @default false\n   */\n  readonly includeCompilerDiagnostics?: boolean;\n\n  /**\n   * Allow reading dirty translations from cache\n   *\n   * @default false\n   */\n  readonly allowDirtyTranslations?: boolean;\n}\n\n/**\n * Entry point for consumers that want to translate code on-the-fly\n *\n * If you want to generate and translate code on-the-fly, in ways that cannot\n * be achieved by the rosetta CLI, use this class.\n */\nexport class RosettaTranslator {\n  /**\n   * Tablet with fresh translations\n   *\n   * All new translations (not read from cache) are added to this tablet.\n   */\n  public readonly tablet = new LanguageTablet();\n\n  public readonly cache = new LanguageTablet();\n\n  private readonly fingerprinter: TypeFingerprinter;\n  private readonly includeCompilerDiagnostics: boolean;\n  private readonly allowDirtyTranslations: boolean;\n\n  public constructor(options: RosettaTranslatorOptions = {}) {\n    this.fingerprinter = new TypeFingerprinter(options?.assemblies ?? []);\n    this.includeCompilerDiagnostics = options.includeCompilerDiagnostics ?? false;\n    this.allowDirtyTranslations = options.allowDirtyTranslations ?? false;\n  }\n\n  /**\n   * @deprecated use `addToCache` instead\n   */\n  public async loadCache(fileName: string) {\n    try {\n      await this.cache.load(fileName);\n    } catch (e: any) {\n      logging.warn(`Error reading cache ${fileName}: ${e.message}`);\n    }\n  }\n\n  public async addToCache(filename: string) {\n    const tab = await LanguageTablet.fromOptionalFile(filename);\n    this.cache.addTablet(tab);\n  }\n\n  public addTabletsToCache(...tablets: LanguageTablet[]) {\n    for (const tab of tablets) {\n      this.cache.addTablet(tab);\n    }\n  }\n\n  public hasCache() {\n    return this.cache.count > 0;\n  }\n\n  /**\n   * For all the given snippets, try to read translations from the cache\n   *\n   * Will remove the cached snippets from the input array.\n   */\n  public readFromCache(snippets: TypeScriptSnippet[], addToTablet = true, compiledOnly = false): ReadFromCacheResults {\n    const translations = new Array<TranslatedSnippet>();\n    const remaining = new Array<TypeScriptSnippet>();\n\n    let infusedCount = 0;\n    let dirtyCount = 0;\n    let dirtySourceCount = 0;\n    let dirtyTypesCount = 0;\n    let dirtyTranslatorCount = 0;\n    let dirtyDidntCompile = 0;\n\n    for (const snippet of snippets) {\n      const fromCache = tryReadFromCache(snippet, this.cache, this.fingerprinter, compiledOnly);\n      switch (fromCache.type) {\n        case 'hit':\n          if (addToTablet) {\n            this.tablet.addSnippet(fromCache.snippet);\n          }\n          translations.push(fromCache.snippet);\n\n          infusedCount += fromCache.infused ? 1 : 0;\n          break;\n\n        case 'dirty':\n          dirtyCount += 1;\n          dirtySourceCount += fromCache.dirtySource ? 1 : 0;\n          dirtyTranslatorCount += fromCache.dirtyTranslator ? 1 : 0;\n          dirtyTypesCount += fromCache.dirtyTypes ? 1 : 0;\n          dirtyDidntCompile += fromCache.dirtyDidntCompile ? 1 : 0;\n\n          if (this.allowDirtyTranslations) {\n            translations.push(fromCache.translation);\n          } else {\n            remaining.push(snippet);\n          }\n          break;\n\n        case 'miss':\n          remaining.push(snippet);\n          break;\n      }\n    }\n\n    return {\n      translations,\n      remaining,\n      infusedCount,\n      dirtyCount,\n      dirtySourceCount,\n      dirtyTranslatorCount,\n      dirtyTypesCount,\n      dirtyDidntCompile,\n    };\n  }\n\n  public async translateAll(snippets: TypeScriptSnippet[], addToTablet?: boolean): Promise<TranslateAllResult>;\n  public async translateAll(snippets: TypeScriptSnippet[], options?: TranslateAllOptions): Promise<TranslateAllResult>;\n  public async translateAll(\n    snippets: TypeScriptSnippet[],\n    optionsOrAddToTablet?: boolean | TranslateAllOptions,\n  ): Promise<TranslateAllResult> {\n    const options =\n      optionsOrAddToTablet && typeof optionsOrAddToTablet === 'object'\n        ? optionsOrAddToTablet\n        : { addToTablet: optionsOrAddToTablet };\n\n    const exampleDependencies = collectDependencies(snippets);\n    await expandWithTransitiveDependencies(exampleDependencies);\n\n    let compilationDirectory;\n    let cleanCompilationDir = false;\n    if (options?.compilationDirectory) {\n      // If the user provided a directory, we're going to trust-but-confirm.\n      await validateAvailableDependencies(options.compilationDirectory, exampleDependencies);\n      compilationDirectory = options.compilationDirectory;\n    } else {\n      compilationDirectory = await prepareDependencyDirectory(exampleDependencies);\n      cleanCompilationDir = true;\n    }\n\n    const origDir = process.cwd();\n    // Easiest way to get a fixed working directory (for sources) in is to chdir\n    process.chdir(compilationDirectory);\n\n    let result;\n    try {\n      result = await translateAll(snippets, this.includeCompilerDiagnostics);\n    } finally {\n      process.chdir(origDir);\n      if (cleanCompilationDir) {\n        if (options.cleanup ?? true) {\n          await fs.rm(compilationDirectory, { force: true, recursive: true });\n        } else {\n          logging.info(`Leaving directory uncleaned: ${compilationDirectory}`);\n        }\n      }\n    }\n\n    const fingerprinted = result.translatedSnippets.map((snippet) =>\n      snippet.withFingerprint(this.fingerprinter.fingerprintAll(snippet.fqnsReferenced())),\n    );\n\n    if (options?.addToTablet ?? true) {\n      for (const translation of fingerprinted) {\n        this.tablet.addSnippet(translation);\n      }\n    }\n\n    return {\n      translatedSnippets: fingerprinted,\n      diagnostics: result.diagnostics,\n    };\n  }\n}\n\n/**\n * Try to find the translation for the given snippet in the given cache\n *\n * Rules for cacheability are:\n * - id is the same (== visible source didn't change)\n * - complete source is the same (== fixture didn't change)\n * - all types involved have the same fingerprint (== API surface didn't change)\n * - the versions of all translations match the versions on the available translators (== translator itself didn't change)\n *\n * For the versions check: we could have selectively picked some translations\n * from the cache while performing others. However, since the big work is in\n * parsing the TypeScript, and the rendering itself is peanutes (assumption), it\n * doesn't really make a lot of difference.  So, for simplification's sake,\n * we'll regen all translations if there's at least one that's outdated.\n */\nfunction tryReadFromCache(\n  sourceSnippet: TypeScriptSnippet,\n  cache: LanguageTablet,\n  fingerprinter: TypeFingerprinter,\n  compiledOnly: boolean,\n): CacheHit {\n  const fromCache = cache.tryGetSnippet(snippetKey(sourceSnippet));\n\n  if (!fromCache) {\n    return { type: 'miss' };\n  }\n\n  // infused snippets won't pass the full source check or the fingerprinter\n  // but there is no reason to try to recompile it, so return cached snippet\n  // if there exists one.\n  if (isInfused(sourceSnippet)) {\n    return { type: 'hit', snippet: fromCache, infused: true };\n  }\n\n  const dirtySource = completeSource(sourceSnippet) !== fromCache.snippet.fullSource;\n  const dirtyTranslator = !Object.entries(TARGET_LANGUAGES).every(\n    ([lang, translator]) => fromCache.snippet.translations?.[lang]?.version === translator.version,\n  );\n  const dirtyTypes = fingerprinter.fingerprintAll(fromCache.fqnsReferenced()) !== fromCache.snippet.fqnsFingerprint;\n  const dirtyDidntCompile = compiledOnly && !fromCache.snippet.didCompile;\n\n  if (dirtySource || dirtyTranslator || dirtyTypes || dirtyDidntCompile) {\n    return { type: 'dirty', translation: fromCache, dirtySource, dirtyTranslator, dirtyTypes, dirtyDidntCompile };\n  }\n  return { type: 'hit', snippet: fromCache, infused: false };\n}\n\nexport type CacheHit =\n  | { readonly type: 'miss' }\n  | { readonly type: 'hit'; readonly snippet: TranslatedSnippet; readonly infused: boolean }\n  | {\n      readonly type: 'dirty';\n      readonly translation: TranslatedSnippet;\n      readonly dirtySource: boolean;\n      readonly dirtyTranslator: boolean;\n      readonly dirtyTypes: boolean;\n      readonly dirtyDidntCompile: boolean;\n    };\n\nfunction isInfused(snippet: TypeScriptSnippet) {\n  return snippet.parameters?.infused !== undefined;\n}\n\nexport interface ReadFromCacheResults {\n  /**\n   * Successful translations\n   */\n  readonly translations: TranslatedSnippet[];\n\n  /**\n   * Successful but dirty hits\n   */\n  readonly remaining: TypeScriptSnippet[];\n\n  /**\n   * How many successfully hit translations were infused\n   */\n  readonly infusedCount: number;\n\n  readonly dirtyCount: number;\n\n  // Counts for dirtiness (a single snippet may be dirty for more than one reason)\n  readonly dirtySourceCount: number;\n  readonly dirtyTranslatorCount: number;\n  readonly dirtyTypesCount: number;\n  readonly dirtyDidntCompile: number;\n}\n\nexport interface TranslateAllOptions {\n  /**\n   * @default - Create a temporary directory with all necessary packages\n   */\n  readonly compilationDirectory?: string;\n\n  /**\n   * @default true\n   */\n  readonly addToTablet?: boolean;\n\n  /**\n   * @default true\n   */\n  readonly cleanup?: boolean;\n}\n"]}