{"version":3,"file":"infuse.js","sourceRoot":"","sources":["../../src/commands/infuse.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as spec from '@jsii/spec';\nimport { replaceAssembly } from '@jsii/spec';\n\nimport { loadAssemblies, loadAllDefaultTablets, LoadedAssembly, allTypeScriptSnippets } from '../jsii/assemblies';\nimport { renderMetadataline, TypeScriptSnippet } from '../snippet';\nimport { SnippetSelector, mean, meanLength, shortest, longest } from '../snippet-selectors';\nimport { snippetKey } from '../tablets/key';\nimport {\n  LanguageTablet,\n  TranslatedSnippet,\n  DEFAULT_TABLET_NAME,\n  DEFAULT_TABLET_NAME_COMPRESSED,\n} from '../tablets/tablets';\nimport { isDefined, mkDict, indexBy } from '../util';\n\nexport interface InfuseResult {\n  readonly coverageResults: Record<string, InfuseTypes>;\n}\n\nexport interface InfuseTypes {\n  readonly types: number;\n  readonly typesWithInsertedExamples: number;\n}\n\nexport interface InfuseOptions {\n  readonly logFile?: string;\n\n  /**\n   * Where to read additional translations\n   */\n  readonly cacheFromFile?: string;\n\n  /**\n   * In addition to the implicit tablets, also write all added examples to this additional output tablet\n   */\n  readonly cacheToFile?: string;\n\n  /**\n   * Compress the cacheToFile\n   */\n  readonly compressCacheToFile?: boolean;\n}\n\nexport const DEFAULT_INFUSION_RESULTS_NAME = 'infusion-results.html';\n\nconst ADDITIONAL_SELECTORS: Record<string, SnippetSelector> = { meanLength, shortest, longest };\n\nclass DefaultRecord<A> {\n  public readonly index: Record<string, A[]> = {};\n\n  public add(key: string, value: A) {\n    if (!this.index[key]) {\n      this.index[key] = [];\n    }\n    this.index[key].push(value);\n  }\n}\n\n/**\n * Infuse will analyze the snippets in a set of tablets, and update the assembly to add\n * examples to types that don't have any yet, based on snippets that use the given type.\n */\nexport async function infuse(assemblyLocations: string[], options?: InfuseOptions): Promise<InfuseResult> {\n  let stream: fs.WriteStream | undefined = undefined;\n  if (options?.logFile) {\n    // Create stream for html file and insert some styling\n    stream = fs.createWriteStream(options.logFile, { encoding: 'utf-8' });\n    startFile(stream);\n  }\n\n  // Load tablet file and assemblies\n  const assemblies = loadAssemblies(assemblyLocations, false);\n  const defaultTablets = await loadAllDefaultTablets(assemblies);\n\n  const availableTranslations = new LanguageTablet();\n  if (options?.cacheFromFile) {\n    availableTranslations.addTablet(await LanguageTablet.fromOptionalFile(options.cacheFromFile));\n  }\n  availableTranslations.addTablets(...Object.values(defaultTablets));\n\n  const { translationsByFqn, originalsByKey } = await availableSnippetsPerFqn(assemblies, availableTranslations);\n\n  const additionalOutputTablet = options?.cacheToFile\n    ? await LanguageTablet.fromOptionalFile(options?.cacheToFile)\n    : new LanguageTablet();\n\n  const coverageResults = mkDict(\n    await Promise.all(\n      assemblies.map(async ({ assembly, directory }) => {\n        stream?.write(`<h1>${assembly.name}</h1>\\n`);\n\n        const implicitTablet = defaultTablets[directory];\n        const implicitTabletFile = path.join(\n          directory,\n          implicitTablet.compressedSource ? DEFAULT_TABLET_NAME_COMPRESSED : DEFAULT_TABLET_NAME,\n        );\n        if (!implicitTablet) {\n          throw new Error(`No tablet found for ${directory}`);\n        }\n\n        let insertedExamples = 0;\n        const filteredTypes = filterForTypesWithoutExamples(assembly.types ?? {});\n        for (const [typeFqn, type] of Object.entries(filteredTypes)) {\n          const available = translationsByFqn[typeFqn];\n          if (!available) {\n            continue;\n          }\n\n          const example = pickBestExample(typeFqn, available, stream);\n          const original = originalsByKey[example.key];\n          insertExample(example, original, type, [implicitTablet, additionalOutputTablet]);\n          insertedExamples++;\n        }\n\n        if (insertedExamples > 0) {\n          // Save the updated assembly and implicit tablets\n          // eslint-disable-next-line no-await-in-loop\n          await Promise.all([\n            replaceAssembly(assembly, directory),\n            implicitTablet.save(implicitTabletFile, implicitTablet.compressedSource),\n          ]);\n        }\n\n        return [\n          directory,\n          {\n            types: Object.keys(filteredTypes).length,\n            typesWithInsertedExamples: insertedExamples,\n          } as InfuseTypes,\n        ] as const;\n      }),\n    ),\n  );\n\n  stream?.close();\n\n  // If we copied examples onto different types, we'll also have inserted new snippets\n  // with different keys into the tablet. We must now write the updated tablet somewhere.\n  if (options?.cacheToFile) {\n    await additionalOutputTablet.save(options.cacheToFile, options.compressCacheToFile);\n  }\n\n  return {\n    coverageResults: coverageResults,\n  };\n}\n\nfunction pickBestExample(typeFqn: string, choices: TranslatedSnippet[], logStream?: fs.WriteStream) {\n  const meanResult = mean(choices);\n  if (logStream) {\n    const selected = Object.entries(ADDITIONAL_SELECTORS).map(([name, fn]) => [name, fn(choices)] as const);\n    const selectedFromSelector = {\n      ...makeDict(selected),\n      mean: meanResult,\n    };\n    logOutput(logStream, typeFqn, createHtmlEntry(selectedFromSelector));\n  }\n  return meanResult;\n}\n\nfunction startFile(stream: fs.WriteStream) {\n  stream.write('<style>\\n');\n  stream.write('h2 { color: blue; clear: both; }\\n');\n  stream.write('h1 { color: red; clear: both; }\\n');\n  stream.write(\n    'div { float: left; height: 31em; width: 22em; overflow: auto; margin: 1em; background-color: #ddd; }\\n',\n  );\n  stream.write(\n    'pre { float: left; height: 30em; width: 25em; overflow: auto; padding: 0.5em; background-color: #ddd; }\\n',\n  );\n  stream.write('</style>\\n');\n}\n\nfunction createHtmlEntry(results: Record<string, TranslatedSnippet>): Record<string, string[]> {\n  const entry = new DefaultRecord<string>();\n  for (const [key, value] of Object.entries(results)) {\n    entry.add(value.originalSource.source, key);\n  }\n  return entry.index;\n}\n\nfunction logOutput(stream: fs.WriteStream | undefined, typeFqn: string, algorithmMap: Record<string, string[]>) {\n  stream?.write(`<h2>${typeFqn}</h2>\\n`);\n  for (const [key, value] of Object.entries(algorithmMap)) {\n    stream?.write(`<div class=\"snippet\"><h3>${value.toString()}</h3>\\n<pre>${key}</pre>\\n</div>\\n`);\n  }\n  for (let i = 0; i < 4 - Object.keys(algorithmMap).length; i++) {\n    stream?.write('<div class=\"padding\"></div>\\n');\n  }\n}\n\nfunction filterForTypesWithoutExamples(types: { [fqn: string]: spec.Type }): Record<string, spec.Type> {\n  const filteredTypes: Record<string, spec.Type> = {};\n  for (const [typeFqn, type] of Object.entries(types)) {\n    // Ignore Interfaces that contain only properties\n    if (type.kind === spec.TypeKind.Interface && !type.datatype) {\n      continue;\n    }\n    // Already has example\n    if (type.docs?.example !== undefined) {\n      continue;\n    }\n    filteredTypes[typeFqn] = type;\n  }\n  return filteredTypes;\n}\n\n/**\n * Insert an example into the docs of a type, and insert it back into the tablet under a new key\n */\nfunction insertExample(\n  example: TranslatedSnippet,\n  original: TypeScriptSnippet | undefined,\n  type: spec.Type,\n  tablets: LanguageTablet[],\n): void {\n  const parameters = {\n    ...original?.parameters,\n    infused: '',\n  };\n  // exampleMetadata should always be nonempty since we always have a parameter.\n  const exampleMetadata = renderMetadataline(parameters) ?? '';\n\n  if (type.docs) {\n    type.docs.example = example.originalSource.source;\n    type.docs.custom = { ...type.docs.custom, exampleMetadata };\n  } else {\n    type.docs = {\n      example: example.originalSource.source,\n      custom: { exampleMetadata },\n    };\n  }\n\n  for (const tablet of tablets) {\n    tablet.addSnippet(\n      example.withLocation({\n        api: { api: 'type', fqn: type.fqn },\n        field: { field: 'example' },\n      }),\n    );\n  }\n}\n\n/**\n * Return a map of FQN -> snippet keys that exercise that FQN.\n *\n * For a snippet to qualify, it must both:\n *\n * a) be current (i.e.: exist in the input assemblies)\n * b) have been analyzed (i.e.: exist in one of the translated tablets)\n *\n * Returns a map of fqns to a list of keys that represent snippets that include the fqn.\n */\nasync function availableSnippetsPerFqn(asms: readonly LoadedAssembly[], translationsTablet: LanguageTablet) {\n  const ret = new DefaultRecord<TranslatedSnippet>();\n\n  const originalsByKey = indexBy(await allTypeScriptSnippets(asms), snippetKey);\n\n  const translations = Object.keys(originalsByKey)\n    .map((key) => translationsTablet.tryGetSnippet(key))\n    .filter(isDefined);\n\n  for (const trans of translations) {\n    for (const fqn of trans.snippet.fqnsReferenced ?? []) {\n      ret.add(fqn, trans);\n    }\n  }\n\n  return { originalsByKey, translationsByFqn: ret.index };\n}\n\nfunction makeDict<A>(xs: Array<readonly [string, A]>): Record<string, A> {\n  const ret: Record<string, A> = {};\n  for (const [str, a] of xs) {\n    ret[str] = a;\n  }\n  return ret;\n}\n"]}