{"version":3,"file":"ast-utils.js","sourceRoot":"","sources":["../../src/typescript/ast-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { AstRenderer } from '../renderer';\n\nexport function stripCommentMarkers(comment: string, multiline: boolean) {\n  if (multiline) {\n    // The text *must* start with '/*' and end with '*/'.\n    // Strip leading '*' from every remaining line (first line because of '**',\n    // other lines because of continuations.\n    return comment\n      .substring(2, comment.length - 2)\n      .replace(/^[ \\t]+/g, '') // Strip all leading whitepace\n      .replace(/[ \\t]+$/g, '') // Strip all trailing whitepace\n      .replace(/^[ \\t]*\\*[ \\t]?/gm, ''); // Strip \"* \" from start of line\n  }\n  // The text *must* start with '//'\n  return comment.replace(/^[/]{2}[ \\t]?/gm, '');\n}\n\nexport function stringFromLiteral(expr: ts.Expression) {\n  if (ts.isStringLiteral(expr)) {\n    return expr.text;\n  }\n  return '???';\n}\n\n/**\n * All types of nodes that can be captured using `nodeOfType`, and the type of Node they map to\n */\nexport type CapturableNodes = {\n  [ts.SyntaxKind.ImportDeclaration]: ts.ImportDeclaration;\n  [ts.SyntaxKind.VariableDeclaration]: ts.VariableDeclaration;\n  [ts.SyntaxKind.ExternalModuleReference]: ts.ExternalModuleReference;\n  [ts.SyntaxKind.NamespaceImport]: ts.NamespaceImport;\n  [ts.SyntaxKind.NamedImports]: ts.NamedImports;\n  [ts.SyntaxKind.ImportSpecifier]: ts.ImportSpecifier;\n  [ts.SyntaxKind.StringLiteral]: ts.StringLiteral;\n};\n\nexport type AstMatcher<A> = (nodes?: ts.Node[]) => A | undefined;\n\n/**\n * Return AST children of the given node\n *\n * Difference with node.getChildren():\n *\n * - node.getChildren() must take a SourceFile (will fail if it doesn't get it)\n *   and returns a mix of abstract and concrete syntax nodes.\n * - This function function will ONLY return abstract syntax nodes.\n */\nexport function nodeChildren(node: ts.Node): ts.Node[] {\n  const ret = new Array<ts.Node>();\n  node.forEachChild((n) => {\n    ret.push(n);\n  });\n  return ret;\n}\n\n/**\n * Match a single node of a given type\n *\n * Capture name is first so that the IDE can detect eagerly that we're falling into\n * that overload and properly autocomplete the recognized node types from CapturableNodes.\n *\n * Looks like SyntaxList nodes appear in the printed AST, but they don't actually appear\n */\nexport function nodeOfType<A>(syntaxKind: ts.SyntaxKind, children?: AstMatcher<A>): AstMatcher<A>;\n// eslint-disable-next-line max-len\nexport function nodeOfType<S extends keyof CapturableNodes, N extends string, A>(\n  capture: N,\n  capturableNodeType: S,\n  children?: AstMatcher<A>,\n): AstMatcher<Omit<A, N> & { [key in N]: CapturableNodes[S] }>;\n// eslint-disable-next-line max-len\nexport function nodeOfType<S extends keyof CapturableNodes, N extends string, A>(\n  syntaxKindOrCaptureName: ts.SyntaxKind | N,\n  nodeTypeOrChildren?: S | AstMatcher<A>,\n  children?: AstMatcher<A>,\n): AstMatcher<A> | AstMatcher<A & { [key in N]: CapturableNodes[S] }> {\n  const capturing = typeof syntaxKindOrCaptureName === 'string'; // Determine which overload we're in (SyntaxKind is a number)\n\n  const realNext = (capturing ? children : (nodeTypeOrChildren as AstMatcher<A>)) ?? DONE;\n  const realCapture = capturing ? syntaxKindOrCaptureName : undefined;\n  const realSyntaxKind = capturing ? nodeTypeOrChildren : syntaxKindOrCaptureName;\n\n  return (nodes) => {\n    for (const node of nodes ?? []) {\n      if (node.kind === realSyntaxKind) {\n        const ret = realNext(nodeChildren(node));\n        if (!ret) {\n          continue;\n        }\n\n        if (realCapture) {\n          return Object.assign(ret, {\n            [realCapture]: node as CapturableNodes[S],\n          }) as any;\n        }\n        return ret;\n      }\n    }\n    return undefined;\n  };\n}\n\nexport function anyNode(): AstMatcher<Record<string, unknown>>;\nexport function anyNode<A>(children: AstMatcher<A>): AstMatcher<A>;\nexport function anyNode<A>(children?: AstMatcher<A>): AstMatcher<A> | AstMatcher<any> {\n  const realNext = children ?? DONE;\n  return (nodes) => {\n    for (const node of nodes ?? []) {\n      const m = realNext(nodeChildren(node));\n      if (m) {\n        return m;\n      }\n    }\n    return undefined;\n  };\n}\n\n// Does not capture deeper because how would we even represent that?\nexport function allOfType<S extends keyof CapturableNodes, N extends string, A>(\n  s: S,\n  name: N,\n  children?: AstMatcher<A>,\n): AstMatcher<{ [key in N]: Array<CapturableNodes[S]> }> {\n  type ArrayType = Array<CapturableNodes[S]>;\n  type ReturnType = { [key in N]: ArrayType };\n  const realNext = children ?? DONE;\n\n  return (nodes) => {\n    let ret: ReturnType | undefined;\n    for (const node of nodes ?? []) {\n      if (node.kind === s) {\n        if (realNext(nodeChildren(node))) {\n          if (!ret) {\n            ret = { [name]: new Array<CapturableNodes[S]>() } as ReturnType;\n          }\n          ret[name].push(node as any);\n        }\n      }\n    }\n    return ret;\n  };\n}\n\nexport const DONE: AstMatcher<Record<string, unknown>> = () => ({});\n\n/**\n * Run a matcher against a node and return (or invoke a callback with) the accumulated bindings\n */\nexport function matchAst<A>(node: ts.Node, matcher: AstMatcher<A>): A | undefined;\nexport function matchAst<A>(node: ts.Node, matcher: AstMatcher<A>, cb: (bindings: A) => void): boolean;\nexport function matchAst<A>(\n  node: ts.Node,\n  matcher: AstMatcher<A>,\n  cb?: (bindings: A) => void,\n): boolean | A | undefined {\n  const matched = matcher([node]);\n  if (cb) {\n    if (matched) {\n      cb(matched);\n    }\n    return !!matched;\n  }\n  return matched;\n}\n\n/**\n * Count the newlines in a given piece of string that aren't in comment blocks\n */\nexport function countNakedNewlines(str: string) {\n  let ret = 0;\n  for (const s of scanText(str, 0, str.length).filter((r) => r.type === 'other' || r.type === 'blockcomment')) {\n    if (s.type === 'other') {\n      // Count newlines in non-comments\n      for (let i = s.pos; i < s.end; i++) {\n        if (str[i] === '\\n') {\n          ret++;\n        }\n      }\n    } else {\n      // Discount newlines at the end of block comments\n      if (s.hasTrailingNewLine) {\n        ret--;\n      }\n    }\n  }\n  return ret;\n}\n\nexport function repeatNewlines(str: string) {\n  return '\\n'.repeat(Math.min(2, countNakedNewlines(str)));\n}\n\nconst WHITESPACE = [' ', '\\t', '\\r', '\\n'];\n\n/**\n * Extract single-line and multi-line comments from the given string\n *\n * Rewritten because I can't get ts.getLeadingComments and ts.getTrailingComments to do what I want.\n */\nexport function extractComments(text: string, start: number): ts.CommentRange[] {\n  return scanText(text, start)\n    .filter((s) => s.type === 'blockcomment' || s.type === 'linecomment')\n    .map(commentRangeFromTextRange);\n}\n\nexport function commentRangeFromTextRange(rng: TextRange): ts.CommentRange {\n  return {\n    kind: rng.type === 'blockcomment' ? ts.SyntaxKind.MultiLineCommentTrivia : ts.SyntaxKind.SingleLineCommentTrivia,\n    pos: rng.pos,\n    end: rng.end,\n    hasTrailingNewLine: rng.type !== 'blockcomment' && rng.hasTrailingNewLine,\n  };\n}\n\ninterface TextRange {\n  pos: number;\n  end: number;\n  type: 'linecomment' | 'blockcomment' | 'other' | 'directive';\n  hasTrailingNewLine: boolean;\n}\n\n/**\n * Extract spans of comments and non-comments out of the string\n *\n * Stop at 'end' when given, or the first non-whitespace character in a\n * non-comment if not given.\n */\nexport function scanText(text: string, start: number, end?: number): TextRange[] {\n  const ret: TextRange[] = [];\n\n  let pos = start;\n  const stopAtCode = end === undefined;\n  if (end === undefined) {\n    end = text.length;\n  }\n  while (pos < end) {\n    const ch = text[pos];\n\n    if (WHITESPACE.includes(ch)) {\n      pos++;\n      continue;\n    }\n\n    if (ch === '/' && text[pos + 1] === '/') {\n      accumulateTextBlock();\n      scanSinglelineComment();\n      continue;\n    }\n\n    if (ch === '/' && text[pos + 1] === '*') {\n      accumulateTextBlock();\n      scanMultilineComment();\n      continue;\n    }\n\n    // Non-whitespace, non-comment, must be regular token. End if we're not scanning\n    // to a particular location, otherwise continue.\n    if (stopAtCode) {\n      break;\n    }\n\n    pos++;\n  }\n\n  accumulateTextBlock();\n\n  return ret;\n\n  function scanMultilineComment() {\n    const endOfComment = findNext('*/', pos + 2);\n    ret.push({\n      type: 'blockcomment',\n      hasTrailingNewLine: ['\\n', '\\r'].includes(text[endOfComment + 2]),\n      pos,\n      end: endOfComment + 2,\n    });\n    pos = endOfComment + 2;\n    start = pos;\n  }\n\n  function scanSinglelineComment() {\n    const nl = Math.min(findNext('\\r', pos + 2), findNext('\\n', pos + 2));\n\n    if (text[pos + 2] === '/') {\n      // Special /// comment\n      ret.push({\n        type: 'directive',\n        hasTrailingNewLine: true,\n        pos: pos + 1,\n        end: nl,\n      });\n    } else {\n      // Regular // comment\n      ret.push({\n        type: 'linecomment',\n        hasTrailingNewLine: true,\n        pos,\n        end: nl,\n      });\n    }\n    pos = nl + 1;\n    start = pos;\n  }\n\n  function accumulateTextBlock() {\n    if (pos - start > 0) {\n      ret.push({\n        type: 'other',\n        hasTrailingNewLine: false,\n        pos: start,\n        end: pos,\n      });\n      start = pos;\n    }\n  }\n\n  function findNext(sub: string, startPos: number) {\n    const f = text.indexOf(sub, startPos);\n    if (f === -1) {\n      return text.length;\n    }\n    return f;\n  }\n}\n\nconst VOID_SHOW_KEYWORD = 'show';\n\nexport function extractMaskingVoidExpression(node: ts.Node): ts.VoidExpression | undefined {\n  const expr = extractVoidExpression(node);\n  if (!expr) {\n    return undefined;\n  }\n  if (ts.isStringLiteral(expr.expression) && expr.expression.text === VOID_SHOW_KEYWORD) {\n    return undefined;\n  }\n  return expr;\n}\n\nexport function extractShowingVoidExpression(node: ts.Node): ts.VoidExpression | undefined {\n  const expr = extractVoidExpression(node);\n  if (!expr) {\n    return undefined;\n  }\n  if (ts.isStringLiteral(expr.expression) && expr.expression.text === VOID_SHOW_KEYWORD) {\n    return expr;\n  }\n  return undefined;\n}\n\n/**\n * Return the string argument to a void expression if it exists\n */\nexport function voidExpressionString(node: ts.VoidExpression): string | undefined {\n  if (ts.isStringLiteral(node.expression)) {\n    return node.expression.text;\n  }\n  return undefined;\n}\n\n/**\n * We use void directives as pragmas. Extract the void directives here\n */\nexport function extractVoidExpression(node: ts.Node): ts.VoidExpression | undefined {\n  if (ts.isVoidExpression(node)) {\n    return node;\n  }\n  if (ts.isExpressionStatement(node)) {\n    return extractVoidExpression(node.expression);\n  }\n  if (ts.isParenthesizedExpression(node)) {\n    return extractVoidExpression(node.expression);\n  }\n  if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n    return extractVoidExpression(node.left);\n  }\n  return undefined;\n}\n\nexport function quoteStringLiteral(x: string) {\n  return x.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n}\n\nexport function visibility(\n  x:\n    | ts.AccessorDeclaration\n    | ts.FunctionLikeDeclaration\n    | ts.GetAccessorDeclaration\n    | ts.PropertyDeclaration\n    | ts.PropertySignature\n    | ts.SetAccessorDeclaration,\n) {\n  const flags = ts.getCombinedModifierFlags(x);\n  if (flags & ts.ModifierFlags.Private) {\n    return 'private';\n  }\n  if (flags & ts.ModifierFlags.Protected) {\n    return 'protected';\n  }\n  return 'public';\n}\n\nfunction hasFlag<T extends ts.Declaration>(flag: ts.ModifierFlags) {\n  return (x: T) => {\n    const flags = ts.getCombinedModifierFlags(x);\n    return (flags & flag) !== 0;\n  };\n}\n\nexport const isReadOnly = hasFlag<\n  | ts.AccessorDeclaration\n  | ts.FunctionLikeDeclaration\n  | ts.GetAccessorDeclaration\n  | ts.PropertyDeclaration\n  | ts.PropertySignature\n  | ts.SetAccessorDeclaration\n>(ts.ModifierFlags.Readonly);\nexport const isExported = hasFlag(ts.ModifierFlags.Export);\nexport const isPrivate = hasFlag(ts.ModifierFlags.Private);\nexport const isProtected = hasFlag(ts.ModifierFlags.Private);\nexport function isPublic(x: ts.Declaration) {\n  // In TypeScript, anything not explicitly marked private or protected is public.\n  return !isPrivate(x) && !isProtected(x);\n}\nexport const isStatic = hasFlag(ts.ModifierFlags.Static);\n\n/**\n * Return the super() call from a method body if found\n */\nexport function findSuperCall(\n  node: ts.Block | ts.Expression | undefined,\n  renderer: AstRenderer<any>,\n): ts.SuperCall | undefined {\n  if (node === undefined) {\n    return undefined;\n  }\n  if (ts.isCallExpression(node)) {\n    if (renderer.textOf(node.expression) === 'super') {\n      return node as unknown as ts.SuperCall;\n    }\n  }\n  if (ts.isExpressionStatement(node)) {\n    return findSuperCall(node.expression, renderer);\n  }\n  if (ts.isBlock(node)) {\n    for (const statement of node.statements) {\n      if (ts.isExpressionStatement(statement)) {\n        const s = findSuperCall(statement.expression, renderer);\n        if (s) {\n          return s;\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Return the names of all private property declarations\n */\nexport function privatePropertyNames(members: readonly ts.ClassElement[], renderer: AstRenderer<any>): string[] {\n  const props = members.filter((m) => ts.isPropertyDeclaration(m)) as ts.PropertyDeclaration[];\n  return props.filter((m) => visibility(m) === 'private').map((m) => renderer.textOf(m.name));\n}\n\nexport function findEnclosingClassDeclaration(node: ts.Node): ts.ClassDeclaration | undefined {\n  while (node && !ts.isClassDeclaration(node)) {\n    node = node.parent;\n  }\n  return node;\n}\n"]}