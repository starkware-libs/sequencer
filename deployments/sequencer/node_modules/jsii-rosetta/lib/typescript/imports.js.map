{"version":3,"file":"imports.js","sourceRoot":"","sources":["../../src/typescript/imports.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { allOfType, matchAst, nodeOfType, stringFromLiteral } from './ast-utils';\nimport { JsiiSymbol, parentSymbol, lookupJsiiSymbolFromNode } from '../jsii/jsii-utils';\nimport { AstRenderer } from '../renderer';\nimport { SubmoduleReferenceMap } from '../submodule-reference';\nimport { fmap } from '../util';\n\n/**\n * Our own unification of import statements\n */\nexport interface ImportStatement {\n  readonly node: ts.Node;\n  readonly packageName: string;\n  readonly imports: FullImport | SelectiveImport;\n  readonly moduleSymbol?: JsiiSymbol;\n}\n\nexport type FullImport = {\n  readonly import: 'full';\n  /**\n   * The name of the namespace prefix in the source code. Used to strip the\n   * prefix in certain languages (e.g: Java).\n   */\n  readonly sourceName: string;\n  /**\n   * The name under which this module is imported. Undefined if the module is\n   * not aliased (could be the case for namepsace/submodule imports).\n   */\n  readonly alias?: string;\n};\n\nexport type SelectiveImport = {\n  readonly import: 'selective';\n  readonly elements: ImportBinding[];\n};\n\nexport interface ImportBinding {\n  readonly sourceName: string;\n\n  readonly alias?: string;\n\n  /**\n   * The JSII Symbol the import refers to\n   */\n  readonly importedSymbol?: JsiiSymbol;\n}\n\nexport function analyzeImportEquals(node: ts.ImportEqualsDeclaration, context: AstRenderer<any>): ImportStatement {\n  let moduleName = '???';\n  matchAst(node.moduleReference, nodeOfType('ref', ts.SyntaxKind.ExternalModuleReference), (bindings) => {\n    moduleName = stringFromLiteral(bindings.ref.expression);\n  });\n\n  const sourceName = context.textOf(node.name);\n\n  return {\n    node,\n    packageName: moduleName,\n    moduleSymbol: lookupJsiiSymbolFromNode(context.typeChecker, node.name),\n    imports: { import: 'full', alias: sourceName, sourceName },\n  };\n}\n\nexport function analyzeImportDeclaration(\n  node: ts.ImportDeclaration | ts.JSDocImportTag,\n  context: AstRenderer<any>,\n): ImportStatement;\nexport function analyzeImportDeclaration(\n  node: ts.ImportDeclaration | ts.JSDocImportTag,\n  context: AstRenderer<any>,\n  submoduleReferences: SubmoduleReferenceMap,\n): ImportStatement[];\nexport function analyzeImportDeclaration(\n  node: ts.ImportDeclaration | ts.JSDocImportTag,\n  context: AstRenderer<any>,\n  submoduleReferences?: SubmoduleReferenceMap,\n): ImportStatement | ImportStatement[] {\n  const packageName = stringFromLiteral(node.moduleSpecifier);\n\n  const starBindings = matchAst(\n    node,\n    nodeOfType(\n      ts.SyntaxKind.ImportDeclaration,\n      nodeOfType(ts.SyntaxKind.ImportClause, nodeOfType('namespace', ts.SyntaxKind.NamespaceImport)),\n    ),\n  );\n\n  if (starBindings) {\n    const sourceName = context.textOf(starBindings.namespace.name);\n    const bareImport: ImportStatement = {\n      node,\n      packageName,\n      moduleSymbol: lookupJsiiSymbolFromNode(context.typeChecker, starBindings.namespace.name),\n      imports: {\n        import: 'full',\n        alias: sourceName,\n        sourceName,\n      },\n    };\n    if (submoduleReferences == null) {\n      return bareImport;\n    }\n\n    const rootSymbol = context.typeChecker.getSymbolAtLocation(starBindings.namespace.name);\n    const refs = rootSymbol && Array.from(submoduleReferences.values()).filter((ref) => ref.root === rootSymbol);\n    // No submodule reference, or only 1 where the path is empty (this is used to signal the use of the bare import so it's not erased)\n    if (refs == null || refs.length === 0 || (refs.length === 1 && refs[0].path.length === 0)) {\n      return [bareImport];\n    }\n\n    return refs.flatMap(({ lastNode, path, root, submoduleChain }, idx, array): ImportStatement[] => {\n      if (\n        array\n          .slice(0, idx)\n          .some(\n            (other) => other.root === root && context.textOf(other.submoduleChain) === context.textOf(submoduleChain),\n          )\n      ) {\n        // This would be a duplicate, so we're skipping it\n        return [];\n      }\n\n      const moduleSymbol = lookupJsiiSymbolFromNode(context.typeChecker, lastNode);\n      return [\n        {\n          node,\n          packageName: [packageName, ...path.map((n) => context.textOf(n))].join('/'),\n          moduleSymbol,\n          imports: {\n            import: 'full',\n            alias: undefined, // No alias exists in the source text for this...\n            sourceName: context.textOf(submoduleChain),\n          },\n        },\n      ];\n    });\n  }\n\n  const namedBindings = matchAst(\n    node,\n    nodeOfType(\n      ts.SyntaxKind.ImportDeclaration,\n      nodeOfType(\n        ts.SyntaxKind.ImportClause,\n        nodeOfType(ts.SyntaxKind.NamedImports, allOfType(ts.SyntaxKind.ImportSpecifier, 'specifiers')),\n      ),\n    ),\n  );\n\n  const extraImports = new Array<ImportStatement>();\n  const elements: ImportBinding[] = (namedBindings?.specifiers ?? []).flatMap(\n    ({ name, propertyName }): ImportBinding[] => {\n      // regular import { name }\n      // renamed import { propertyName as name }\n      const directBinding = {\n        sourceName: context.textOf(propertyName ?? name),\n        alias: propertyName && context.textOf(name),\n        importedSymbol: lookupJsiiSymbolFromNode(context.typeChecker, propertyName ?? name),\n      } as const;\n\n      if (submoduleReferences != null) {\n        const symbol = context.typeChecker.getSymbolAtLocation(name);\n        let omitDirectBinding = false;\n        for (const match of Array.from(submoduleReferences.values()).filter((ref) => ref.root === symbol)) {\n          if (match.path.length === 0) {\n            // This is a namespace binding that is used as-is (not via a transitive path). It needs to be preserved.\n            omitDirectBinding = false;\n            continue;\n          }\n          const subPackageName = [packageName, ...match.path.map((n) => n.getText(n.getSourceFile()))].join('/');\n          const importedSymbol = lookupJsiiSymbolFromNode(context.typeChecker, match.lastNode);\n          const moduleSymbol = fmap(importedSymbol, parentSymbol);\n          const importStatement =\n            extraImports.find((stmt) => {\n              if (moduleSymbol != null) {\n                return stmt.moduleSymbol === moduleSymbol;\n              }\n              return stmt.packageName === subPackageName;\n            }) ??\n            extraImports[\n              extraImports.push({\n                moduleSymbol,\n                node: match.lastNode,\n                packageName: subPackageName,\n                imports: { import: 'selective', elements: [] },\n              }) - 1\n            ];\n\n          (importStatement.imports as SelectiveImport).elements.push({\n            sourceName: context.textOf(match.submoduleChain),\n            importedSymbol,\n          });\n        }\n        if (omitDirectBinding) {\n          return [];\n        }\n      }\n\n      return [directBinding];\n    },\n  );\n\n  if (submoduleReferences == null) {\n    return {\n      node,\n      packageName,\n      imports: { import: 'selective', elements },\n      moduleSymbol: fmap(elements?.[0]?.importedSymbol, parentSymbol),\n    };\n  }\n\n  return [\n    {\n      node,\n      packageName,\n      imports: { import: 'selective', elements },\n      moduleSymbol: fmap(elements?.[0]?.importedSymbol, parentSymbol),\n    },\n    ...extraImports,\n  ];\n}\n"]}