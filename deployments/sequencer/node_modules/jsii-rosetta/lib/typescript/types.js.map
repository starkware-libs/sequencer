{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/typescript/types.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { hasAllFlags, hasAnyFlag, resolveEnumLiteral, resolvedSymbolAtLocation } from '../jsii/jsii-utils';\nimport { isDefined } from '../util';\n\n/**\n * Return the first non-undefined type from a union\n */\nexport function firstTypeInUnion(typeChecker: ts.TypeChecker, type: ts.Type): ts.Type {\n  type = typeChecker.getNonNullableType(type);\n\n  if (!type.isUnion()) {\n    return type;\n  }\n\n  return type.types[0];\n}\n\nexport type BuiltInType = 'any' | 'boolean' | 'number' | 'string' | 'void';\nexport function builtInTypeName(type: ts.Type): BuiltInType | undefined {\n  if (hasAnyFlag(type.flags, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n    return 'any';\n  }\n  if (hasAnyFlag(type.flags, ts.TypeFlags.BooleanLike)) {\n    return 'boolean';\n  }\n  if (hasAnyFlag(type.flags, ts.TypeFlags.NumberLike)) {\n    return 'number';\n  }\n  if (hasAnyFlag(type.flags, ts.TypeFlags.StringLike)) {\n    return 'string';\n  }\n  return undefined;\n}\n\nexport function renderType(type: ts.Type): string {\n  if (type.isClassOrInterface()) {\n    return type.symbol.name;\n  }\n  if (type.isLiteral()) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return `${type.value}`;\n  }\n  return renderTypeFlags(type);\n}\n\nexport function parameterAcceptsUndefined(param: ts.ParameterDeclaration, type?: ts.Type): boolean {\n  if (param.initializer !== undefined) {\n    return true;\n  }\n  if (param.questionToken !== undefined) {\n    return true;\n  }\n  if (type) {\n    return typeContainsUndefined(type);\n  }\n  return false;\n}\n\n/**\n * This is a simplified check that should be good enough for most purposes\n */\nexport function typeContainsUndefined(type: ts.Type): boolean {\n  if (type.getFlags() & ts.TypeFlags.Undefined) {\n    return true;\n  }\n  if (type.isUnion()) {\n    return type.types.some(typeContainsUndefined);\n  }\n  return false;\n}\n\nexport function renderTypeFlags(type: ts.Type): string {\n  return renderFlags(type.flags, ts.TypeFlags);\n}\n\nexport type MapAnalysis = { result: 'nonMap' } | { result: 'map'; elementType: ts.Type | undefined };\n\n/**\n * If this is a map type, return the type mapped *to* (key must always be `string` anyway).\n */\nexport function mapElementType(type: ts.Type, typeChecker: ts.TypeChecker): MapAnalysis {\n  if (hasAnyFlag(type.flags, ts.TypeFlags.Object) && type.symbol) {\n    if (type.symbol.name === '__type') {\n      // Declared map type: {[k: string]: A}\n      return { result: 'map', elementType: type.getStringIndexType() };\n    }\n\n    if (type.symbol.name === '__object') {\n      // Derived map type from object literal: typeof({ k: \"value\" })\n      // For every property, get the node that created it (PropertyAssignment), and get the type of the initializer of that node\n      const initializerTypes = type.getProperties().map((p) => {\n        const expression = p.valueDeclaration ?? p.declarations![0];\n        return typeOfObjectLiteralProperty(typeChecker, expression);\n      });\n      return {\n        result: 'map',\n        elementType: typeIfSame([...initializerTypes, type.getStringIndexType()].filter(isDefined)),\n      };\n    }\n  }\n\n  return { result: 'nonMap' };\n}\n\n/**\n * Try to infer the map element type from the properties if they're all the same\n */\nexport function inferMapElementType(\n  elements: readonly ts.ObjectLiteralElementLike[],\n  typeChecker: ts.TypeChecker,\n): ts.Type | undefined {\n  const types = elements.map((e) => typeOfObjectLiteralProperty(typeChecker, e)).filter(isDefined);\n\n  return types.every((t) => isSameType(types[0], t)) ? types[0] : undefined;\n}\n\nfunction typeOfObjectLiteralProperty(typeChecker: ts.TypeChecker, el: ts.Node): ts.Type | undefined {\n  if (ts.isPropertyAssignment(el)) {\n    return typeOfExpression(typeChecker, el.initializer);\n  }\n  if (ts.isShorthandPropertyAssignment(el)) {\n    return typeOfExpression(typeChecker, el.name);\n  }\n  return undefined;\n}\n\nfunction isSameType(a: ts.Type, b: ts.Type) {\n  return a.flags === b.flags && a.symbol?.name === b.symbol?.name;\n}\n\nfunction typeIfSame(types: Array<ts.Type | undefined>): ts.Type | undefined {\n  const ttypes = types.filter(isDefined);\n  if (types.length === 0) {\n    return undefined;\n  }\n\n  return ttypes.every((t) => isSameType(ttypes[0], t)) ? ttypes[0] : undefined;\n}\n\n/**\n * If this is an array type, return the element type of the array\n */\nexport function arrayElementType(type: ts.Type): ts.Type | undefined {\n  if (type.symbol && type.symbol.name === 'Array') {\n    const tr = type as ts.TypeReference;\n    return tr.aliasTypeArguments && tr.aliasTypeArguments[0];\n  }\n  return undefined;\n}\n\nexport function typeOfExpression(typeChecker: ts.TypeChecker, node: ts.Expression) {\n  const t = typeChecker.getContextualType(node) ?? typeChecker.getTypeAtLocation(node);\n  return resolveEnumLiteral(typeChecker, t);\n}\n\n/**\n * Infer type of expression by the argument it is assigned to\n *\n * If the type of the expression can include undefined (if the value is\n * optional), `undefined` will be removed from the union.\n *\n * (Will return undefined for object literals not unified with a declared type)\n */\nexport function inferredTypeOfExpression(typeChecker: ts.TypeChecker, node: ts.Expression) {\n  const type = typeChecker.getContextualType(node);\n  return type ? typeChecker.getNonNullableType(type) : undefined;\n}\n\nexport function isNumber(x: any): x is number {\n  return typeof x === 'number';\n}\n\nexport function isEnumAccess(typeChecker: ts.TypeChecker, access: ts.PropertyAccessExpression) {\n  const symbol = resolvedSymbolAtLocation(typeChecker, access.expression);\n  return symbol ? hasAnyFlag(symbol.flags, ts.SymbolFlags.Enum) : false;\n}\n\nexport function isStaticReadonlyAccess(typeChecker: ts.TypeChecker, access: ts.PropertyAccessExpression) {\n  const symbol = resolvedSymbolAtLocation(typeChecker, access);\n  const decl = symbol?.getDeclarations();\n  if (decl && decl[0] && ts.isPropertyDeclaration(decl[0])) {\n    const flags = ts.getCombinedModifierFlags(decl[0]);\n    return hasAllFlags(flags, ts.ModifierFlags.Readonly | ts.ModifierFlags.Static);\n  }\n  return false;\n}\n\nexport function renderFlags(flags: number | undefined, flagObject: Record<string, number | string>) {\n  if (flags === undefined) {\n    return '';\n  }\n\n  return Object.values(flagObject)\n    .filter(isNumber)\n    .filter((f) => hasAllFlags(flags, f))\n    .map((f) => flagObject[f])\n    .join(',');\n}\n\nexport function determineReturnType(typeChecker: ts.TypeChecker, node: ts.SignatureDeclaration): ts.Type | undefined {\n  const signature = typeChecker.getSignatureFromDeclaration(node);\n  if (!signature) {\n    return undefined;\n  }\n  return typeChecker.getReturnTypeOfSignature(signature);\n}\n"]}