{"version":3,"file":"visible-spans.js","sourceRoot":"","sources":["../../src/typescript/visible-spans.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { Span } from '../o-tree';\n\n/**\n * A class representing a set of non-overlapping Spans.\n */\nexport class Spans {\n  /**\n   * Derive visible spans from marked source (`/// !show` and `/// !hide` directives).\n   */\n  public static visibleSpansFromSource(source: string) {\n    return new Spans(calculateMarkedSpans(source).filter((s) => s.visible));\n  }\n\n  public constructor(private readonly _spans: Span[]) {\n    _spans.sort((a, b) => a.start - b.start);\n\n    // Merge adjacent spans\n    let i = 0;\n    while (i < this._spans.length - 1) {\n      const current = this._spans[i];\n      const next = this._spans[i + 1];\n\n      if (current.end === next.start) {\n        // Replace these two with a new, merged one\n        this._spans.splice(i, 2, {\n          start: current.start,\n          end: next.end,\n        });\n      } else {\n        // Else advance\n        i++;\n      }\n    }\n  }\n\n  public get spans(): readonly Span[] {\n    return this._spans;\n  }\n\n  /**\n   * Whether another span is fully contained within this set of spans\n   */\n  public fullyContainsSpan(span: Span) {\n    const candidate = this.findSpan(span.start);\n    return !!candidate && spanInside(span, candidate);\n  }\n\n  public containsPosition(pos: number) {\n    const candidate = this.findSpan(pos);\n    return !!candidate && spanContains(candidate, pos);\n  }\n\n  /**\n   * Return whether the START of the given node is visible\n   *\n   * For nodes that potentially span many lines (like class declarations)\n   * this will check the first line.\n   */\n  public containsStartOfNode(node: ts.Node) {\n    return this.containsPosition(node.getStart());\n  }\n\n  /**\n   * Find the span that would contain the given position, if any\n   *\n   * Returns the highest span s.t. span.start <= position. Uses the fact that\n   * spans are non-overlapping.\n   */\n  private findSpan(position: number): Span | undefined {\n    // For now, using linear search as the amount of spans is rather trivial.\n    // Change to binary search if this ever becomes an issue\n    if (this.spans.length === 0 || position < this._spans[0].start) {\n      return undefined;\n    }\n\n    let candidate = this._spans[0];\n    let i = 1;\n    while (i < this.spans.length && this.spans[i].start <= position) {\n      candidate = this._spans[i];\n      i++;\n    }\n    return candidate;\n  }\n}\n\nexport function trimCompleteSourceToVisible(source: string): string {\n  const spans = Spans.visibleSpansFromSource(source);\n\n  return spans.spans\n    .map((span) => source.substring(span.start, span.end))\n    .join('')\n    .trimRight();\n}\n\nexport interface MarkedSpan {\n  start: number;\n  end: number;\n  visible: boolean;\n}\n\nfunction calculateMarkedSpans(source: string): MarkedSpan[] {\n  const regEx = /^[ \\t]*[/]{3}[ \\t]*(!(?:show|hide))[ \\t]*$/gm;\n\n  const ret = new Array<MarkedSpan>();\n  let match;\n  let spanStart;\n  let visible = true;\n  while ((match = regEx.exec(source)) != null) {\n    const directiveStart = match.index;\n    const directive = match[1].trim();\n    if (['!hide', '!show'].includes(directive)) {\n      const isShow = directive === '!show';\n      if (spanStart === undefined) {\n        // Add a span at the start which is the reverse of the actual first directive\n        ret.push({ start: 0, end: directiveStart, visible: !isShow });\n      } else {\n        // Else add a span for the current directive\n        ret.push({ start: spanStart, end: directiveStart, visible });\n      }\n      visible = isShow;\n\n      // A directive eats its trailing newline.\n      spanStart = match.index + match[0].length + 1;\n    }\n  }\n\n  // Add the remainder under the last visibility\n  ret.push({ start: spanStart ?? 0, end: source.length, visible });\n\n  // Filter empty spans and return\n  return ret.filter((s) => s.start < s.end);\n}\n\n/**\n * Whether span a is fully inside span b\n */\nexport function spanInside(a: Span, b: Span) {\n  return b.start <= a.start && a.end <= b.end;\n}\n\nexport function spanContains(a: Span, position: number) {\n  return a.start <= position && position < a.end;\n}\n"]}