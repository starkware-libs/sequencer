{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fs } from 'node:fs';\nimport * as ts from 'typescript';\n\nimport { RosettaDiagnostic } from './translate';\n\nexport function startsWithUppercase(x: string): boolean {\n  return /^[A-Z]/.exec(x) != null;\n}\n\nexport interface File {\n  readonly contents: string;\n  readonly fileName: string;\n}\n\nexport function printDiagnostics(diags: readonly RosettaDiagnostic[], stream: NodeJS.WritableStream, colors: boolean) {\n  // Don't print too much, at some point it just clogs up the log\n  const maxDiags = 50;\n\n  for (const diag of diags.slice(0, maxDiags)) {\n    stream.write(colors ? diag.formattedMessage : stripColorCodes(diag.formattedMessage));\n  }\n\n  if (diags.length > maxDiags) {\n    stream.write(`(...and ${diags.length - maxDiags} more diagnostics not shown)`);\n  }\n}\n\nexport function formatList(xs: string[], n = 5) {\n  const tooMany = xs.length - n;\n\n  return tooMany > 0 ? `${xs.slice(0, n).join(', ')} (and ${tooMany} more)` : xs.join(', ');\n}\n\nexport const StrictBrand = 'jsii.strict';\ninterface MaybeStrictDiagnostic {\n  readonly [StrictBrand]?: boolean;\n}\n\n/**\n * Annotate a diagnostic with a magic property to indicate it's a strict diagnostic\n */\nexport function annotateStrictDiagnostic(diag: ts.Diagnostic) {\n  Object.defineProperty(diag, StrictBrand, {\n    configurable: false,\n    enumerable: true,\n    value: true,\n    writable: false,\n  });\n}\n\n/**\n * Return whether or not the given diagnostic was annotated with the magic strict property\n */\nexport function hasStrictBranding(diag: ts.Diagnostic) {\n  return !!(diag as MaybeStrictDiagnostic)[StrictBrand];\n}\n\n/**\n * Chunk an array of elements into approximately equal groups\n */\nexport function divideEvenly<A>(groups: number, xs: A[]): A[][] {\n  const chunkSize = Math.ceil(xs.length / groups);\n  const ret: A[][] = [];\n\n  for (let i = 0; i < groups; i++) {\n    ret.push(xs.slice(i * chunkSize, (i + 1) * chunkSize));\n  }\n\n  return ret;\n}\n\nexport function flat<A>(xs: A[][]): A[] {\n  return Array.prototype.concat.apply([], xs);\n}\n\n/**\n * Partition a list in twain using a predicate\n *\n * Returns [elements-matching-predicate, elements-not-matching-predicate];\n */\nexport function partition<A>(xs: A[], pred: (x: A) => boolean): [A[], A[]] {\n  const truthy = new Array<A>();\n  const falsy = new Array<A>();\n\n  for (const x of xs) {\n    if (pred(x)) {\n      truthy.push(x);\n    } else {\n      falsy.push(x);\n    }\n  }\n\n  return [truthy, falsy];\n}\n\nexport function setExtend<A>(xs: Set<A>, els: Iterable<A>) {\n  for (const el of els) {\n    xs.add(el);\n  }\n}\n\nexport function mkDict<A extends string, B>(xs: Array<readonly [A, B]>): Record<A, B> {\n  const ret: any = {};\n  for (const [key, value] of xs) {\n    ret[key] = value;\n  }\n  return ret;\n}\n\n/**\n * Apply a function to a value, as long as it's not `undefined`\n *\n * This is a companion helper to TypeScript's nice `??` and `?.` nullish\n * operators. Those operators are helpful if you're calling methods:\n *\n *    object?.method()  <- returns 'undefined' if 'object' is nullish\n *\n * But are no help when you want to use free functions:\n *\n *    func(object)      <- but what if 'object' is nullish and func\n *                         expects it not to be?\n *\n * Yes you can write `object ? func(object) : undefined` but the trailing\n * `: undefined` clutters your code. Instead, you write:\n *\n *    fmap(object, func)\n *\n * The name `fmap` is taken from Haskell: it's a \"Functor-map\" (although\n * only for the `Maybe` Functor).\n */\nexport function fmap<A, B>(value: NonNullable<A>, fn: (x: NonNullable<A>) => B): B;\nexport function fmap<A, B>(value: undefined | null, fn: (x: NonNullable<A>) => B): undefined;\nexport function fmap<A, B>(value: A | undefined | null, fn: (x: A) => B): B | undefined;\nexport function fmap<A, B>(value: A, fn: (x: A) => B): B | undefined {\n  if (value == null) {\n    return undefined;\n  }\n  return fn(value);\n}\n\nexport function mapValues<A, B>(xs: Record<string, A>, fn: (x: A) => B): Record<string, B> {\n  const ret: Record<string, B> = {};\n  for (const [key, value] of Object.entries(xs)) {\n    ret[key] = fn(value);\n  }\n  return ret;\n}\n\n/**\n * Sort an array by a key function.\n *\n * Instead of having to write your own comparators for your types any time you\n * want to sort, you supply a function that maps a value to a compound sort key\n * consisting of numbers or strings. The sorting will happen by that sort key\n * instead.\n */\nexport function sortBy<A>(xs: A[], keyFn: (x: A) => Array<string | number>) {\n  return xs.sort((a, b) => {\n    const aKey = keyFn(a);\n    const bKey = keyFn(b);\n\n    for (let i = 0; i < Math.min(aKey.length, bKey.length); i++) {\n      // Compare aKey[i] to bKey[i]\n      const av = aKey[i];\n      const bv = bKey[i];\n\n      if (av === bv) {\n        continue;\n      }\n\n      if (typeof av !== typeof bv) {\n        throw new Error(`Type of sort key ${JSON.stringify(aKey)} not same as ${JSON.stringify(bKey)}`);\n      }\n\n      if (typeof av === 'number' && typeof bv === 'number') {\n        return av - bv;\n      }\n\n      if (typeof av === 'string' && typeof bv === 'string') {\n        return av.localeCompare(bv);\n      }\n    }\n\n    return aKey.length - bKey.length;\n  });\n}\n\n/**\n * Group elements by a key\n *\n * Supply a function that maps each element to a key string.\n *\n * Returns a map of the key to the list of elements that map to that key.\n */\nexport function groupBy<A>(xs: A[], keyFn: (x: A) => string): Record<string, A[]> {\n  const ret: Record<string, A[]> = {};\n  for (const x of xs) {\n    const key = keyFn(x);\n    if (ret[key]) {\n      ret[key].push(x);\n    } else {\n      ret[key] = [x];\n    }\n  }\n  return ret;\n}\n\nexport function isDefined<A>(x: A): x is NonNullable<A> {\n  return x !== undefined;\n}\n\nexport function indexBy<A>(xs: A[], fn: (x: A) => string): Record<string, A> {\n  return mkDict(xs.map((x) => [fn(x), x] as const));\n}\n\nexport type Mutable<T> = { -readonly [P in keyof T]: Mutable<T[P]> };\n\nexport function commentToken(language: string) {\n  // This is future-proofed a bit, but don't read too much in this...\n  switch (language) {\n    case 'python':\n    case 'ruby':\n      return '#';\n    case 'csharp':\n    case 'java':\n    case 'go':\n    default:\n      return '//';\n  }\n}\n\nexport async function pathExists(path: string): Promise<boolean> {\n  try {\n    await fs.stat(path);\n    return true;\n  } catch (err: any) {\n    if (err.code === 'ENOENT') {\n      return false;\n    }\n    if (!err.stack) {\n      Error.captureStackTrace(err);\n    }\n    throw err;\n  }\n}\n\n// Copy/pasted from the 'ansi-regex' package to avoid taking a dependency for this one line that will never change\nconst ANSI_PATTERN = new RegExp(\n  [\n    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n    '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n  ].join('|'),\n  'g',\n);\n\nfunction stripColorCodes(x: string) {\n  return x.replace(ANSI_PATTERN, '');\n}\n"]}