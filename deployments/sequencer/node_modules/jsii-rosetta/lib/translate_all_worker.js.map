{"version":3,"file":"translate_all_worker.js","sourceRoot":"","sources":["../src/translate_all_worker.ts"],"names":[],"mappings":";;AAkCA,gEAuBC;AAzDD;;GAEG;AACH,yCAAyC;AAKzC,2CAAmF;AAcnF,SAAS,cAAc,CAAC,OAA8B;IACpD,MAAM,MAAM,GAAG,0BAA0B,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,0BAA0B,CAAC,CAAC;IAEhG,OAAO;QACL,iBAAiB,EAAE,MAAM,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;QAClE,WAAW,EAAE,MAAM,CAAC,WAAW;KAChC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,SAAgB,0BAA0B,CACxC,QAA6B,EAC7B,0BAAmC;IAEnC,MAAM,kBAAkB,GAAG,IAAI,KAAK,EAAqB,CAAC;IAE1D,MAAM,QAAQ,GAAG,IAAI,KAAK,EAAqB,CAAC;IAEhD,MAAM,UAAU,GAAG,IAAI,sBAAU,CAAC,0BAA0B,CAAC,CAAC;IAC9D,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE,CAAC;QAC7B,IAAI,CAAC;YACH,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;QACvD,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,QAAQ,CAAC,IAAI,CACX,IAAA,iCAAqB,EAAC,IAAI,EAAE,uCAAuC,CAAC,KAAK,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,cAAc,EAAE,CAAC,CAC7G,CAAC;QACJ,CAAC;IACH,CAAC;IAED,OAAO;QACL,kBAAkB;QAClB,WAAW,EAAE,CAAC,GAAG,UAAU,CAAC,WAAW,EAAE,GAAG,QAAQ,CAAC;KACtD,CAAC;AACJ,CAAC;AAED,UAAU,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,CAAC,CAAC","sourcesContent":["/**\n * Pool worker for extract.ts\n */\nimport * as workerpool from 'workerpool';\n\nimport { TypeScriptSnippet } from './snippet';\nimport { TranslatedSnippetSchema } from './tablets/schema';\nimport { TranslatedSnippet } from './tablets/tablets';\nimport { RosettaDiagnostic, Translator, makeRosettaDiagnostic } from './translate';\nimport { TranslateAllResult } from './translate_all';\n\nexport interface TranslateBatchRequest {\n  readonly snippets: TypeScriptSnippet[];\n  readonly includeCompilerDiagnostics: boolean;\n}\n\nexport interface TranslateBatchResponse {\n  // Cannot be 'TranslatedSnippet' because needs to be serializable\n  readonly translatedSchemas: TranslatedSnippetSchema[];\n  readonly diagnostics: RosettaDiagnostic[];\n}\n\nfunction translateBatch(request: TranslateBatchRequest): TranslateBatchResponse {\n  const result = singleThreadedTranslateAll(request.snippets, request.includeCompilerDiagnostics);\n\n  return {\n    translatedSchemas: result.translatedSnippets.map((s) => s.snippet),\n    diagnostics: result.diagnostics,\n  };\n}\n\n/**\n * Translate the given snippets using a single compiler\n */\nexport function singleThreadedTranslateAll(\n  snippets: TypeScriptSnippet[],\n  includeCompilerDiagnostics: boolean,\n): TranslateAllResult {\n  const translatedSnippets = new Array<TranslatedSnippet>();\n\n  const failures = new Array<RosettaDiagnostic>();\n\n  const translator = new Translator(includeCompilerDiagnostics);\n  for (const block of snippets) {\n    try {\n      translatedSnippets.push(translator.translate(block));\n    } catch (e: any) {\n      failures.push(\n        makeRosettaDiagnostic(true, `rosetta: error translating snippet: ${e}\\n${e.stack}\\n${block.completeSource}`),\n      );\n    }\n  }\n\n  return {\n    translatedSnippets,\n    diagnostics: [...translator.diagnostics, ...failures],\n  };\n}\n\nworkerpool.worker({ translateBatch });\n"]}