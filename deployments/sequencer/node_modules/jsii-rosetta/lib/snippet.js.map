{"version":3,"file":"snippet.js","sourceRoot":"","sources":["../src/snippet.ts"],"names":[],"mappings":"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","sourcesContent":["import { trimCompleteSourceToVisible } from './typescript/visible-spans';\n\n/**\n * A piece of TypeScript code found in an assembly, ready to be translated\n */\nexport interface TypeScriptSnippet {\n  /**\n   * The snippet code that ends up in the JSII assembly\n   */\n  readonly visibleSource: string;\n\n  /**\n   * Description of where the snippet was found\n   */\n  readonly location: SnippetLocation;\n\n  /**\n   * When enhanced with a fixture, the snippet's complete source code\n   */\n  readonly completeSource?: string;\n\n  /**\n   * Parameters for the conversion\n   */\n  readonly parameters?: Record<string, string>;\n\n  /**\n   * Whether this snippet must be processed as if `--strict` was always supplied.\n   *\n   * @default false\n   */\n  readonly strict?: boolean;\n\n  /**\n   * Dependencies necessary to compile this snippet\n   *\n   * Value is a regular { name -> semver } map like NPM's `dependencies`,\n   * `devDependencies` etc.\n   *\n   * @default none\n   */\n  readonly compilationDependencies?: Record<string, CompilationDependency>;\n}\n\nexport type CompilationDependency =\n  | { readonly type: 'concrete'; readonly resolvedDirectory: string }\n  | { readonly type: 'symbolic'; readonly versionRange: string };\n\n/**\n * Description of a location where the snippet is found\n *\n * The location does not necessarily indicate an exact source file,\n * but it will generally refer to a location that can contain one or more\n * snippets.\n */\nexport interface SnippetLocation {\n  /**\n   * The jsii API with which this snippet is associated\n   */\n  readonly api: ApiLocation;\n\n  /**\n   * The API field in which the snippet is found, if any\n   *\n   * Absence of this field is appropriate for source files (or tests),\n   * but for Markdown files 'field' should really be set to a Markdown\n   * location.\n   */\n  readonly field?: FieldLocation;\n}\n\n/**\n * How to represent the initializer in a 'parameter' type.\n *\n * (Don't feel like making everyone's `case` statement worse by adding an\n * 'initializer-parameter' variant).\n */\nexport const INITIALIZER_METHOD_NAME = '<initializer>';\n\nexport type ApiLocation =\n  | { readonly api: 'file'; readonly fileName: string }\n  | { readonly api: 'moduleReadme'; readonly moduleFqn: string }\n  | { readonly api: 'type'; readonly fqn: string }\n  | { readonly api: 'initializer'; readonly fqn: string }\n  | { readonly api: 'member'; readonly fqn: string; readonly memberName: string }\n  | {\n      readonly api: 'parameter';\n      readonly fqn: string;\n      readonly methodName: string | typeof INITIALIZER_METHOD_NAME;\n      readonly parameterName: string;\n    };\n\nexport type FieldLocation = { readonly field: 'markdown'; readonly line: number } | { readonly field: 'example' };\n\n/**\n * Render an API location to a human readable representation\n */\nexport function formatLocation(location: SnippetLocation): string {\n  switch (location.field?.field) {\n    case 'example':\n      return `${renderApiLocation(location.api)}-example`;\n    case 'markdown':\n      return `${renderApiLocation(location.api)}-L${location.field.line}`;\n    case undefined:\n      return renderApiLocation(location.api);\n  }\n}\n\n/**\n * Render an API location to an unique string\n *\n * This function is used in hashing examples for reuse, and so the formatting\n * here should not be changed lightly.\n */\nexport function renderApiLocation(apiLoc: ApiLocation): string {\n  switch (apiLoc.api) {\n    case 'file':\n      return apiLoc.fileName;\n    case 'moduleReadme':\n      return `${apiLoc.moduleFqn}-README`;\n    case 'type':\n      return apiLoc.fqn;\n    case 'initializer':\n      return `${apiLoc.fqn}#initializer`;\n    case 'member':\n      return `${apiLoc.fqn}#${apiLoc.memberName}`;\n    case 'parameter':\n      return `${apiLoc.fqn}#${apiLoc.methodName}!#${apiLoc.parameterName}`;\n  }\n}\n\n/**\n * Construct a TypeScript snippet from visible source\n *\n * Will parse parameters from a directive in the given source, but will not\n * interpret `/// !show` and `/// !hide` directives.\n *\n * `/// !show` and `/// !hide` directives WILL affect what gets displayed by\n * the translator, but they will NOT affect the snippet's cache key (i.e. the\n * cache key will be based on the full source given here).\n *\n * Use this if you are looking up a snippet in a tablet, which has been translated\n * previously using a fixture.\n */\nexport function typeScriptSnippetFromVisibleSource(\n  typeScriptSource: string,\n  location: SnippetLocation,\n  strict: boolean,\n  parameters: Record<string, string> = {},\n): TypeScriptSnippet {\n  const [source, sourceParameters] = parametersFromSourceDirectives(typeScriptSource);\n  const visibleSource = source.trimEnd();\n\n  return {\n    visibleSource,\n    location,\n    parameters: Object.assign({}, parameters, sourceParameters),\n    strict,\n  };\n}\n\n/**\n * Construct a TypeScript snippet from literal source\n *\n * @deprecated Use `typeScriptSnippetFromVisibleSource`\n */\nexport function typeScriptSnippetFromSource(\n  typeScriptSource: string,\n  location: SnippetLocation,\n  strict: boolean,\n  parameters: Record<string, string> = {},\n): TypeScriptSnippet {\n  return typeScriptSnippetFromVisibleSource(typeScriptSource, location, strict, parameters);\n}\n\n/**\n * Construct a TypeScript snippet from complete source\n *\n * Will parse parameters from a directive in the given source, and will\n * interpret `/// !show` and `/// !hide` directives.\n *\n * The snippet's cache key will be based on the source that remains after\n * these directives are processed.\n *\n * Use this if you are building a snippet to be translated, and take care\n * to store the return object's `visibleSource` in the assembly (not the original\n * source you passed in).\n */\nexport function typeScriptSnippetFromCompleteSource(\n  typeScriptSource: string,\n  location: SnippetLocation,\n  strict: boolean,\n  parameters: Record<string, string> = {},\n): TypeScriptSnippet {\n  const [source, sourceParameters] = parametersFromSourceDirectives(typeScriptSource);\n  const completeSrc = source.trimRight();\n\n  const visibleSource = trimCompleteSourceToVisible(completeSrc);\n\n  return {\n    visibleSource,\n    completeSource: visibleSource !== completeSrc ? completeSrc : undefined,\n    location,\n    parameters: Object.assign({}, parameters, sourceParameters),\n    strict,\n  };\n}\n\nexport function updateParameters(snippet: TypeScriptSnippet, params: Record<string, string>): TypeScriptSnippet {\n  return {\n    ...snippet,\n    parameters: Object.assign(Object.create(null), snippet.parameters ?? {}, params),\n  };\n}\n\n/**\n * Get the complete (compilable) source of a snippet\n */\nexport function completeSource(snippet: TypeScriptSnippet) {\n  return snippet.completeSource ?? snippet.visibleSource;\n}\n\n/**\n * Extract snippet parameters from the first line of the source if it's a compiler directive\n */\nfunction parametersFromSourceDirectives(source: string): [string, Record<string, string>] {\n  const [firstLine, ...rest] = source.split('\\n');\n  // Also extract parameters from an initial line starting with '/// ' (getting rid of that line).\n  const m = /[/]{3}(.*)$/.exec(firstLine);\n  if (m) {\n    return [rest.join('\\n'), parseMetadataLine(m[1])];\n  }\n\n  return [source, {}];\n}\n\n/**\n * Parse a set of 'param param=value' directives into an object\n */\nexport function parseKeyValueList(parameters: string[]): Record<string, string> {\n  const ret: Record<string, string> = {};\n  for (const param of parameters) {\n    const parts = param.split('=', 2);\n    if (parts.length === 2) {\n      ret[parts[0]] = parts[1];\n    } else {\n      ret[parts[0]] = '';\n    }\n  }\n  return ret;\n}\n\nexport function parseMetadataLine(metadata: string): Record<string, string> {\n  return parseKeyValueList(parseMetadata(metadata));\n\n  function parseMetadata(md: string): string[] {\n    return md\n      .trim()\n      .split(' ')\n      .map((s) => s.trim())\n      .filter((s) => s !== '');\n  }\n}\n\nexport function renderMetadataline(metadata: Record<string, string> = {}): string | undefined {\n  const line = Object.entries(metadata)\n    .filter(([key, _]) => !key.startsWith('$'))\n    .map(([key, value]) => (value !== '' ? `${key}=${value}` : key))\n    .join(' ');\n\n  return line ? line : undefined;\n}\n\n/**\n * Recognized snippet parameters\n */\nexport enum SnippetParameters {\n  /**\n   * Use fixture with the given name (author parameter)\n   */\n  FIXTURE = 'fixture',\n\n  /**\n   * Don't use a fixture (author parameter)\n   */\n  NO_FIXTURE = 'nofixture',\n\n  /**\n   * Snippet was extracted from this literate file (backwards compatibility)\n   *\n   * Parameter attached by 'jsii'; load the given file instead of any fixture,\n   * process as usual.\n   */\n  LITERATE_SOURCE = 'lit',\n\n  /**\n   * This snippet has been infused\n   *\n   * This means it has been copied from a different location, and potentially\n   * even from a different assembly. If so, we can't expect it to compile in\n   * the future, and if doesn't, we ignore the errors.\n   *\n   * N.B: this shouldn't make a difference in normal operation, as the `infuse`\n   * command will duplicate the translation to the target tablet. This only\n   * matters if we remove the tablet and try to re-extract an assembly with\n   * infused examples from somewher else.\n   */\n  INFUSED = 'infused',\n\n  /**\n   * What directory to resolve fixtures in for this snippet (system parameter)\n   *\n   * Attached during processing, should not be used by authors. Does NOT imply\n   * anything about the directory where we pretend to compile this file.\n   */\n  $PROJECT_DIRECTORY = '$directory',\n\n  /**\n   * What directory to pretend the file is in (system parameter)\n   *\n   * Attached when compiling a literate file, as they compile in\n   * the location where they are stored.\n   */\n  $COMPILATION_DIRECTORY = '$compilation',\n}\n"]}