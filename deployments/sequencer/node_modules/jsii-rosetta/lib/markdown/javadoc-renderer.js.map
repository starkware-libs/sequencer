{"version":3,"file":"javadoc-renderer.js","sourceRoot":"","sources":["../../src/markdown/javadoc-renderer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as cm from 'commonmark';\n\nimport { makeJavaEscaper } from './escapes';\nimport { RendererContext } from './markdown';\nimport { MarkdownRenderer, collapsePara, para, stripTrailingWhitespace, stripPara } from './markdown-renderer';\n\nconst ESCAPE = makeJavaEscaper();\n\n/**\n * A renderer that will render a CommonMark tree to JavaDoc comments\n *\n * Mostly concerns itself with code annotations and escaping; tags that the\n * XML formatter doesn't have equivalents for will be rendered back to MarkDown.\n */\nexport class JavaDocRenderer extends MarkdownRenderer {\n  public override block_quote(_node: cm.Node, context: RendererContext) {\n    return `<blockquote>${context.content()}</blockquote>`;\n  }\n\n  public override code(node: cm.Node, _context: RendererContext) {\n    return `<code>${ESCAPE.text(node.literal)}</code>`;\n  }\n\n  /**\n   * Render code blocks for JavaDoc\n   *\n   * See https://reflectoring.io/howto-format-code-snippets-in-javadoc/\n   *\n   * Since we need to display @ inside our examples and we don't have to\n   * care about writability, the most robust option seems to be <pre>\n   * tags with escaping of bad characters.\n   */\n  public override code_block(node: cm.Node, _context: RendererContext) {\n    return para(`<blockquote><pre>\\n${ESCAPE.text(node.literal)}</pre></blockquote>`);\n  }\n\n  public override text(node: cm.Node, _context: RendererContext) {\n    return ESCAPE.text(node.literal) ?? '';\n  }\n\n  public override link(node: cm.Node, context: RendererContext) {\n    return `<a href=\"${ESCAPE.attribute(node.destination) ?? ''}\">${context.content()}</a>`;\n  }\n\n  public override document(_node: cm.Node, context: RendererContext) {\n    return stripTrailingWhitespace(specialDocCommentEscape(collapseParaJava(context.content())));\n  }\n\n  public override heading(node: cm.Node, context: RendererContext) {\n    return para(`<h${node.level}>${context.content()}</h${node.level}>`);\n  }\n\n  public override list(node: cm.Node, context: RendererContext) {\n    const tag = node.listType === 'bullet' ? 'ul' : 'ol';\n\n    return para(`<${tag}>\\n${context.content()}</${tag}>`);\n  }\n\n  public override item(_node: cm.Node, context: RendererContext) {\n    return `<li>${stripPara(context.content())}</li>\\n`;\n  }\n\n  public override image(node: cm.Node, context: RendererContext) {\n    return `<img alt=\"${ESCAPE.text2attr(context.content())}\" src=\"${ESCAPE.attribute(node.destination) ?? ''}\">`;\n  }\n\n  public override emph(_node: cm.Node, context: RendererContext) {\n    return `<em>${context.content()}</em>`;\n  }\n\n  public override strong(_node: cm.Node, context: RendererContext) {\n    return `<strong>${context.content()}</strong>`;\n  }\n\n  public override thematic_break(_node: cm.Node, _context: RendererContext) {\n    return para('<hr>');\n  }\n}\n\nfunction collapseParaJava(x: string) {\n  return collapsePara(x, '\\n<p>\\n');\n}\n\n/**\n * A final single-pass escape of '* /' which might otherwise end a doc comment.\n *\n * We have to do this in one final pass because I've observed that in running\n * next, the MarkDown parser will parse the two symbols to:\n *\n *    [..., text('*'), text('/'), ...]\n *\n * which means we have no other ability to observe the two-character combination\n * properly.\n */\nfunction specialDocCommentEscape(x: string) {\n  return x.replace(new RegExp('\\\\*\\\\/', 'g'), '*&#47;');\n}\n"]}