{"version":3,"file":"renderer.js","sourceRoot":"","sources":["../src/renderer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { TargetLanguage } from './languages';\nimport { NO_SYNTAX, OTree, UnknownSyntax, Span } from './o-tree';\nimport { SubmoduleReference, SubmoduleReferenceMap } from './submodule-reference';\nimport {\n  commentRangeFromTextRange,\n  extractMaskingVoidExpression,\n  extractShowingVoidExpression,\n  nodeChildren,\n  repeatNewlines,\n  scanText,\n} from './typescript/ast-utils';\nimport { analyzeImportDeclaration, analyzeImportEquals, ImportStatement } from './typescript/imports';\nimport { typeOfExpression, inferredTypeOfExpression } from './typescript/types';\n\n/**\n * Render a TypeScript AST to some other representation (encoded in OTrees)\n *\n * Dispatch the actual conversion to a specific handler which will get the\n * appropriate method called for particular AST nodes. The handler may use\n * context to modify its own operations when traversing the tree hierarchy,\n * the type of which should be expressed via the C parameter.\n */\nexport class AstRenderer<C> {\n  public readonly diagnostics = new Array<ts.Diagnostic>();\n  public readonly currentContext: C;\n\n  public constructor(\n    private readonly sourceFile: ts.SourceFile,\n    public readonly typeChecker: ts.TypeChecker,\n    private readonly handler: AstHandler<C>,\n    private readonly options: AstRendererOptions = {},\n    public readonly submoduleReferences: SubmoduleReferenceMap = new Map(),\n  ) {\n    this.currentContext = handler.defaultContext;\n  }\n\n  /**\n   * Merge the new context with the current context and create a new Converter from it\n   */\n  public updateContext(contextUpdate: Partial<C>): AstRenderer<C> {\n    const newContext = this.handler.mergeContext(this.currentContext, contextUpdate);\n\n    // Use prototypal inheritance to create a version of 'this' in which only\n    // 'currentContext' is updated.\n    return Object.assign(Object.create(this), {\n      currentContext: newContext,\n    });\n  }\n\n  /**\n   * Convert a single node to an OTree\n   */\n  public convert(node: ts.Node | undefined): OTree {\n    if (node === undefined) {\n      return NO_SYNTAX;\n    }\n\n    // Basic transform of node\n    const transformed = this.dispatch(node);\n    transformed.setSpan(node.getStart(this.sourceFile), node.getEnd());\n    if (!transformed.attachComment) {\n      return transformed;\n    }\n\n    const withTrivia = this.attachLeadingTrivia(node, transformed);\n    withTrivia.setSpan(node.getStart(this.sourceFile), node.getEnd());\n    return withTrivia;\n  }\n\n  /**\n   * Convert a set of nodes, filtering out hidden nodes\n   */\n  public convertAll(nodes: readonly ts.Node[]): OTree[] {\n    return filterVisible(nodes).map(this.convert.bind(this));\n  }\n\n  public convertWithModifier(\n    nodes: readonly ts.Node[],\n    makeContext: (context: this, node: ts.Node, index: number) => AstRenderer<C>,\n  ): OTree[] {\n    const vis = assignVisibility(nodes);\n    const result = new Array<OTree>();\n    for (const [idx, { node, visible, maskingVoid }] of vis.entries()) {\n      const renderedNode = visible ? node : maskingVoid;\n      if (renderedNode) {\n        const context = makeContext(this, renderedNode, idx);\n        result.push(context.convert(renderedNode));\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Convert a set of nodes, but update the context for the last one.\n   *\n   * Takes visibility into account.\n   */\n  public convertLastDifferently(nodes: readonly ts.Node[], lastContext: C): OTree[] {\n    const lastConverter = this.updateContext(lastContext);\n\n    const convert = this.convert.bind(this);\n    const lastConvert = lastConverter.convert.bind(lastConverter);\n\n    const ret: OTree[] = [];\n\n    const vis = assignVisibility(nodes);\n    for (let i = 0; i < vis.length; i++) {\n      const whichConvert = i === vis.length - 1 ? lastConvert : convert;\n\n      const node = vis[i].visible ? vis[i].node : vis[i].maskingVoid;\n      if (node) {\n        ret.push(whichConvert(node));\n      }\n    }\n\n    return ret;\n  }\n\n  public getPosition(node: ts.Node): Span {\n    return {\n      start: node.getStart(this.sourceFile),\n      end: node.getEnd(),\n    };\n  }\n\n  public textOf(node: ts.Node): string {\n    return node.getText(this.sourceFile);\n  }\n\n  public textAt(pos: number, end: number): string {\n    return this.sourceFile.text.substring(pos, end);\n  }\n\n  /**\n   * Infer type of expression by the argument it is assigned to\n   *\n   * If the type of the expression can include undefined (if the value is\n   * optional), `undefined` will be removed from the union.\n   *\n   * (Will return undefined for object literals not unified with a declared type)\n   *\n   * @deprecated Use `inferredTypeOfExpression` instead\n   */\n  public inferredTypeOfExpression(node: ts.Expression) {\n    return inferredTypeOfExpression(this.typeChecker, node);\n  }\n\n  /**\n   * Type of expression from the text of the expression\n   *\n   * (Will return a map type for object literals)\n   *\n   * @deprecated Use `typeOfExpression` directly\n   */\n  public typeOfExpression(node: ts.Expression): ts.Type {\n    return typeOfExpression(this.typeChecker, node);\n  }\n\n  public typeOfType(node: ts.TypeNode): ts.Type {\n    return this.typeChecker.getTypeFromTypeNode(node);\n  }\n\n  public typeToString(type: ts.Type) {\n    return this.typeChecker.typeToString(type);\n  }\n\n  public report(node: ts.Node, messageText: string, category: ts.DiagnosticCategory = ts.DiagnosticCategory.Error) {\n    this.diagnostics.push({\n      category,\n      code: 0,\n      source: 'rosetta',\n      messageText,\n      file: this.sourceFile,\n      start: node.getStart(this.sourceFile),\n      length: node.getWidth(this.sourceFile),\n    });\n  }\n\n  public reportUnsupported(node: ts.Node, language: TargetLanguage | undefined): void {\n    const nodeKind = ts.SyntaxKind[node.kind];\n    // tslint:disable-next-line:max-line-length\n    if (language) {\n      this.report(\n        node,\n        `This TypeScript feature (${nodeKind}) is not supported in examples because we cannot translate it to ${language}. Please rewrite this example.`,\n      );\n    } else {\n      this.report(\n        node,\n        `This TypeScript feature (${nodeKind}) is not supported in examples. Please rewrite this example.`,\n      );\n    }\n  }\n\n  /**\n   * Whether there is non-whitespace on the same line before the given position\n   */\n  public codeOnLineBefore(pos: number) {\n    const text = this.sourceFile.text;\n    while (pos > 0) {\n      const c = text[--pos];\n      if (c === '\\n') {\n        return false;\n      }\n      if (c !== ' ' && c !== '\\r' && c !== '\\t') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return a newline if the given node is preceded by at least one newline\n   *\n   * Used to mirror newline use between matchin brackets (such as { ... } and [ ... ]).\n   */\n  public mirrorNewlineBefore(viz?: ts.Node, suffix = '', otherwise = ''): string {\n    if (viz === undefined) {\n      return suffix;\n    }\n\n    // Return a newline if the given node is preceded by newlines\n    const leadingRanges = scanText(this.sourceFile.text, viz.getFullStart(), viz.getStart(this.sourceFile));\n    const newlines = [];\n\n    for (const range of leadingRanges) {\n      if (range.type === 'other') {\n        newlines.push(repeatNewlines(this.sourceFile.text.substring(range.pos, range.end)));\n      }\n    }\n\n    return (newlines.join('').length > 0 ? '\\n' : otherwise) + suffix;\n  }\n\n  /**\n   * Dispatch node to handler\n   */\n  private dispatch(tree: ts.Node): OTree {\n    const visitor = this.handler;\n\n    // Using a switch on tree.kind + forced down-casting, because this is significantly faster than\n    // doing a cascade of `if` statements with the `ts.is<NodeType>` functions, since `tree.kind` is\n    // effectively integers, and this switch statement is hence optimizable to a jump table. This is\n    // a VERY significant enhancement to the debugging experience, too.\n    switch (tree.kind) {\n      case ts.SyntaxKind.EmptyStatement:\n        // Additional semicolon where it doesn't belong.\n        return NO_SYNTAX;\n      case ts.SyntaxKind.SourceFile:\n        return visitor.sourceFile(tree as ts.SourceFile, this);\n      case ts.SyntaxKind.ImportEqualsDeclaration:\n        return visitor.importStatement(analyzeImportEquals(tree as ts.ImportEqualsDeclaration, this), this);\n      case ts.SyntaxKind.ImportDeclaration:\n        return new OTree(\n          [],\n          analyzeImportDeclaration(tree as ts.ImportDeclaration, this, this.submoduleReferences).map((import_) =>\n            visitor.importStatement(import_, this),\n          ),\n          { canBreakLine: true, separator: '\\n' },\n        );\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        return visitor.stringLiteral(tree as ts.StringLiteral | ts.NoSubstitutionTemplateLiteral, this);\n      case ts.SyntaxKind.NumericLiteral:\n        return visitor.numericLiteral(tree as ts.NumericLiteral, this);\n      case ts.SyntaxKind.FunctionDeclaration:\n        return visitor.functionDeclaration(tree as ts.FunctionDeclaration, this);\n      case ts.SyntaxKind.Identifier:\n        return visitor.identifier(tree as ts.Identifier, this);\n      case ts.SyntaxKind.Block:\n        return visitor.block(tree as ts.Block, this);\n      case ts.SyntaxKind.Parameter:\n        return visitor.parameterDeclaration(tree as ts.ParameterDeclaration, this);\n      case ts.SyntaxKind.ReturnStatement:\n        return visitor.returnStatement(tree as ts.ReturnStatement, this);\n      case ts.SyntaxKind.BinaryExpression:\n        return visitor.binaryExpression(tree as ts.BinaryExpression, this);\n      case ts.SyntaxKind.IfStatement:\n        return visitor.ifStatement(tree as ts.IfStatement, this);\n      case ts.SyntaxKind.PropertyAccessExpression:\n        const submoduleReference = this.submoduleReferences?.get(tree as ts.PropertyAccessExpression);\n        return visitor.propertyAccessExpression(tree as ts.PropertyAccessExpression, this, submoduleReference);\n      case ts.SyntaxKind.AwaitExpression:\n        return visitor.awaitExpression(tree as ts.AwaitExpression, this);\n      case ts.SyntaxKind.CallExpression:\n        return visitor.callExpression(tree as ts.CallExpression, this);\n      case ts.SyntaxKind.ExpressionStatement:\n        return visitor.expressionStatement(tree as ts.ExpressionStatement, this);\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        return visitor.objectLiteralExpression(tree as ts.ObjectLiteralExpression, this);\n      case ts.SyntaxKind.NewExpression:\n        return visitor.newExpression(tree as ts.NewExpression, this);\n      case ts.SyntaxKind.PropertyAssignment:\n        return visitor.propertyAssignment(tree as ts.PropertyAssignment, this);\n      case ts.SyntaxKind.VariableStatement:\n        return visitor.variableStatement(tree as ts.VariableStatement, this);\n      case ts.SyntaxKind.VariableDeclarationList:\n        return visitor.variableDeclarationList(tree as ts.VariableDeclarationList, this);\n      case ts.SyntaxKind.VariableDeclaration:\n        return visitor.variableDeclaration(tree as ts.VariableDeclaration, this);\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        return visitor.arrayLiteralExpression(tree as ts.ArrayLiteralExpression, this);\n      case ts.SyntaxKind.ShorthandPropertyAssignment:\n        return visitor.shorthandPropertyAssignment(tree as ts.ShorthandPropertyAssignment, this);\n      case ts.SyntaxKind.ForOfStatement:\n        return visitor.forOfStatement(tree as ts.ForOfStatement, this);\n      case ts.SyntaxKind.ClassDeclaration:\n        return visitor.classDeclaration(tree as ts.ClassDeclaration, this);\n      case ts.SyntaxKind.Constructor:\n        return visitor.constructorDeclaration(tree as ts.ConstructorDeclaration, this);\n      case ts.SyntaxKind.PropertyDeclaration:\n        return visitor.propertyDeclaration(tree as ts.PropertyDeclaration, this);\n      case ts.SyntaxKind.ComputedPropertyName:\n        return visitor.computedPropertyName((tree as ts.ComputedPropertyName).expression, this);\n      case ts.SyntaxKind.MethodDeclaration:\n        return visitor.methodDeclaration(tree as ts.MethodDeclaration, this);\n      case ts.SyntaxKind.InterfaceDeclaration:\n        return visitor.interfaceDeclaration(tree as ts.InterfaceDeclaration, this);\n      case ts.SyntaxKind.PropertySignature:\n        return visitor.propertySignature(tree as ts.PropertySignature, this);\n      case ts.SyntaxKind.MethodSignature:\n        return visitor.methodSignature(tree as ts.MethodSignature, this);\n      case ts.SyntaxKind.AsExpression:\n        return visitor.asExpression(tree as ts.AsExpression, this);\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        return visitor.prefixUnaryExpression(tree as ts.PrefixUnaryExpression, this);\n      case ts.SyntaxKind.SpreadAssignment:\n        if (this.textOf(tree) === '...') {\n          return visitor.ellipsis(tree as ts.SpreadAssignment, this);\n        }\n        return visitor.spreadAssignment(tree as ts.SpreadAssignment, this);\n      case ts.SyntaxKind.SpreadElement:\n        if (this.textOf(tree) === '...') {\n          return visitor.ellipsis(tree as ts.SpreadElement, this);\n        }\n        return visitor.spreadElement(tree as ts.SpreadElement, this);\n      case ts.SyntaxKind.ElementAccessExpression:\n        return visitor.elementAccessExpression(tree as ts.ElementAccessExpression, this);\n      case ts.SyntaxKind.TemplateExpression:\n        return visitor.templateExpression(tree as ts.TemplateExpression, this);\n      case ts.SyntaxKind.NonNullExpression:\n        return visitor.nonNullExpression(tree as ts.NonNullExpression, this);\n      case ts.SyntaxKind.ParenthesizedExpression:\n        return visitor.parenthesizedExpression(tree as ts.ParenthesizedExpression, this);\n      case ts.SyntaxKind.VoidExpression:\n        return visitor.maskingVoidExpression(tree as ts.VoidExpression, this);\n      case ts.SyntaxKind.JSDoc:\n      case ts.SyntaxKind.JSDocComment:\n        return visitor.jsDoc(tree as ts.JSDoc, this);\n      default:\n        if (ts.isToken(tree)) {\n          return visitor.token(tree, this);\n        }\n        this.reportUnsupported(tree, undefined);\n    }\n\n    if (this.options.bestEffort !== false) {\n      // When doing best-effort conversion and we don't understand the node type, just return the complete text of it as-is\n      return new OTree([this.textOf(tree)]);\n    }\n    // Otherwise, show a placeholder indicating we don't recognize the type\n    const nodeKind = ts.SyntaxKind[tree.kind];\n    return new UnknownSyntax(\n      [`<${nodeKind} ${this.textOf(tree)}>`],\n      ['\\n', ...nodeChildren(tree).map(this.convert.bind(this))],\n      {\n        indent: 2,\n      },\n    );\n  }\n\n  /**\n   * Attach any leading whitespace and comments to the given output tree\n   *\n   * Regardless of whether it's declared to be able to accept such or not.\n   */\n  private attachLeadingTrivia(node: ts.Node, transformed: OTree): OTree {\n    // Add comments and leading whitespace\n    const leadingRanges = scanText(this.sourceFile.text, node.getFullStart(), node.getStart(this.sourceFile));\n\n    const precede: OTree[] = [];\n    for (const range of leadingRanges) {\n      let trivia: OTree | undefined = undefined;\n      switch (range.type) {\n        case 'other':\n          trivia = new OTree([repeatNewlines(this.sourceFile.text.substring(range.pos, range.end))], [], {\n            renderOnce: `ws-${range.pos}`,\n          });\n          break;\n        case 'linecomment':\n        case 'blockcomment':\n          trivia = this.handler.commentRange(\n            commentSyntaxFromCommentRange(commentRangeFromTextRange(range), this),\n            this,\n          );\n          break;\n\n        case 'directive':\n          break;\n      }\n      if (trivia != null) {\n        // Set spans on comments to make sure their visibility is toggled correctly.\n        trivia.setSpan(range.pos, range.end);\n        precede.push(trivia);\n      }\n    }\n\n    // FIXME: No trailing comments for now, they're too tricky\n\n    if (precede.length > 0 && !transformed.isEmpty) {\n      return new OTree([...precede, transformed], [], { canBreakLine: true });\n    }\n    return transformed;\n  }\n}\n\n/**\n * Interface for AST handlers\n *\n * C is the type of hierarchical context the handler uses. Context\n * needs 2 operations: a constructor for a default context, and a\n * merge operation to combine 2 contexts to yield a new one.\n *\n * Otherwise, the handler should return an OTree for every type\n * of AST node.\n */\nexport interface AstHandler<C> {\n  readonly language: TargetLanguage;\n\n  readonly defaultContext: C;\n  readonly indentChar?: ' ' | '\\t';\n  mergeContext(old: C, update: Partial<C>): C;\n\n  sourceFile(node: ts.SourceFile, context: AstRenderer<C>): OTree;\n  commentRange(node: CommentSyntax, context: AstRenderer<C>): OTree;\n  importStatement(node: ImportStatement, context: AstRenderer<C>): OTree;\n  stringLiteral(node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral, children: AstRenderer<C>): OTree;\n  numericLiteral(node: ts.NumericLiteral, children: AstRenderer<C>): OTree;\n  functionDeclaration(node: ts.FunctionDeclaration, children: AstRenderer<C>): OTree;\n  identifier(node: ts.Identifier, children: AstRenderer<C>): OTree;\n  block(node: ts.Block, children: AstRenderer<C>): OTree;\n  parameterDeclaration(node: ts.ParameterDeclaration, children: AstRenderer<C>): OTree;\n  returnStatement(node: ts.ReturnStatement, context: AstRenderer<C>): OTree;\n  binaryExpression(node: ts.BinaryExpression, context: AstRenderer<C>): OTree;\n  ifStatement(node: ts.IfStatement, context: AstRenderer<C>): OTree;\n  propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    context: AstRenderer<C>,\n    submoduleReference: SubmoduleReference | undefined,\n  ): OTree;\n  awaitExpression(node: ts.AwaitExpression, context: AstRenderer<C>): OTree;\n  callExpression(node: ts.CallExpression, context: AstRenderer<C>): OTree;\n  expressionStatement(node: ts.ExpressionStatement, context: AstRenderer<C>): OTree;\n  token<A extends ts.SyntaxKind>(node: ts.Token<A>, context: AstRenderer<C>): OTree;\n  objectLiteralExpression(node: ts.ObjectLiteralExpression, context: AstRenderer<C>): OTree;\n  newExpression(node: ts.NewExpression, context: AstRenderer<C>): OTree;\n  propertyAssignment(node: ts.PropertyAssignment, context: AstRenderer<C>): OTree;\n  variableStatement(node: ts.VariableStatement, context: AstRenderer<C>): OTree;\n  variableDeclarationList(node: ts.VariableDeclarationList, context: AstRenderer<C>): OTree;\n  variableDeclaration(node: ts.VariableDeclaration, context: AstRenderer<C>): OTree;\n  jsDoc(node: ts.JSDoc, context: AstRenderer<C>): OTree;\n  arrayLiteralExpression(node: ts.ArrayLiteralExpression, context: AstRenderer<C>): OTree;\n  shorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, context: AstRenderer<C>): OTree;\n  forOfStatement(node: ts.ForOfStatement, context: AstRenderer<C>): OTree;\n  classDeclaration(node: ts.ClassDeclaration, context: AstRenderer<C>): OTree;\n  constructorDeclaration(node: ts.ConstructorDeclaration, context: AstRenderer<C>): OTree;\n  propertyDeclaration(node: ts.PropertyDeclaration, context: AstRenderer<C>): OTree;\n  computedPropertyName(node: ts.Expression, context: AstRenderer<C>): OTree;\n  methodDeclaration(node: ts.MethodDeclaration, context: AstRenderer<C>): OTree;\n  interfaceDeclaration(node: ts.InterfaceDeclaration, context: AstRenderer<C>): OTree;\n  propertySignature(node: ts.PropertySignature, context: AstRenderer<C>): OTree;\n  methodSignature(node: ts.MethodSignature, context: AstRenderer<C>): OTree;\n  asExpression(node: ts.AsExpression, context: AstRenderer<C>): OTree;\n  prefixUnaryExpression(node: ts.PrefixUnaryExpression, context: AstRenderer<C>): OTree;\n  spreadElement(node: ts.SpreadElement, context: AstRenderer<C>): OTree;\n  spreadAssignment(node: ts.SpreadAssignment, context: AstRenderer<C>): OTree;\n  templateExpression(node: ts.TemplateExpression, context: AstRenderer<C>): OTree;\n  nonNullExpression(node: ts.NonNullExpression, context: AstRenderer<C>): OTree;\n  parenthesizedExpression(node: ts.ParenthesizedExpression, context: AstRenderer<C>): OTree;\n  maskingVoidExpression(node: ts.VoidExpression, context: AstRenderer<C>): OTree;\n  elementAccessExpression(node: ts.ElementAccessExpression, context: AstRenderer<C>): OTree;\n\n  // Not a node, called when we recognize a spread element/assignment that is only\n  // '...' and nothing else.\n  ellipsis(node: ts.SpreadElement | ts.SpreadAssignment, context: AstRenderer<C>): OTree;\n}\n\nexport function nimpl<C>(node: ts.Node, context: AstRenderer<C>, options: { additionalInfo?: string } = {}) {\n  const children = nodeChildren(node).map((c) => context.convert(c));\n\n  let syntaxKind = ts.SyntaxKind[node.kind];\n  if (syntaxKind === 'FirstPunctuation') {\n    // These have the same identifier but this name is more descriptive\n    syntaxKind = 'OpenBraceToken';\n  }\n\n  const parts = [`(${syntaxKind}`];\n  if (options.additionalInfo) {\n    parts.push(`{${options.additionalInfo}}`);\n  }\n  parts.push(context.textOf(node));\n\n  return new UnknownSyntax([parts.join(' ')], children.length > 0 ? ['\\n', ...children] : [], {\n    indent: 2,\n    suffix: ')',\n    separator: '\\n',\n    canBreakLine: true,\n  });\n}\n\nexport interface AstRendererOptions {\n  /**\n   * If enabled, don't translate the text of unknown nodes\n   *\n   * @default true\n   */\n  bestEffort?: boolean;\n}\n\ninterface ClassifiedNode {\n  node: ts.Node;\n  visible: boolean;\n  maskingVoid?: ts.VoidExpression;\n}\n\nfunction filterVisible(nodes: readonly ts.Node[]): ts.Node[] {\n  return assignVisibility(nodes)\n    .map((c) => (c.visible ? c.node : c.maskingVoid))\n    .filter(notUndefined);\n}\n\nfunction assignVisibility(nodes: readonly ts.Node[]): ClassifiedNode[] {\n  const ret: ClassifiedNode[] = [];\n\n  let visible = true;\n  for (const node of nodes) {\n    const maskingVoid = extractMaskingVoidExpression(node);\n    if (visible && maskingVoid) {\n      visible = false;\n    }\n\n    ret.push({ node, maskingVoid, visible });\n\n    if (!visible) {\n      const showing = extractShowingVoidExpression(node);\n      if (showing) {\n        visible = true;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction notUndefined<A>(x: A | undefined): x is A {\n  return x !== undefined;\n}\n\n/**\n * Our own representation of comments\n *\n * (So we can synthesize 'em\n */\nexport interface CommentSyntax {\n  pos: number;\n  text: string;\n  hasTrailingNewLine?: boolean;\n  kind: ts.CommentKind;\n\n  /**\n   * Whether it's at the end of a code line (so we can render a separating space)\n   */\n  isTrailing?: boolean;\n}\n\nfunction commentSyntaxFromCommentRange(rng: ts.CommentRange, renderer: AstRenderer<any>): CommentSyntax {\n  return {\n    hasTrailingNewLine: rng.hasTrailingNewLine,\n    kind: rng.kind,\n    pos: rng.pos,\n    text: renderer.textAt(rng.pos, rng.end),\n    isTrailing: renderer.codeOnLineBefore(rng.pos),\n  };\n}\n"]}