{"version":3,"file":"rosetta-reader.js","sourceRoot":"","sources":["../src/rosetta-reader.ts"],"names":[],"mappings":"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","sourcesContent":["import * as spec from '@jsii/spec';\n\nimport { allTypeScriptSnippets, guessTabletLocation } from './jsii/assemblies';\nimport { TargetLanguage } from './languages';\nimport * as logging from './logging';\nimport { transformMarkdown } from './markdown/markdown';\nimport { MarkdownRenderer } from './markdown/markdown-renderer';\nimport { ReplaceTypeScriptTransform } from './markdown/replace-typescript-transform';\nimport { CodeBlock } from './markdown/types';\nimport {\n  SnippetParameters,\n  TypeScriptSnippet,\n  updateParameters,\n  ApiLocation,\n  typeScriptSnippetFromSource,\n} from './snippet';\nimport { snippetKey } from './tablets/key';\nimport { LanguageTablet, Translation } from './tablets/tablets';\nimport { Translator } from './translate';\nimport { commentToken, pathExists, printDiagnostics } from './util';\n\nexport enum UnknownSnippetMode {\n  /**\n   * Return the snippet as given (untranslated)\n   */\n  VERBATIM = 'verbatim',\n\n  /**\n   * Live-translate the snippet as best as we can\n   */\n  TRANSLATE = 'translate',\n\n  /**\n   * Throw an error if this occurs\n   */\n  FAIL = 'fail',\n}\n\nexport interface RosettaOptions {\n  /**\n   * Whether or not to live-convert samples\n   *\n   * @default UnknownSnippetMode.VERBATIM\n   */\n  readonly unknownSnippets?: UnknownSnippetMode;\n\n  /**\n   * Target languages to use for live conversion\n   *\n   * @default All languages\n   */\n  readonly targetLanguages?: readonly TargetLanguage[];\n\n  /**\n   * Whether to include compiler diagnostics in the compilation results.\n   */\n  readonly includeCompilerDiagnostics?: boolean;\n\n  /**\n   * Whether this Rosetta should operate in \"loose\" mode, where missing literate\n   * source files and missing fixtures are ignored instead of failing.\n   *\n   * @default false\n   */\n  readonly loose?: boolean;\n\n  /**\n   * Adds a disclaimer to start of snippet if it did not compile.\n   *\n   * @default false\n   */\n  readonly prefixDisclaimer?: boolean;\n}\n\n/**\n * Entry point class for consumers of Rosetta tablets (primarily: pacmak)\n *\n * Rosetta can work in one of two modes:\n *\n * 1. Live translation of snippets.\n * 2. Read translations from a pre-translated tablet (prepared using `jsii-rosetta extract` command).\n *\n * The second method affords more control over the precise circumstances of\n * sample compilation and is recommended, but the first method will do\n * when the second one is not necessary.\n */\nexport class RosettaTabletReader {\n  /**\n   * Newly translated samples\n   *\n   * In case live translation has been enabled, all samples that have been translated on-the-fly\n   * are added to this tablet.\n   */\n  public readonly liveTablet = new LanguageTablet();\n\n  private readonly loadedTablets: LanguageTablet[] = [];\n  private readonly extractedSnippets = new Map<string, TypeScriptSnippet>();\n  private readonly translator: Translator;\n  private readonly loose: boolean;\n  private readonly unknownSnippets: UnknownSnippetMode;\n  private readonly _prefixDisclaimer: boolean;\n\n  public constructor(private readonly options: RosettaOptions = {}) {\n    this.loose = !!options.loose;\n    this.unknownSnippets = options.unknownSnippets ?? UnknownSnippetMode.VERBATIM;\n    this.translator = new Translator(options.includeCompilerDiagnostics ?? false);\n    this._prefixDisclaimer = options.prefixDisclaimer ?? false;\n  }\n\n  /**\n   * Diagnostics encountered while doing live translation\n   */\n  public get diagnostics() {\n    return this.translator.diagnostics;\n  }\n\n  /**\n   * Load a tablet as a source for translateable snippets\n   *\n   * Note: the snippets loaded from this tablet will NOT be validated for\n   * their fingerprints or translator versions! If a matching snippet is found\n   * in the tablet, it will always be returned, whether or not it is stale.\n   */\n  public async loadTabletFromFile(tabletFile: string) {\n    const tablet = new LanguageTablet();\n    await tablet.load(tabletFile);\n    this.addTablet(tablet);\n  }\n\n  /**\n   * Directly add a tablet to the list of tablets to load translations from\n   */\n  public addTablet(tablet: LanguageTablet) {\n    this.loadedTablets.push(tablet);\n  }\n\n  /**\n   * Add an assembly\n   *\n   * If a default tablet file is found in the assembly's directory, it will be\n   * loaded (and assumed to contain a complete list of translated snippets for\n   * this assembly already).\n   *\n   * Otherwise, if live conversion is enabled, the snippets in the assembly\n   * become available for live translation later. This is necessary because we probably\n   * need to fixturize snippets for successful compilation, and the information\n   * pacmak sends our way later on is not going to be enough to do that.\n   */\n  public async addAssembly(assembly: spec.Assembly, assemblyDir: string) {\n    const defaultTablet = guessTabletLocation(assemblyDir);\n    if (await pathExists(defaultTablet)) {\n      try {\n        await this.loadTabletFromFile(defaultTablet);\n        return;\n      } catch (e: any) {\n        logging.warn(`Error loading ${defaultTablet}: ${e.message}. Skipped.`);\n      }\n    }\n\n    // Inventarize the snippets from this assembly, but only if there's a chance\n    // we're going to need them.\n    if (this.unknownSnippets === UnknownSnippetMode.TRANSLATE) {\n      for (const tsnip of await allTypeScriptSnippets([{ assembly, directory: assemblyDir }], this.loose)) {\n        this.extractedSnippets.set(snippetKey(tsnip), tsnip);\n      }\n    }\n  }\n\n  /**\n   * Translate the given snippet for the given target language\n   *\n   * This will either:\n   *\n   * - Find an existing translation in a tablet and return that, if available.\n   * - Otherwise, find a fixturized version of this snippet in an assembly that\n   *   was loaded beforehand, and translate it on-the-fly. Finding the fixture\n   *   will be based on the snippet key, which consists of a hash of the\n   *   visible source and the API location.\n   * - Otherwise, translate the snippet as-is (without fixture information).\n   *\n   * This will do and store a full conversion of the given snippet, even if it only\n   * returns one language. Subsequent retrievals for the same snippet in other\n   * languages will reuse the translation from cache.\n   *\n   * If you are calling this for the side effect of adding translations to the live\n   * tablet, you only need to do that for one language.\n   */\n  public translateSnippet(source: TypeScriptSnippet, targetLang: TargetLanguage): Translation | undefined {\n    // Look for it in loaded tablets (or previous conversions)\n    for (const tab of this.allTablets) {\n      const ret = tab.lookup(source, targetLang);\n      if (ret !== undefined) {\n        return this.prefixDisclaimer(ret, this._prefixDisclaimer);\n      }\n    }\n\n    if (this.unknownSnippets === UnknownSnippetMode.VERBATIM) {\n      return this.prefixDisclaimer(\n        {\n          language: targetLang,\n          source: source.visibleSource,\n        },\n        this._prefixDisclaimer,\n      );\n    }\n\n    if (this.unknownSnippets === UnknownSnippetMode.FAIL) {\n      const message = [\n        'The following snippet was not found in any of the loaded tablets:',\n        source.visibleSource,\n        `Location: ${JSON.stringify(source.location)}`,\n        `Language: ${targetLang}`,\n      ].join('\\n');\n      throw new Error(message);\n    }\n\n    if (this.options.targetLanguages && !this.options.targetLanguages.includes(targetLang)) {\n      throw new Error(\n        `Rosetta configured for live conversion to ${this.options.targetLanguages.join(\n          ', ',\n        )}, but requested ${targetLang}`,\n      );\n    }\n\n    // See if we can find a fixturized version of this snippet. If so, use that do the live\n    // conversion.\n    const extracted = this.extractedSnippets.get(snippetKey(source));\n    if (extracted !== undefined) {\n      const snippet = this.translator.translate(extracted, this.options.targetLanguages);\n      this.liveTablet.addSnippet(snippet);\n      return this.prefixDisclaimer(snippet.get(targetLang), this._prefixDisclaimer);\n    }\n\n    // Try to live-convert it as-is.\n    const snippet = this.translator.translate(source, this.options.targetLanguages);\n    this.liveTablet.addSnippet(snippet);\n    return this.prefixDisclaimer(snippet.get(targetLang), this._prefixDisclaimer);\n  }\n\n  /**\n   * Translate a snippet found in the \"@ example\" section of a jsii assembly\n   *\n   * Behaves exactly like `translateSnippet`, so see that method for documentation.\n   */\n  public translateExample(\n    apiLocation: ApiLocation,\n    example: string,\n    targetLang: TargetLanguage,\n    strict: boolean,\n    compileDirectory = process.cwd(),\n  ): Translation {\n    const location = { api: apiLocation, field: { field: 'example' } } as const;\n\n    const snippet = typeScriptSnippetFromSource(example, location, strict, {\n      [SnippetParameters.$COMPILATION_DIRECTORY]: compileDirectory,\n    });\n\n    const translated = this.translateSnippet(snippet, targetLang);\n\n    return translated ?? { language: 'typescript', source: example };\n  }\n\n  /**\n   * Translate all TypeScript snippets found in a block of Markdown text\n   *\n   * For each snippet, behaves exactly like `translateSnippet`, so see that\n   * method for documentation.\n   */\n  public translateSnippetsInMarkdown(\n    apiLocation: ApiLocation,\n    markdown: string,\n    targetLang: TargetLanguage,\n    strict: boolean,\n    translationToCodeBlock: (x: Translation) => CodeBlock = id,\n    compileDirectory = process.cwd(),\n  ): string {\n    return transformMarkdown(\n      markdown,\n      new MarkdownRenderer(),\n      new ReplaceTypeScriptTransform(apiLocation, strict, (tsSnip) => {\n        const translated = this.translateSnippet(\n          updateParameters(tsSnip, {\n            [SnippetParameters.$COMPILATION_DIRECTORY]: compileDirectory,\n          }),\n          targetLang,\n        );\n        if (!translated) {\n          return undefined;\n        }\n\n        return translationToCodeBlock(translated);\n      }),\n    );\n  }\n\n  public printDiagnostics(stream: NodeJS.WritableStream, colors = true) {\n    printDiagnostics(this.diagnostics, stream, colors);\n  }\n\n  public get hasErrors() {\n    return this.diagnostics.some((d) => d.isError);\n  }\n\n  private get allTablets(): LanguageTablet[] {\n    return [...this.loadedTablets, this.liveTablet];\n  }\n\n  /**\n   * Adds a disclaimer to the front of the example if the prefixDisclaimer\n   * flag is set and we know it does not compile.\n   */\n  private prefixDisclaimer(translation: Translation | undefined, prefixDisclaimer: boolean): Translation | undefined {\n    if (!prefixDisclaimer || translation?.didCompile !== false) {\n      return translation;\n    }\n    const comment = commentToken(translation.language);\n    const disclaimer = 'Example automatically generated from non-compiling source. May contain errors.';\n    return {\n      ...translation,\n      source: `${comment} ${disclaimer}\\n${translation.source}`,\n    };\n  }\n}\n\nfunction id(x: Translation) {\n  return x;\n}\n\n/**\n * Backwards compatibility\n *\n * @deprecated use RosettaTabletReader instead\n */\nexport class Rosetta extends RosettaTabletReader {}\n"]}