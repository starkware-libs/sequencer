{"version":3,"file":"go.js","sourceRoot":"","sources":["../../src/languages/go.ts"],"names":[],"mappings":"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","sourcesContent":["// import { JsiiSymbol, simpleName, namespaceName } from '../jsii/jsii-utils';\n// import { jsiiTargetParameter } from '../jsii/packages';\nimport { AssertionError } from 'node:assert';\nimport * as ts from 'typescript';\n\nimport { DefaultVisitor } from './default';\nimport { TargetLanguage } from './target-language';\nimport { analyzeObjectLiteral, determineJsiiType, JsiiType, ObjectLiteralStruct } from '../jsii/jsii-types';\nimport { lookupJsiiSymbolFromNode } from '../jsii/jsii-utils';\nimport { OTree } from '../o-tree';\nimport { AstRenderer } from '../renderer';\nimport { SubmoduleReference } from '../submodule-reference';\nimport { isExported, isPublic, isPrivate, isReadOnly, isStatic } from '../typescript/ast-utils';\nimport { analyzeImportDeclaration, ImportStatement } from '../typescript/imports';\nimport {\n  determineReturnType,\n  inferMapElementType,\n  inferredTypeOfExpression,\n  typeOfExpression,\n} from '../typescript/types';\n\ninterface GoLanguageContext {\n  /**\n   * Free floating symbols are made importable across packages by naming with a capital in Go.\n   */\n  isExported: boolean;\n\n  /**\n   * Whether type should be converted a pointer type\n   */\n  isPtr: boolean;\n\n  /**\n   * Whether this is the R-Value in an assignment expression to a pointer value.\n   */\n  isPtrAssignmentRValue: boolean;\n\n  /**\n   * Whether the current element is a parameter delcaration name.\n   */\n  isParameterName: boolean;\n\n  /**\n   * Whether context is within a struct declaration\n   */\n  isStruct: boolean;\n\n  /**\n   * Whether the context is within an interface delcaration.\n   */\n  isInterface: boolean;\n\n  /**\n   * Whether properties are being intialized within a `map` type\n   */\n  inMapLiteral: boolean;\n\n  /**\n   * Wheter to wrap a literal in a pointer constructor ie: jsii.String.\n   */\n  wrapPtr: boolean;\n}\n\nenum DeclarationType {\n  STRUCT,\n  INTERFACE,\n  FUNCTION,\n  BUILTIN,\n  UNKNOWN,\n}\n\ntype GoRenderer = AstRenderer<GoLanguageContext>;\n\ninterface FormattedId {\n  readonly type: DeclarationType;\n  readonly formatted: string;\n}\nexport class GoVisitor extends DefaultVisitor<GoLanguageContext> {\n  /**\n   * Translation version\n   *\n   * Bump this when you change something in the implementation to invalidate\n   * existing cached translations.\n   */\n  public static readonly VERSION = '1';\n\n  public readonly indentChar = '\\t';\n\n  public readonly language = TargetLanguage.GO;\n\n  private readonly idMap = new Map<ts.Symbol | string, FormattedId>();\n\n  public readonly defaultContext: GoLanguageContext = {\n    isExported: false,\n    isPtr: false,\n    isPtrAssignmentRValue: false,\n    isStruct: false,\n    isInterface: false,\n    isParameterName: false,\n    inMapLiteral: false,\n    wrapPtr: false,\n  };\n\n  protected override argumentList(args: readonly ts.Node[] | undefined, renderer: GoRenderer): OTree {\n    return new OTree([], args ? renderer.convertAll(args) : [], {\n      separator: ', ',\n    });\n  }\n\n  public override block(node: ts.Block, renderer: GoRenderer): OTree {\n    return new OTree(['{'], renderer.convertAll(node.statements), {\n      indent: 1,\n      suffix: renderer.mirrorNewlineBefore(node.statements[0], '}'),\n    });\n  }\n\n  public override expressionStatement(node: ts.ExpressionStatement, renderer: GoRenderer): OTree {\n    const inner = renderer.convert(node.expression);\n    if (inner.isEmpty) {\n      return inner;\n    }\n    return new OTree([inner], [], { canBreakLine: true });\n  }\n\n  public override functionDeclaration(node: ts.FunctionDeclaration, renderer: GoRenderer): OTree {\n    const funcName = renderer.updateContext({ isExported: isExported(node) }).convert(node.name);\n    const returnType = determineReturnType(renderer.typeChecker, node);\n    const goType = this.renderType(node.type ?? node, returnType?.symbol, returnType, true, '', renderer);\n\n    const body = node.body?.statements ? renderer.convertAll(node.body.statements) : [];\n    return new OTree(\n      [\n        'func ',\n        funcName,\n        '(',\n        new OTree([], renderer.updateContext({ isPtr: true }).convertAll(node.parameters), {\n          separator: ', ',\n        }),\n        ')',\n        goType ? ' ' : '',\n        goType,\n      ],\n      [\n        new OTree(\n          [' {'],\n          [this.defaultArgValues(node.parameters, renderer.updateContext({ wrapPtr: true })), ...body],\n          {\n            indent: 1,\n            suffix: '\\n}',\n          },\n        ),\n      ],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override identifier(\n    node: ts.Identifier | ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: GoRenderer,\n  ) {\n    const symbol = renderer.typeChecker.getSymbolAtLocation(node);\n\n    // If the identifier corresponds to a renamed imported symbol, we need to use the original symbol name, qualified\n    // with the import package name, since Go does not allow generalized symbol aliasing (we *could* alias types, but\n    // not static functions or constructors).\n    const declaration = symbol?.valueDeclaration ?? symbol?.declarations?.[0];\n    if (declaration && ts.isImportSpecifier(declaration)) {\n      const importInfo = analyzeImportDeclaration(declaration.parent.parent.parent, renderer);\n      const packageName =\n        importInfo.moduleSymbol?.sourceAssembly?.packageJson.jsii?.targets?.go?.packageName ??\n        this.goName(importInfo.packageName, renderer, undefined);\n\n      const importedSymbol = declaration.propertyName\n        ? renderer.typeChecker.getSymbolAtLocation(declaration.propertyName)\n        : symbol;\n      // Note: imported members are (by nature) always exported by the module they are imported from.\n      return new OTree([\n        packageName,\n        '.',\n        this.goName(\n          (declaration.propertyName ?? declaration.name).text,\n          renderer.updateContext({ isExported: true }),\n          importedSymbol,\n        ),\n      ]);\n    }\n\n    return new OTree([this.goName(node.text, renderer, symbol)]);\n  }\n\n  public override newExpression(node: ts.NewExpression, renderer: GoRenderer): OTree {\n    const { classNamespace, className } = determineClassName.call(this, node.expression);\n    return new OTree(\n      [\n        ...(classNamespace ? [classNamespace, '.'] : []),\n        'New', // Should this be \"new\" if the class is unexported?\n        className,\n        '(',\n      ],\n      renderer.updateContext({ wrapPtr: true }).convertAll(node.arguments ?? []),\n      { canBreakLine: true, separator: ', ', suffix: ')' },\n    );\n\n    function determineClassName(this: GoVisitor, expr: ts.Expression): { classNamespace?: OTree; className: string } {\n      if (ts.isIdentifier(expr)) {\n        // Imported names are referred to by the original (i.e: exported) name, qualified with the source module's go\n        // package name.\n        const symbol = renderer.typeChecker.getSymbolAtLocation(expr);\n        const declaration = symbol?.valueDeclaration ?? symbol?.declarations?.[0];\n        if (declaration && ts.isImportSpecifier(declaration)) {\n          const importInfo = analyzeImportDeclaration(declaration.parent.parent.parent, renderer);\n          const packageName =\n            importInfo.moduleSymbol?.sourceAssembly?.packageJson.jsii?.targets?.go?.packageName ??\n            this.goName(importInfo.packageName, renderer, undefined);\n\n          return {\n            classNamespace: new OTree([packageName]),\n            className: this.goName(\n              (declaration.propertyName ?? declaration.name).text,\n              renderer.updateContext({ isExported: true }),\n              symbol,\n            ),\n          };\n        }\n\n        return { className: ucFirst(expr.text) };\n      }\n      if (ts.isPropertyAccessExpression(expr)) {\n        if (ts.isIdentifier(expr.expression)) {\n          return {\n            className: ucFirst(expr.name.text),\n            classNamespace: renderer.updateContext({ isExported: false }).convert(expr.expression),\n          };\n        } else if (\n          ts.isPropertyAccessExpression(expr.expression) &&\n          renderer.submoduleReferences.has(expr.expression)\n        ) {\n          const submodule = renderer.submoduleReferences.get(expr.expression)!;\n          return {\n            className: ucFirst(expr.name.text),\n            classNamespace: renderer.updateContext({ isExported: false }).convert(submodule.lastNode),\n          };\n        }\n        renderer.reportUnsupported(expr.expression, TargetLanguage.GO);\n        return {\n          className: ucFirst(expr.name.text),\n          classNamespace: new OTree(['#error#']),\n        };\n      }\n      renderer.reportUnsupported(expr, TargetLanguage.GO);\n      return { className: expr.getText(expr.getSourceFile()) };\n    }\n  }\n\n  public override arrayLiteralExpression(\n    node: ts.ArrayLiteralExpression,\n    renderer: AstRenderer<GoLanguageContext>,\n  ): OTree {\n    const arrayType =\n      inferredTypeOfExpression(renderer.typeChecker, node) ?? renderer.typeChecker.getTypeAtLocation(node);\n    const [elementType] = renderer.typeChecker.getTypeArguments(arrayType as ts.TypeReference);\n    const typeName = elementType\n      ? this.renderType(node, elementType.symbol, elementType, true, 'interface{}', renderer)\n      : 'interface{}';\n\n    return new OTree(['[]', typeName, '{'], renderer.convertAll(node.elements), {\n      separator: ',',\n      trailingSeparator: true,\n      suffix: '}',\n      indent: 1,\n    });\n  }\n\n  public override objectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: GoRenderer): OTree {\n    const lit = analyzeObjectLiteral(renderer.typeChecker, node);\n\n    switch (lit.kind) {\n      case 'unknown':\n        return this.unknownTypeObjectLiteralExpression(node, renderer);\n      case 'struct':\n      case 'local-struct':\n        return this.knownStructObjectLiteralExpression(node, lit, renderer);\n      case 'map':\n        return this.keyValueObjectLiteralExpression(node, renderer);\n    }\n  }\n\n  public override propertyAssignment(node: ts.PropertyAssignment, renderer: GoRenderer): OTree {\n    const key =\n      ts.isStringLiteralLike(node.name) || ts.isIdentifier(node.name)\n        ? renderer.currentContext.inMapLiteral\n          ? JSON.stringify(node.name.text)\n          : this.goName(node.name.text, renderer, renderer.typeChecker.getSymbolAtLocation(node.name))\n        : renderer.convert(node.name);\n    return new OTree(\n      [\n        key,\n        ': ',\n        renderer\n          .updateContext({\n            // Reset isExported, as this was intended for the key name translation...\n            isExported: undefined,\n            // Struct member values are always pointers...\n            isPtr: renderer.currentContext.isStruct,\n            wrapPtr: renderer.currentContext.isStruct || renderer.currentContext.inMapLiteral,\n          })\n          .convert(node.initializer),\n      ],\n      [],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override shorthandPropertyAssignment(\n    node: ts.ShorthandPropertyAssignment,\n    renderer: AstRenderer<GoLanguageContext>,\n  ): OTree {\n    const key =\n      ts.isStringLiteralLike(node.name) || ts.isIdentifier(node.name)\n        ? renderer.currentContext.inMapLiteral\n          ? JSON.stringify(node.name.text)\n          : this.goName(node.name.text, renderer, renderer.typeChecker.getSymbolAtLocation(node.name))\n        : renderer.convert(node.name);\n\n    const rawValue = renderer.updateContext({ wrapPtr: true, isStruct: false }).convert(node.name);\n    const value = isPointerValue(renderer.typeChecker, node.name)\n      ? rawValue\n      : wrapPtrExpression(renderer.typeChecker, node.name, rawValue);\n\n    return new OTree([key, ': ', value], [], { canBreakLine: true });\n  }\n\n  public override templateExpression(node: ts.TemplateExpression, renderer: AstRenderer<GoLanguageContext>): OTree {\n    let template = '';\n    const parameters = new Array<OTree>();\n\n    if (node.head.rawText) {\n      template += node.head.rawText;\n    }\n\n    for (const span of node.templateSpans) {\n      template += '%v';\n      parameters.push(renderer.convert(span.expression));\n      if (span.literal.rawText) {\n        template += span.literal.rawText;\n      }\n    }\n\n    if (parameters.length === 0) {\n      return new OTree([JSON.stringify(template)]);\n    }\n\n    return new OTree(\n      ['fmt.Sprintf('],\n      [\n        JSON.stringify(template),\n        ...parameters.reduce((list, element) => list.concat(', ', element), new Array<string | OTree>()),\n      ],\n      {\n        canBreakLine: true,\n        suffix: ')',\n      },\n    );\n  }\n\n  public override token<A extends ts.SyntaxKind>(node: ts.Token<A>, renderer: GoRenderer): OTree {\n    switch (node.kind) {\n      case ts.SyntaxKind.FalseKeyword:\n      case ts.SyntaxKind.TrueKeyword:\n        if (renderer.currentContext.wrapPtr) {\n          return new OTree(['jsii.Boolean(', node.getText(), ')']);\n        }\n        return new OTree([node.getText()]);\n\n      case ts.SyntaxKind.NullKeyword:\n      case ts.SyntaxKind.UndefinedKeyword:\n        return new OTree(['nil']);\n      default:\n        return super.token(node, renderer);\n    }\n  }\n\n  public override unknownTypeObjectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: GoRenderer): OTree {\n    return this.keyValueObjectLiteralExpression(node, renderer);\n  }\n\n  public override keyValueObjectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: GoRenderer): OTree {\n    const valueType = inferMapElementType(node.properties, renderer.typeChecker);\n\n    return new OTree(\n      [`map[string]`, this.renderType(node, valueType?.symbol, valueType, true, `interface{}`, renderer), `{`],\n      renderer.updateContext({ inMapLiteral: true, wrapPtr: true }).convertAll(node.properties),\n      {\n        suffix: '}',\n        separator: ',',\n        trailingSeparator: true,\n        indent: 1,\n      },\n    );\n  }\n\n  public override knownStructObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    structType: ObjectLiteralStruct,\n    renderer: GoRenderer,\n  ): OTree {\n    const exported = structType.kind === 'struct';\n    return new OTree(\n      [\n        '&',\n        this.goName(\n          structType.type.symbol.name,\n          renderer.updateContext({ isExported: exported, isPtr: false }),\n          structType.type.symbol,\n        ),\n        '{',\n      ],\n      renderer.updateContext({ isExported: exported, isStruct: true }).convertAll(node.properties),\n      {\n        suffix: '}',\n        separator: ',',\n        trailingSeparator: true,\n        indent: 1,\n      },\n    );\n  }\n\n  public override asExpression(node: ts.AsExpression, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const jsiiType = determineJsiiType(renderer.typeChecker, renderer.typeChecker.getTypeFromTypeNode(node.type));\n    switch (jsiiType.kind) {\n      case 'builtIn':\n        switch (jsiiType.builtIn) {\n          case 'boolean':\n            return new OTree(['bool(', renderer.convert(node.expression), ')'], [], { canBreakLine: true });\n          case 'number':\n            return new OTree(['f64(', renderer.convert(node.expression), ')'], [], { canBreakLine: true });\n          case 'string':\n            return new OTree(['string(', renderer.convert(node.expression), ')'], [], { canBreakLine: true });\n          case 'any':\n          case 'void':\n            // Just return the value as-is... Everything is compatible with `interface{}`.\n            return renderer.convert(node.expression);\n        }\n        // To make linter understand there is no fall-through here...\n        throw new AssertionError({ message: 'unreachable' });\n      default:\n        return new OTree(\n          [renderer.convert(node.expression), '.(', this.renderTypeNode(node.type, false, renderer), ')'],\n          [],\n          { canBreakLine: true },\n        );\n    }\n  }\n\n  public override parameterDeclaration(node: ts.ParameterDeclaration, renderer: GoRenderer): OTree {\n    const nodeName = renderer.updateContext({ isParameterName: true, isPtr: false }).convert(node.name);\n    const nodeType = node.dotDotDotToken ? (node.type as ts.ArrayTypeNode | undefined)?.elementType : node.type;\n    const typeNode = this.renderTypeNode(nodeType, true, renderer);\n    return new OTree([...(node.dotDotDotToken ? ['...'] : []), nodeName, ' ', typeNode]);\n  }\n\n  public override printStatement(args: ts.NodeArray<ts.Expression>, renderer: GoRenderer): OTree {\n    const renderedArgs = this.argumentList(args, renderer);\n    return new OTree(['fmt.Println(', renderedArgs, ')']);\n  }\n\n  public override propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    renderer: GoRenderer,\n    submoduleReference?: SubmoduleReference,\n  ): OTree {\n    if (submoduleReference != null) {\n      return new OTree([\n        renderer\n          .updateContext({ isExported: false, isPtr: false, wrapPtr: false })\n          .convert(submoduleReference.lastNode),\n      ]);\n    }\n\n    const expressionType = typeOfExpression(renderer.typeChecker, node.expression);\n    const valueSymbol = renderer.typeChecker.getSymbolAtLocation(node.name);\n\n    const isStaticMember = valueSymbol?.valueDeclaration != null && isStatic(valueSymbol.valueDeclaration);\n    const isClassStaticPropertyAccess =\n      isStaticMember &&\n      expressionType?.symbol?.valueDeclaration != null &&\n      valueSymbol.valueDeclaration != null &&\n      ts.isClassDeclaration(expressionType.symbol.valueDeclaration) &&\n      (ts.isPropertyDeclaration(valueSymbol.valueDeclaration) || ts.isAccessor(valueSymbol.valueDeclaration));\n    const isClassStaticMethodAccess =\n      isStaticMember &&\n      !isClassStaticPropertyAccess &&\n      valueSymbol.valueDeclaration != null &&\n      ts.isMethodDeclaration(valueSymbol.valueDeclaration);\n\n    // When the expression has an unknown type (unresolved symbol), has an upper-case first letter,\n    // and doesn't end in a call expression (as hinted by the presence of parentheses), we assume\n    // it's a type name... In such cases, what comes after can be considered a static member access.\n    // Note that the expression might be further qualified, so we check using a regex that checks\n    // for the last \".\" - delimited segment if there's dots in there...\n    const expressionLooksLikeTypeReference =\n      expressionType.symbol == null &&\n      /(?:\\.|^)[A-Z][^.)]*$/.exec(node.expression.getText(node.expression.getSourceFile())) != null;\n\n    // Whether the node is an enum member reference.\n    const isEnumMember =\n      expressionType?.symbol?.valueDeclaration != null && ts.isEnumDeclaration(expressionType.symbol.valueDeclaration);\n\n    const jsiiSymbol = lookupJsiiSymbolFromNode(renderer.typeChecker, node.name);\n    const isExportedTypeName = jsiiSymbol != null && jsiiSymbol.symbolType !== 'module';\n\n    const delimiter =\n      isEnumMember || isClassStaticPropertyAccess || isClassStaticMethodAccess || expressionLooksLikeTypeReference\n        ? '_'\n        : '.';\n\n    return new OTree([\n      renderer.convert(node.expression),\n      delimiter,\n      renderer\n        .updateContext({\n          isExported:\n            isClassStaticPropertyAccess ||\n            isClassStaticMethodAccess ||\n            expressionLooksLikeTypeReference ||\n            isEnumMember ||\n            isExportedTypeName,\n        })\n        .convert(node.name),\n      ...(isClassStaticPropertyAccess\n        ? ['()']\n        : // If the parent's not a call-like expression, and it's an inferred static property access, we need to put call\n        // parentheses at the end, as static properties are accessed via synthetic readers.\n        expressionLooksLikeTypeReference && findUp(node, ts.isCallLikeExpression) == null\n        ? ['()']\n        : []),\n    ]);\n  }\n\n  public override methodSignature(node: ts.MethodSignature, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const type = this.renderTypeNode(node.type, true, renderer);\n    return new OTree(\n      [\n        renderer.updateContext({ isExported: renderer.currentContext.isExported && isPublic(node) }).convert(node.name),\n        '(',\n      ],\n      renderer.convertAll(node.parameters),\n      { suffix: `) ${type}`, canBreakLine: true },\n    );\n  }\n\n  public override propertyDeclaration(node: ts.PropertyDeclaration, renderer: AstRenderer<GoLanguageContext>): OTree {\n    return new OTree(\n      [\n        renderer\n          .updateContext({ isExported: (renderer.currentContext.isExported && isPublic(node)) || isStatic(node) })\n          .convert(node.name),\n        ' ',\n        this.renderTypeNode(node.type, true, renderer),\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override propertySignature(node: ts.PropertySignature, renderer: GoRenderer): OTree {\n    if (renderer.currentContext.isInterface) {\n      const type = this.renderTypeNode(node.type, true, renderer);\n      const getter = new OTree([\n        renderer.updateContext({ isExported: renderer.currentContext.isExported && isPublic(node) }).convert(node.name),\n        '() ',\n        type,\n      ]);\n      if (isReadOnly(node)) {\n        return getter;\n      }\n      const setter = new OTree([\n        '\\n',\n        renderer.currentContext.isExported && isPublic(node) ? 'Set' : 'set',\n        renderer.updateContext({ isExported: true }).convert(node.name),\n        '(value ',\n        type,\n        ')',\n      ]);\n      return new OTree([getter, setter]);\n    }\n\n    return new OTree([\n      '\\n',\n      renderer.updateContext({ isExported: renderer.currentContext.isExported && isPublic(node) }).convert(node.name),\n      ' ',\n      this.renderTypeNode(node.type, renderer.currentContext.isPtr, renderer),\n    ]);\n  }\n\n  public override regularCallExpression(node: ts.CallExpression, renderer: GoRenderer): OTree {\n    return new OTree([\n      renderer.convert(node.expression),\n      '(',\n      this.argumentList(node.arguments, renderer.updateContext({ wrapPtr: true })),\n      ')',\n    ]);\n  }\n\n  public override returnStatement(node: ts.ReturnStatement, renderer: AstRenderer<GoLanguageContext>): OTree {\n    return new OTree(['return ', renderer.updateContext({ wrapPtr: true }).convert(node.expression)], [], {\n      canBreakLine: true,\n    });\n  }\n\n  public override binaryExpression(node: ts.BinaryExpression, renderer: AstRenderer<GoLanguageContext>): OTree {\n    if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n      const symbol = symbolFor(renderer.typeChecker, node.left);\n      return new OTree([\n        renderer.convert(node.left),\n        ' = ',\n        renderer\n          .updateContext({\n            isPtrAssignmentRValue:\n              symbol?.valueDeclaration &&\n              (ts.isParameter(symbol.valueDeclaration) || ts.isPropertyDeclaration(symbol.valueDeclaration)),\n          })\n          .convert(node.right),\n      ]);\n    }\n\n    const output = super.binaryExpression(node, renderer.updateContext({ wrapPtr: false, isPtr: false }));\n    if (!renderer.currentContext.wrapPtr) {\n      return output;\n    }\n    return wrapPtrExpression(renderer.typeChecker, node, output);\n  }\n\n  public override stringLiteral(\n    node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: GoRenderer,\n  ): OTree {\n    // Go supports backtick-delimited multi-line string literals, similar/same as JavaScript no-substitution templates.\n    // We only use this trick if the literal includes actual new line characters (otherwise it just looks weird in go).\n    const text =\n      ts.isNoSubstitutionTemplateLiteral(node) && /[\\n\\r]/m.test(node.text)\n        ? node.getText(node.getSourceFile())\n        : JSON.stringify(node.text);\n\n    return new OTree([`${renderer.currentContext.wrapPtr ? jsiiStr(text) : text}`]);\n  }\n\n  public override numericLiteral(node: ts.NumericLiteral, renderer: GoRenderer): OTree {\n    const text = `${node.text}`;\n\n    return new OTree([`${renderer.currentContext.wrapPtr ? jsiiNum(text) : text}`]);\n  }\n\n  public override classDeclaration(node: ts.ClassDeclaration, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const className = node.name\n      ? renderer.updateContext({ isExported: isExported(node) }).convert(node.name)\n      : 'anonymous';\n\n    const extendsClause = node.heritageClauses?.find((clause) => clause.token === ts.SyntaxKind.ExtendsKeyword);\n    const base = extendsClause && this.renderTypeNode(extendsClause.types[0], false, renderer);\n\n    const properties = node.members\n      .filter(ts.isPropertyDeclaration)\n      .map((prop) => renderer.updateContext({ isStruct: true, isPtr: true }).convert(prop));\n\n    const struct = new OTree(['type ', className, ' struct {'], [...(base ? ['\\n', base] : []), ...properties], {\n      canBreakLine: true,\n      suffix: properties.length > 0 ? renderer.mirrorNewlineBefore(node.members[0], '}') : '\\n}',\n      indent: 1,\n    });\n\n    const methods = [\n      node.members.length > 0\n        ? // Ensure there is a blank line between thre struct and the first member, but don't put two if there's already\n          // one as part of the first member's leading trivia.\n          new OTree(['\\n\\n'], [], { renderOnce: `ws-${node.members[0].getFullStart()}` })\n        : '',\n      ...renderer.convertAll(\n        node.members.filter((member) => !ts.isPropertyDeclaration(member) || (isExported(node) && !isPrivate(member))),\n      ),\n    ];\n\n    return new OTree([struct], methods, { canBreakLine: true });\n  }\n\n  public override structInterfaceDeclaration(node: ts.InterfaceDeclaration, renderer: GoRenderer): OTree {\n    const bases =\n      node.heritageClauses?.flatMap((hc) => hc.types).map((t) => this.renderTypeNode(t, false, renderer)) ?? [];\n    return new OTree(\n      ['type ', renderer.updateContext({ isStruct: true }).convert(node.name), ' struct {'],\n      [...bases, ...renderer.updateContext({ isStruct: true, isPtr: true }).convertAll(node.members)],\n      { indent: 1, canBreakLine: true, separator: '\\n', trailingSeparator: true, suffix: '}' },\n    );\n  }\n\n  public override regularInterfaceDeclaration(\n    node: ts.InterfaceDeclaration,\n    renderer: AstRenderer<GoLanguageContext>,\n  ): OTree {\n    if (node.members.length === 0) {\n      // Erase empty interfaces as they have no bearing in Go\n      return new OTree([]);\n    }\n\n    const symbol = renderer.typeChecker.getSymbolAtLocation(node.name);\n    const name = this.goName(node.name.text, renderer.updateContext({ isExported: isExported(node) }), symbol);\n    return new OTree(\n      [`type ${name} interface {`],\n      renderer.updateContext({ isInterface: true, isExported: isExported(node) }).convertAll(node.members),\n      { indent: 1, canBreakLine: true, separator: '\\n', trailingSeparator: true, suffix: '}' },\n    );\n  }\n\n  public override constructorDeclaration(\n    node: ts.ConstructorDeclaration,\n    renderer: AstRenderer<GoLanguageContext>,\n  ): OTree {\n    const className = node.parent.name\n      ? this.goName(\n          node.parent.name.text,\n          renderer.updateContext({ isExported: isExported(node.parent) }),\n          renderer.typeChecker.getSymbolAtLocation(node.parent.name),\n        )\n      : 'anonymous';\n\n    const defaultArgValues = this.defaultArgValues(node.parameters, renderer);\n\n    return new OTree(\n      [\n        'func ',\n        isExported(node.parent) ? 'New' : 'new',\n        ucFirst(className),\n        '(',\n        new OTree([], renderer.convertAll(node.parameters), { separator: ', ' }),\n        ') *',\n        className,\n        ' {',\n        new OTree([], [defaultArgValues, '\\nthis := &', className, '{}'], {\n          indent: 1,\n        }),\n      ],\n      node.body ? renderer.convertAll(node.body.statements) : [],\n      { canBreakLine: true, suffix: '\\n\\treturn this\\n}', indent: 1 },\n    );\n  }\n\n  public override superCallExpression(node: ts.CallExpression, renderer: AstRenderer<GoLanguageContext>): OTree {\n    // We're on a `super` call, so we must be extending a base class.\n    const base = findUp(node, ts.isConstructorDeclaration)!.parent.heritageClauses!.find(\n      (clause) => clause.token === ts.SyntaxKind.ExtendsKeyword,\n    )!.types[0].expression;\n    const baseConstructor = ts.isPropertyAccessExpression(base)\n      ? new OTree([\n          renderer.convert(base.expression),\n          '.New',\n          ucFirst(this.goName(base.name.text, renderer, renderer.typeChecker.getSymbolAtLocation(base.name))),\n        ])\n      : ts.isIdentifier(base)\n      ? `new${ucFirst(this.goName(base.text, renderer, renderer.typeChecker.getSymbolAtLocation(base)))}`\n      : (function () {\n          renderer.reportUnsupported(node, TargetLanguage.GO);\n          return renderer.convert(base);\n        })();\n\n    return new OTree(\n      [\n        baseConstructor,\n        '_Override(this, ',\n        this.argumentList(node.arguments, renderer.updateContext({ wrapPtr: true, isPtr: true })),\n        ')',\n      ],\n      [],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override methodDeclaration(node: ts.MethodDeclaration, renderer: AstRenderer<GoLanguageContext>): OTree {\n    if (ts.isObjectLiteralExpression(node.parent)) {\n      return super.methodDeclaration(node, renderer);\n    }\n\n    const className = node.parent.name\n      ? this.goName(\n          node.parent.name.text,\n          renderer.updateContext({ isExported: isExported(node.parent) }),\n          renderer.typeChecker.getSymbolAtLocation(node.parent.name),\n        )\n      : 'anonymous';\n\n    const returnType = determineReturnType(renderer.typeChecker, node);\n    const goReturnType =\n      returnType && this.renderType(node.type ?? node, returnType.symbol, returnType, true, 'interface{}', renderer);\n\n    return new OTree(\n      [\n        'func (this *',\n        className,\n        ') ',\n        renderer.updateContext({ isExported: renderer.currentContext.isExported && isPublic(node) }).convert(node.name),\n        '(',\n        new OTree([], renderer.convertAll(node.parameters), { separator: ', ' }),\n        ') ',\n        goReturnType,\n        goReturnType ? ' ' : '',\n        '{',\n      ],\n      [\n        this.defaultArgValues(node.parameters, renderer),\n        ...(node.body ? renderer.convertAll(node.body.statements) : []),\n      ],\n      { canBreakLine: true, suffix: node.body && node.body.statements.length > 0 ? '\\n}' : '}', indent: 1 },\n    );\n  }\n\n  public override ifStatement(node: ts.IfStatement, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const [ifPrefix, ifSuffix, ifIndent] = ts.isBlock(node.thenStatement) ? [' '] : [' {\\n', '\\n}', 1];\n    const ifStmt = new OTree(\n      ['if ', renderer.convert(node.expression)],\n      [ifPrefix, renderer.convert(node.thenStatement)],\n      {\n        canBreakLine: true,\n        suffix: ifSuffix,\n        indent: ifIndent,\n      },\n    );\n    if (!node.elseStatement) {\n      return ifStmt;\n    }\n\n    const [elsePrefix, elseSuffix, elseIndent] = ts.isBlock(node.elseStatement) ? [' '] : [' {\\n', '\\n}', 1];\n    const elseStmt = new OTree(['else'], [elsePrefix, renderer.convert(node.elseStatement)], {\n      canBreakLine: true,\n      suffix: elseSuffix,\n      indent: elseIndent,\n    });\n\n    return new OTree([], [ifStmt, elseStmt], {\n      separator: ' ',\n      canBreakLine: true,\n    });\n  }\n\n  public override forOfStatement(node: ts.ForOfStatement, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const [prefix, suffix, indent] = ts.isBlock(node.statement) ? [' '] : [' {\\n', '\\n}', 1];\n    return new OTree(\n      ['for _, ', nameOf(node.initializer), ' := range ', renderer.convert(node.expression)],\n      [prefix, renderer.convert(node.statement)],\n      { canBreakLine: true, suffix, indent },\n    );\n\n    function nameOf(decl: ts.ForInitializer | ts.Declaration): string | OTree {\n      if (ts.isVariableDeclarationList(decl)) {\n        if (decl.declarations.length !== 1) {\n          renderer.reportUnsupported(decl.declarations[1], TargetLanguage.GO);\n        }\n        return nameOf(decl.declarations[0]);\n      }\n      if (ts.isVariableDeclaration(decl)) {\n        return decl.name.getText(decl.name.getSourceFile());\n      }\n      renderer.reportUnsupported(decl, TargetLanguage.GO);\n      return renderer.convert(decl);\n    }\n  }\n\n  public override importStatement(node: ImportStatement, renderer: AstRenderer<GoLanguageContext>): OTree {\n    const packageName =\n      node.moduleSymbol?.sourceAssembly?.packageJson.jsii?.targets?.go?.packageName ??\n      node.packageName\n        // Special case namespaced npm package names, so they are mangled the same way pacmak does.\n        .replace(/@([a-z0-9_-]+)\\/([a-z0-9_-])/, '$1$2')\n        .split('/')\n        .map((txt) => this.goName(txt, renderer, undefined))\n        .filter((txt) => txt !== '')\n        .join('/');\n    const moduleName = node.moduleSymbol?.sourceAssembly?.packageJson.jsii?.targets?.go?.moduleName\n      ? `${node.moduleSymbol.sourceAssembly.packageJson.jsii.targets.go.moduleName}/${packageName}`\n      : `github.com/aws-samples/dummy/${packageName}`;\n\n    if (node.imports.import === 'full') {\n      // We don't emit the alias if it matches the last path segment (conventionally this is the package name)\n      const maybeAlias = node.imports.alias ? `${this.goName(node.imports.alias, renderer, undefined)} ` : '';\n\n      return new OTree([`import ${maybeAlias}${JSON.stringify(moduleName)}`], undefined, { canBreakLine: true });\n    }\n\n    if (node.imports.elements.length === 0) {\n      // This is a blank import (for side-effects only)\n      return new OTree([`import _ ${JSON.stringify(moduleName)}`], undefined, { canBreakLine: true });\n    }\n\n    return new OTree([`import ${JSON.stringify(moduleName)}`], undefined, { canBreakLine: true });\n  }\n\n  public override variableDeclaration(node: ts.VariableDeclaration, renderer: AstRenderer<GoLanguageContext>): OTree {\n    if (!node.initializer) {\n      return new OTree([\n        'var ',\n        renderer.updateContext({ isExported: isExported(node) }).convert(node.name),\n        ' ',\n        this.renderTypeNode(node.type, false, renderer) || 'interface{}',\n      ]);\n    }\n\n    return new OTree([\n      renderer.updateContext({ isExported: false }).convert(node.name),\n      ' := ',\n      renderer.convert(node.initializer),\n    ]);\n  }\n\n  private defaultArgValues(params: ts.NodeArray<ts.ParameterDeclaration>, renderer: GoRenderer) {\n    return new OTree(\n      params.reduce((accum: OTree[], param) => {\n        if (!param.initializer) {\n          return accum;\n        }\n\n        const name = renderer.updateContext({ isPtr: true }).convert(param.name);\n        return [\n          ...accum,\n          new OTree(\n            ['\\n', 'if ', name, ' == nil {'],\n            ['\\n', name, ' = ', renderer.updateContext({ wrapPtr: true }).convert(param.initializer)],\n            {\n              indent: 1,\n              suffix: '\\n}',\n            },\n          ),\n        ];\n      }, []),\n    );\n  }\n\n  public mergeContext(old: GoLanguageContext, update: Partial<GoLanguageContext>): GoLanguageContext {\n    return Object.assign({}, old, update);\n  }\n\n  private renderTypeNode(typeNode: ts.TypeNode | undefined, isPtr: boolean, renderer: GoRenderer): string {\n    if (!typeNode) {\n      return '';\n    }\n    return this.renderType(\n      typeNode,\n      renderer.typeChecker.getTypeFromTypeNode(typeNode).symbol,\n      renderer.typeOfType(typeNode),\n      isPtr,\n      renderer.textOf(typeNode),\n      renderer,\n    );\n  }\n\n  private renderType(\n    typeNode: ts.Node,\n    typeSymbol: ts.Symbol | undefined,\n    type: ts.Type | undefined,\n    isPtr: boolean,\n    fallback: string,\n    renderer: GoRenderer,\n  ): string {\n    if (type === undefined) {\n      return fallback;\n    }\n\n    const jsiiType = determineJsiiType(renderer.typeChecker, type);\n\n    const doRender = (jType: JsiiType, asPtr: boolean, typeSym: ts.Symbol | undefined): string => {\n      const prefix = asPtr ? '*' : '';\n      switch (jType.kind) {\n        case 'unknown':\n          return fallback;\n        case 'error':\n          renderer.report(typeNode, jType.message);\n          return fallback;\n        case 'map':\n          return `map[string]${doRender(jType.elementType, true, jType.elementTypeSymbol)}`;\n        case 'list':\n          return `[]${doRender(jType.elementType, true, jType.elementTypeSymbol)}`;\n        case 'namedType':\n          return this.goName(jType.name, renderer, typeSym);\n        case 'builtIn':\n          switch (jType.builtIn) {\n            case 'boolean':\n              return `${prefix}bool`;\n            case 'number':\n              return `${prefix}f64`;\n            case 'string':\n              return `${prefix}string`;\n            case 'any':\n              return 'interface{}';\n            case 'void':\n              return '';\n          }\n      }\n    };\n\n    return doRender(jsiiType, isPtr, typeSymbol);\n  }\n\n  /**\n   * Guess an item's go name based on it's TS name and context\n   */\n  private goName(input: string, renderer: GoRenderer, symbol: ts.Symbol | undefined) {\n    let text = input.replace(/[^a-z0-9_]/gi, '');\n\n    // Symbols can be an index signature, if this is a dot-style access to a map member. In this\n    // case we should not cache against the symbol as this would cause all such accesses to the same\n    // object to return the same text, which would be incorrect!\n    const indexSignature = ts.SymbolFlags.Signature | ts.SymbolFlags.Transient;\n    const cacheKey = symbol != null && (symbol.flags & indexSignature) === indexSignature ? input : symbol ?? input;\n\n    const prev = this.idMap.get(cacheKey) ?? this.idMap.get(input);\n\n    if (prev) {\n      // If an identifier has been renamed go get it\n      text = prev.formatted;\n    } else if (renderer.currentContext.isExported && !renderer.currentContext.inMapLiteral) {\n      // Uppercase exported and public symbols/members\n      text = ucFirst(text);\n    } else if (!renderer.currentContext.inMapLiteral) {\n      // Lowercase unexported items that are capitalized in TS like structs/interfaces/classes\n      text = lcFirst(text);\n    }\n\n    text = prefixReserved(text);\n\n    if (text !== input && prev == null) {\n      this.idMap.set(cacheKey, { formatted: text, type: getDeclarationType(renderer.currentContext) });\n    }\n\n    if (\n      // Non-pointer references to parameters need to be de-referenced\n      (!renderer.currentContext.isPtr &&\n        !renderer.currentContext.isParameterName &&\n        symbol?.valueDeclaration?.kind === ts.SyntaxKind.Parameter &&\n        !renderer.currentContext.isPtrAssignmentRValue) ||\n      // Pointer reference to non-interfaces are prefixed with *\n      (renderer.currentContext.isPtr && prev && prev?.type !== DeclarationType.INTERFACE)\n    ) {\n      return `*${text}`;\n    }\n    return text;\n  }\n}\n\n/**\n * Uppercase the first letter\n */\nfunction ucFirst(x: string) {\n  return x.substring(0, 1).toUpperCase() + x.substring(1);\n}\n\n/**\n * Lowercase the first letter\n */\nfunction lcFirst(x: string) {\n  return x.substring(0, 1).toLowerCase() + x.substring(1);\n}\n\nfunction wrapPtrExpression(typeChecker: ts.TypeChecker, node: ts.Expression, unwrapped: OTree): OTree {\n  const type = typeOfExpression(typeChecker, node);\n  const jsiiType = determineJsiiType(typeChecker, type);\n  if (jsiiType.kind !== 'builtIn') {\n    return unwrapped;\n  }\n  switch (jsiiType.builtIn) {\n    case 'boolean':\n      return new OTree(['jsii.Boolean(', unwrapped, ')']);\n    case 'number':\n      return new OTree(['jsii.Number(', unwrapped, ')']);\n    case 'string':\n      return new OTree(['jsii.String(', unwrapped, ')']);\n    case 'any':\n    case 'void':\n      return unwrapped;\n  }\n}\n\n/**\n * Wrap a string literal in the jsii.String helper\n */\nfunction jsiiStr(x: string) {\n  return `jsii.String(${x})`;\n}\n\n/**\n * Wrap a string literal in the jsii.String helper\n */\nfunction jsiiNum(x: string) {\n  return `jsii.Number(${x})`;\n}\n\n/**\n * Prefix reserved word identifiers with _\n */\nfunction prefixReserved(x: string) {\n  if (['struct'].includes(x)) {\n    return `${x}_`;\n  }\n  return x;\n}\n\nfunction getDeclarationType(ctx: GoLanguageContext) {\n  if (ctx.isStruct) {\n    return DeclarationType.STRUCT;\n  }\n\n  return DeclarationType.UNKNOWN;\n}\n\nfunction findUp<T extends ts.Node>(node: ts.Node, predicate: (node: ts.Node) => node is T): T | undefined {\n  if (predicate(node)) {\n    return node;\n  }\n  if (node.parent == null) {\n    return undefined;\n  }\n  return findUp(node.parent, predicate);\n}\n\nfunction symbolFor(typeChecker: ts.TypeChecker, node: ts.Node): ts.Symbol | undefined {\n  if (ts.isIdentifier(node)) {\n    return typeChecker.getSymbolAtLocation(node);\n  }\n  if (ts.isPropertyAccessExpression(node)) {\n    return typeChecker.getSymbolAtLocation(node.name);\n  }\n  // I don't know \n  return undefined;\n}\n\n/**\n * Checks whether the provided node corresponds to a pointer-value.\n *\n * NOTE: This currently only checkes for parameter declarations. This is\n * presently used only to determine whether a variable reference needs to be\n * wrapped or not (i.e: \"jsii.String(varStr)\"), and parameter references are the\n * only \"always pointer\" values possible in that particular context.\n *\n * @param typeChecker a TypeChecker to use to resolve the node's symbol.\n * @param node        the node to be checked.\n *\n * @returns true if the node corresponds to a pointer-value.\n */\nfunction isPointerValue(typeChecker: ts.TypeChecker, node: ts.Node): boolean {\n  const symbol = typeChecker.getSymbolAtLocation(node);\n  if (symbol == null) {\n    // Can't find symbol, assuming it's a pointer...\n    return true;\n  }\n\n  const declaration = symbol.valueDeclaration;\n  if (declaration == null) {\n    // Doesn't have declaration, assuming it's a pointer...\n    return true;\n  }\n\n  // Now check if this is known pointer kind or not....\n  return ts.isParameter(node);\n}\n"]}