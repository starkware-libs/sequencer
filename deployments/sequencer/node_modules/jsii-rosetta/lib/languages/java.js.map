{"version":3,"file":"java.js","sourceRoot":"","sources":["../../src/languages/java.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { DefaultVisitor } from './default';\nimport { determineJsiiType, JsiiType, analyzeObjectLiteral, ObjectLiteralStruct } from '../jsii/jsii-types';\nimport { JsiiSymbol, simpleName, namespaceName } from '../jsii/jsii-utils';\nimport { jsiiTargetParameter } from '../jsii/packages';\nimport { TargetLanguage } from '../languages/target-language';\nimport { OTree, NO_SYNTAX } from '../o-tree';\nimport { AstRenderer } from '../renderer';\nimport { SubmoduleReference } from '../submodule-reference';\nimport { isReadOnly, matchAst, nodeOfType, quoteStringLiteral, visibility } from '../typescript/ast-utils';\nimport { ImportStatement } from '../typescript/imports';\nimport { isEnumAccess, isStaticReadonlyAccess, determineReturnType } from '../typescript/types';\nimport { fmap, setExtend } from '../util';\n\ninterface JavaContext {\n  /**\n   * Whether to ignore the left-hand part of a property access expression.\n   *\n   * Used to strip out TypeScript namespace prefixes from 'extends' and 'new' clauses,\n   * EVEN if the source doesn't compile.\n   *\n   * @default false\n   */\n  readonly discardPropertyAccess?: boolean;\n\n  /**\n   * Whether a property access ('sth.b') should be substituted by a getter ('sth.getB()').\n   * Not true for 'new' expressions and calls to methods on objects.\n   *\n   * @default true\n   */\n  readonly convertPropertyToGetter?: boolean;\n\n  /**\n   * Set when we are in the middle translating a type (= class, interface or enum) declaration.\n   */\n  readonly insideTypeDeclaration?: InsideTypeDeclaration;\n\n  /**\n   * True if we are in the middle of a `new` expression that has an object literal as its last argument -\n   * in that case, we render a ClassName.Builder.create(...).prop(...).build() expression instead.\n   *\n   * @default false\n   */\n  readonly inNewExprWithObjectLiteralAsLastArg?: boolean;\n\n  /**\n   * True when, from the context,\n   * we are supposed to render a JavaScript object literal as a Map in Java.\n   *\n   * @default false\n   */\n  readonly inKeyValueList?: boolean;\n\n  /**\n   * Used when rendering a JavaScript object literal that is _not_ for a struct -\n   * we render that as a Map in Java.\n   *\n   * @default false\n   */\n  readonly identifierAsString?: boolean;\n\n  /**\n   * Used when rendering a JavaScript object literal that is for a struct -\n   * maps to a Builder in Java.\n   *\n   * @default false\n   */\n  readonly stringLiteralAsIdentifier?: boolean;\n\n  /**\n   * Used to denote that a type is being rendered in a position where a generic\n   * type parameter is expected, so only reference types are valid (not\n   * primitives).\n   *\n   * @default false\n   */\n  readonly requiresReferenceType?: boolean;\n}\n\n/**\n * Values saved when we are translating a type declaration.\n */\ninterface InsideTypeDeclaration {\n  /**\n   * The name of the type.\n   * Needed to correctly generate the constructor.\n   */\n  readonly typeName: ts.Node | undefined;\n\n  /**\n   * Is this an interface (true) or a class (unset/false)\n   */\n  readonly isInterface?: boolean;\n}\n\ntype JavaRenderer = AstRenderer<JavaContext>;\n\nexport class JavaVisitor extends DefaultVisitor<JavaContext> {\n  /**\n   * Translation version\n   *\n   * Bump this when you change something in the implementation to invalidate\n   * existing cached translations.\n   */\n  public static readonly VERSION = '1';\n\n  /**\n   * Aliases for modules\n   *\n   * If these are encountered in the LHS of a property access, they will be dropped.\n   */\n  private readonly dropPropertyAccesses = new Set<string>();\n\n  public readonly language = TargetLanguage.JAVA;\n  public readonly defaultContext = {};\n\n  public mergeContext(old: JavaContext, update: Partial<JavaContext>): JavaContext {\n    return Object.assign({}, old, update);\n  }\n\n  public override importStatement(importStatement: ImportStatement): OTree {\n    const guessedNamespace = guessJavaNamespaceName(importStatement.packageName);\n    if (importStatement.imports.import === 'full') {\n      this.dropPropertyAccesses.add(importStatement.imports.sourceName);\n      const namespace = fmap(importStatement.moduleSymbol, findJavaName) ?? guessedNamespace;\n\n      return new OTree([`import ${namespace}.*;`], [], { canBreakLine: true });\n    }\n\n    const imports = importStatement.imports.elements.map((e) => {\n      const fqn = fmap(e.importedSymbol, findJavaName) ?? `${guessedNamespace}.${e.sourceName}`;\n\n      // If there is no imported symbol, we check if there is anything looking like a type name in\n      // the source name (that is, any segment that starts with an upper case letter), and if none\n      // is found, assume this refers to a namespace/module.\n      return (e.importedSymbol?.symbolType == null &&\n        !e.sourceName.split('.').some((segment) => /^[A-Z]/.test(segment))) ||\n        e.importedSymbol?.symbolType === 'module'\n        ? `import ${fqn}.*;`\n        : `import ${fqn};`;\n    });\n\n    const localNames = importStatement.imports.elements\n      .filter((el) => el.importedSymbol?.symbolType === 'module')\n      .map((el) => el.alias ?? el.sourceName);\n    setExtend(this.dropPropertyAccesses, localNames);\n\n    return new OTree([], imports, { canBreakLine: true, separator: '\\n' });\n  }\n\n  public override classDeclaration(node: ts.ClassDeclaration, renderer: JavaRenderer): OTree {\n    return this.renderClassDeclaration(node, renderer);\n  }\n\n  public override structInterfaceDeclaration(node: ts.InterfaceDeclaration, renderer: JavaRenderer): OTree {\n    // Render structs as simple Java classes with getters, and setters that return `this`.\n    // This is a compromise between brevity\n    // (rendering a full inner static Builder class, like JSII uses, would be quite verbose)\n    // and ease of use\n    // (fluent setters allow us to mirror JavaScript object literals more closely than classic,\n    // void-returning setters would).\n\n    return this.renderClassDeclaration(node, renderer);\n  }\n\n  public override regularInterfaceDeclaration(node: ts.InterfaceDeclaration, renderer: JavaRenderer): OTree {\n    return new OTree(\n      [\n        'public ',\n        'interface ',\n        renderer.convert(node.name),\n        ...this.typeHeritage(node, renderer.updateContext({ discardPropertyAccess: true })),\n        ' {',\n      ],\n      renderer\n        .updateContext({\n          insideTypeDeclaration: { typeName: node.name, isInterface: true },\n        })\n        .convertAll(node.members),\n      {\n        indent: 4,\n        canBreakLine: true,\n        suffix: '\\n}',\n      },\n    );\n  }\n\n  public override propertySignature(node: ts.PropertySignature, renderer: JavaRenderer): OTree {\n    const propertyType = this.renderTypeNode(node.type, renderer, 'Object');\n    const propertyName = renderer.convert(node.name);\n\n    const isClass = !renderer.currentContext.insideTypeDeclaration?.isInterface;\n    const blockSep = isClass ? ' ' : ';';\n\n    const field = isClass\n      ? new OTree([], ['private ', propertyType, ' ', propertyName, ';'], {\n          canBreakLine: true,\n        })\n      : NO_SYNTAX;\n\n    const getter = new OTree(\n      [],\n      [\n        isClass ? 'public ' : NO_SYNTAX,\n        propertyType,\n        ' ',\n        `get${capitalize(renderer.textOf(node.name))}()${blockSep}`,\n        isClass ? this.renderBlock([new OTree(['\\n'], ['return this.', propertyName, ';'])]) : NO_SYNTAX,\n      ],\n      {\n        canBreakLine: true,\n      },\n    );\n\n    const hasSetter = isClass || !isReadOnly(node);\n\n    const setter = hasSetter\n      ? new OTree(\n          [],\n          [\n            isClass ? 'public ' : NO_SYNTAX,\n            renderer.convert(renderer.currentContext.insideTypeDeclaration!.typeName),\n            ' ',\n            propertyName, // don't prefix the setter with `set` - makes it more aligned with JSII builders\n            '(',\n            propertyType,\n            ' ',\n            propertyName,\n            `)${blockSep}`,\n            isClass\n              ? this.renderBlock([\n                  new OTree(['\\n'], ['this.', propertyName, ' = ', propertyName, ';']),\n                  new OTree(['\\n'], ['return this;']),\n                ])\n              : NO_SYNTAX,\n          ],\n          {\n            canBreakLine: true,\n          },\n        )\n      : NO_SYNTAX;\n\n    return new OTree([], [field, getter, setter], {\n      canBreakLine: true,\n      separator: '\\n',\n    });\n  }\n\n  public override propertyDeclaration(node: ts.PropertyDeclaration, renderer: JavaRenderer): OTree {\n    const vis = visibility(node);\n\n    return new OTree(\n      [\n        vis,\n        isReadOnly(node) ? ' final' : '',\n        ' ',\n        this.renderTypeNode(node.type, renderer, 'Object'),\n        ' ',\n        renderer.convert(node.name),\n        ';',\n      ],\n      [],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override constructorDeclaration(node: ts.ConstructorDeclaration, renderer: JavaRenderer): OTree {\n    return this.renderProcedure(node, renderer, renderer.currentContext.insideTypeDeclaration!.typeName, undefined);\n  }\n\n  public override methodDeclaration(node: ts.MethodDeclaration, renderer: JavaRenderer): OTree {\n    const retType = determineReturnType(renderer.typeChecker, node);\n    return this.renderProcedure(node, renderer, node.name, this.renderType(node, retType, renderer, 'void'));\n  }\n\n  public override functionDeclaration(node: ts.FunctionDeclaration, renderer: JavaRenderer): OTree {\n    const retType = determineReturnType(renderer.typeChecker, node);\n    return this.renderProcedure(node, renderer, node.name, this.renderType(node, retType, renderer, 'void'));\n  }\n\n  public override methodSignature(node: ts.MethodSignature, renderer: JavaRenderer): OTree {\n    return new OTree(\n      [\n        this.renderTypeNode(node.type, renderer, 'void'),\n        ' ',\n        renderer.convert(node.name),\n        '(',\n        new OTree([], renderer.convertAll(node.parameters), {\n          separator: ', ',\n        }),\n        ');',\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override parameterDeclaration(node: ts.ParameterDeclaration, renderer: JavaRenderer): OTree {\n    let renderedType = this.renderTypeNode(node.type, renderer);\n    if (node.dotDotDotToken && renderedType.endsWith('[]')) {\n      // Varargs. In Java, render this as `Element...` (instead of `Element[]` which is what we'll have gotten).\n      renderedType = `${renderedType.slice(0, -2)}...`;\n    }\n\n    return new OTree([renderedType, ' ', renderer.convert(node.name)]);\n  }\n\n  public override block(node: ts.Block, renderer: JavaRenderer): OTree {\n    return this.renderBlock(renderer.convertAll(node.statements));\n  }\n\n  public override variableDeclaration(node: ts.VariableDeclaration, renderer: JavaRenderer): OTree {\n    let fallback = 'Object';\n    if (node.type) {\n      fallback = node.type.getText();\n    }\n    const type =\n      (node.type && renderer.typeOfType(node.type)) ||\n      (node.initializer && renderer.typeOfExpression(node.initializer));\n\n    const renderedType = type ? this.renderType(node, type, renderer, fallback) : fallback;\n\n    if (!node.initializer) {\n      return new OTree([renderedType, ' ', renderer.convert(node.name), ';'], []);\n    }\n\n    return new OTree(\n      [\n        renderedType,\n        ' ',\n        renderer.convert(node.name),\n        ...(node.initializer ? [' = ', renderer.convert(node.initializer)] : []),\n        ';',\n      ],\n      [],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override expressionStatement(node: ts.ExpressionStatement, renderer: JavaRenderer): OTree {\n    const inner = renderer.convert(node.expression);\n    return inner.isEmpty ? inner : new OTree([inner, ';'], [], { canBreakLine: true });\n  }\n\n  public override ifStatement(node: ts.IfStatement, renderer: JavaRenderer): OTree {\n    const ifStmt = new OTree(\n      ['if (', renderer.convert(node.expression), ') '],\n      [renderer.convert(node.thenStatement)],\n      {\n        canBreakLine: true,\n      },\n    );\n    const elseStmt = node.elseStatement\n      ? new OTree(['else '], [renderer.convert(node.elseStatement)], {\n          canBreakLine: true,\n        })\n      : undefined;\n\n    return elseStmt\n      ? new OTree([], [ifStmt, elseStmt], {\n          separator: ' ',\n          canBreakLine: true,\n        })\n      : ifStmt;\n  }\n\n  public override forOfStatement(node: ts.ForOfStatement, renderer: JavaRenderer): OTree {\n    // This is what a \"for (const x of ...)\" looks like in the AST\n    let variableName = '???';\n\n    matchAst(\n      node.initializer,\n      nodeOfType(ts.SyntaxKind.VariableDeclarationList, nodeOfType('var', ts.SyntaxKind.VariableDeclaration)),\n      (bindings) => {\n        variableName = renderer.textOf(bindings.var.name);\n      },\n    );\n\n    return new OTree(\n      ['for (Object ', variableName, ' : ', renderer.convert(node.expression), ') '],\n      [renderer.convert(node.statement)],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  public override printStatement(args: ts.NodeArray<ts.Expression>, renderer: JavaRenderer) {\n    return new OTree([\n      'System.out.println(',\n      args.length === 1 ? renderer.convert(args[0]) : new OTree([], renderer.convertAll(args), { separator: ' + ' }),\n      ')',\n    ]);\n  }\n\n  public override templateExpression(node: ts.TemplateExpression, renderer: JavaRenderer): OTree {\n    let template = '';\n    const parameters = new Array<OTree>();\n\n    if (node.head.rawText) {\n      template += node.head.rawText;\n    }\n\n    for (const span of node.templateSpans) {\n      template += '%s';\n      parameters.push(\n        renderer\n          .updateContext({\n            convertPropertyToGetter: true,\n            identifierAsString: false,\n          })\n          .convert(span.expression),\n      );\n      if (span.literal.rawText) {\n        template += span.literal.rawText;\n      }\n    }\n\n    if (parameters.length === 0) {\n      return new OTree([JSON.stringify(quoteStringLiteral(template))]);\n    }\n\n    return new OTree([\n      'String.format(',\n      `\"${quoteStringLiteral(template)\n        // Java does not have multiline string literals, so we must replace literal newlines with %n\n        .replace(/\\n/g, '%n')}\"`,\n      ...parameters.reduce((list, element) => list.concat(', ', element), new Array<string | OTree>()),\n      ')',\n    ]);\n  }\n\n  public override asExpression(node: ts.AsExpression, renderer: JavaRenderer): OTree {\n    return new OTree(['(', this.renderTypeNode(node.type, renderer, 'Object'), ')', renderer.convert(node.expression)]);\n  }\n\n  public override arrayLiteralExpression(node: ts.ArrayLiteralExpression, renderer: JavaRenderer): OTree {\n    return new OTree(['List.of('], renderer.convertAll(node.elements), {\n      separator: ', ',\n      suffix: ')',\n      indent: 4,\n    });\n  }\n\n  public override regularCallExpression(node: ts.CallExpression, renderer: JavaRenderer): OTree {\n    return new OTree([\n      renderer.updateContext({ convertPropertyToGetter: false }).convert(node.expression),\n      '(',\n      this.argumentList(node.arguments, renderer),\n      ')',\n    ]);\n  }\n\n  public override newExpression(node: ts.NewExpression, renderer: JavaRenderer): OTree {\n    const argsLength = node.arguments ? node.arguments.length : 0;\n    const lastArg = argsLength > 0 ? node.arguments![argsLength - 1] : undefined;\n\n    // We render the ClassName.Builder.create(...) expression\n    // if the last argument is an object literal, and either a known struct (because\n    // those are the jsii rules) or an unknown type (because the example didn't\n    // compile but most of the target examples will intend this to be a struct).\n\n    const structArgument = lastArg && ts.isObjectLiteralExpression(lastArg) ? lastArg : undefined;\n    let renderBuilder = false;\n    if (lastArg && ts.isObjectLiteralExpression(lastArg)) {\n      const analysis = analyzeObjectLiteral(renderer.typeChecker, lastArg);\n      renderBuilder = analysis.kind === 'struct' || analysis.kind === 'unknown';\n    }\n\n    const className = renderer\n      .updateContext({\n        discardPropertyAccess: true,\n        convertPropertyToGetter: false,\n      })\n      .convert(node.expression);\n\n    if (renderBuilder) {\n      const initialArguments = node.arguments!.slice(0, argsLength - 1);\n      return new OTree(\n        [],\n        [\n          className,\n          '.Builder.create(',\n          this.argumentList(initialArguments, renderer),\n          ')',\n          ...renderer.convertAll(structArgument!.properties),\n          new OTree([renderer.mirrorNewlineBefore(structArgument!.properties[0])], ['.build()']),\n        ],\n        { canBreakLine: true, indent: 8 },\n      );\n    }\n\n    return new OTree([], ['new ', className, '(', this.argumentList(node.arguments, renderer), ')'], {\n      canBreakLine: true,\n    });\n  }\n\n  public override unknownTypeObjectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: JavaRenderer): OTree {\n    return renderer.currentContext.inNewExprWithObjectLiteralAsLastArg\n      ? this.renderObjectLiteralAsBuilder(node, renderer)\n      : this.keyValueObjectLiteralExpression(node, renderer);\n  }\n\n  public override keyValueObjectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: JavaRenderer): OTree {\n    return new OTree(['Map.of('], renderer.updateContext({ inKeyValueList: true }).convertAll(node.properties), {\n      suffix: ')',\n      separator: ', ',\n      indent: 8,\n    });\n  }\n\n  public override knownStructObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    structType: ObjectLiteralStruct,\n    renderer: JavaRenderer,\n  ): OTree {\n    // Special case: we're rendering an object literal, but the containing constructor\n    // has already started the builder: we don't have to create a new instance,\n    // all we have to do is pile on arguments.\n    if (renderer.currentContext.inNewExprWithObjectLiteralAsLastArg) {\n      return new OTree([], renderer.convertAll(node.properties), { indent: 8 });\n    }\n\n    // Jsii-generated classes have builders, classes we generated in the course of\n    // this example do not.\n    const hasBuilder = structType.kind !== 'local-struct';\n\n    return new OTree(\n      hasBuilder ? [structType.type.symbol.name, '.builder()'] : ['new ', structType.type.symbol.name, '()'],\n      [\n        ...renderer.convertAll(node.properties),\n        new OTree([renderer.mirrorNewlineBefore(node.properties[0])], [hasBuilder ? '.build()' : '']),\n      ],\n      {\n        indent: 8,\n      },\n    );\n  }\n\n  public override propertyAssignment(node: ts.PropertyAssignment, renderer: JavaRenderer): OTree {\n    return renderer.currentContext.inKeyValueList\n      ? this.singlePropertyInJavaScriptObjectLiteralToJavaMap(node.name, node.initializer, renderer)\n      : this.singlePropertyInJavaScriptObjectLiteralToFluentSetters(node.name, node.initializer, renderer);\n  }\n\n  public override shorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, renderer: JavaRenderer): OTree {\n    return renderer.currentContext.inKeyValueList\n      ? this.singlePropertyInJavaScriptObjectLiteralToJavaMap(node.name, node.name, renderer)\n      : this.singlePropertyInJavaScriptObjectLiteralToFluentSetters(node.name, node.name, renderer);\n  }\n\n  public override propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    renderer: JavaRenderer,\n    submoduleRef: SubmoduleReference | undefined,\n  ): OTree {\n    const rightHandSide = renderer.convert(node.name);\n    // If a submodule access, then just render the name, we emitted a * import of the expression segment already.\n    if (submoduleRef != null) {\n      return rightHandSide;\n    }\n\n    let parts: Array<OTree | string | undefined>;\n\n    const leftHandSide = renderer.textOf(node.expression);\n\n    // Suppress the LHS of the dot operator if it matches an alias for a module import.\n    if (this.dropPropertyAccesses.has(leftHandSide) || renderer.currentContext.discardPropertyAccess) {\n      parts = [rightHandSide];\n    } else if (leftHandSide === 'this') {\n      // for 'this', assume this is a field, and access it directly\n      parts = ['this', '.', rightHandSide];\n    } else {\n      let convertToGetter = renderer.currentContext.convertPropertyToGetter !== false;\n\n      // See if we're not accessing an enum member or public static readonly property (const).\n      if (isEnumAccess(renderer.typeChecker, node)) {\n        convertToGetter = false;\n      }\n      if (isStaticReadonlyAccess(renderer.typeChecker, node)) {\n        convertToGetter = false;\n      }\n\n      // add a 'get' prefix to the property name, and change the access to a method call, if required\n      const renderedRightHandSide = convertToGetter ? `get${capitalize(node.name.text)}()` : rightHandSide;\n\n      // strip any trailing ! from the left-hand side, as they're not meaningful in Java\n      parts = [renderer.convert(node.expression), '.', renderedRightHandSide];\n    }\n\n    return new OTree(parts);\n  }\n\n  public override stringLiteral(\n    node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: JavaRenderer,\n  ): OTree {\n    if (renderer.currentContext.stringLiteralAsIdentifier) {\n      return this.identifier(node, renderer);\n    }\n    // Java does not have multiline string literals, so we must replace literal newlines with \\n\n    return new OTree([JSON.stringify(node.text).replace(/\\n/g, '\\\\n')]);\n  }\n\n  public override identifier(\n    node: ts.Identifier | ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: JavaRenderer,\n  ): OTree {\n    const nodeText = node.text;\n    return new OTree([renderer.currentContext.identifierAsString ? JSON.stringify(nodeText) : nodeText]);\n  }\n\n  private renderObjectLiteralAsBuilder(node: ts.ObjectLiteralExpression, renderer: JavaRenderer): OTree {\n    return new OTree(\n      [],\n      [\n        ...renderer.convertAll(node.properties),\n        new OTree([renderer.mirrorNewlineBefore(node.properties[0])], ['.build()']),\n      ],\n      {\n        indent: 8,\n      },\n    );\n  }\n\n  private singlePropertyInJavaScriptObjectLiteralToJavaMap(\n    name: ts.Node,\n    initializer: ts.Node,\n    renderer: JavaRenderer,\n  ): OTree {\n    return new OTree(\n      [],\n      [\n        renderer\n          .updateContext({\n            identifierAsString: !ts.isComputedPropertyName(name),\n          })\n          .convert(name),\n        ', ',\n        renderer.updateContext({ inKeyValueList: false }).convert(initializer),\n      ],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  private singlePropertyInJavaScriptObjectLiteralToFluentSetters(\n    name: ts.Node,\n    initializer: ts.Node,\n    renderer: JavaRenderer,\n  ): OTree {\n    return new OTree(\n      [],\n      [\n        '.',\n        renderer.updateContext({ stringLiteralAsIdentifier: true }).convert(name),\n        '(',\n        renderer.updateContext({ inNewExprWithObjectLiteralAsLastArg: false }).convert(initializer),\n        ')',\n      ],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  private renderClassDeclaration(node: ts.ClassDeclaration | ts.InterfaceDeclaration, renderer: JavaRenderer) {\n    return new OTree(\n      [\n        'public ',\n        'class ',\n        renderer.convert(node.name),\n        ...this.typeHeritage(node, renderer.updateContext({ discardPropertyAccess: true })),\n        ' {',\n      ],\n      renderer.updateContext({ insideTypeDeclaration: { typeName: node.name } }).convertAll(node.members),\n      {\n        indent: 4,\n        canBreakLine: true,\n        suffix: '\\n}',\n      },\n    );\n  }\n\n  private typeHeritage(\n    node: ts.ClassDeclaration | ts.InterfaceDeclaration,\n    renderer: JavaRenderer,\n  ): Array<OTree | string | undefined> {\n    return [\n      ...this.extractSuperTypes(node, renderer, ts.SyntaxKind.ExtendsKeyword, 'extends'),\n      ...this.extractSuperTypes(node, renderer, ts.SyntaxKind.ImplementsKeyword, 'implements'),\n    ];\n  }\n\n  private extractSuperTypes(\n    node: ts.ClassDeclaration | ts.InterfaceDeclaration,\n    renderer: JavaRenderer,\n    heritageKeyword: ts.SyntaxKind,\n    outputKeyword: string,\n  ): Array<OTree | string | undefined> {\n    const heritageClause = (node.heritageClauses ?? []).find((hc) => hc.token === heritageKeyword);\n    const superTypes = heritageClause ? heritageClause.types.map((t) => renderer.convert(t.expression)) : [];\n    return superTypes.length > 0 ? [` ${outputKeyword} `, new OTree([], superTypes, { separator: ', ' })] : [];\n  }\n\n  private renderTypeNode(typeNode: ts.TypeNode | undefined, renderer: JavaRenderer, fallback?: string): string {\n    fallback =\n      fallback ??\n      (typeNode\n        ? lastElement(renderer.textOf(typeNode).split('.')) // remove any namespace prefixes\n        : 'Object');\n\n    if (!typeNode) {\n      return fallback;\n    }\n\n    return this.renderType(typeNode, renderer.typeOfType(typeNode), renderer, fallback);\n  }\n\n  private renderType(owningNode: ts.Node, type: ts.Type | undefined, renderer: JavaRenderer, fallback: string): string {\n    if (!type) {\n      return fallback;\n    }\n\n    return doRender(determineJsiiType(renderer.typeChecker, type), false);\n\n    // eslint-disable-next-line consistent-return\n    function doRender(jsiiType: JsiiType, requiresReferenceType: boolean): string {\n      switch (jsiiType.kind) {\n        case 'unknown':\n          return fallback;\n        case 'error':\n          renderer.report(owningNode, jsiiType.message);\n          return fallback;\n        case 'map':\n          return `Map<String, ${doRender(jsiiType.elementType, true)}>`;\n        case 'list':\n          return `${doRender(jsiiType.elementType, true)}[]`;\n        case 'namedType':\n          return jsiiType.name;\n        case 'builtIn':\n          switch (jsiiType.builtIn) {\n            case 'boolean':\n              return requiresReferenceType ? 'Boolean' : 'boolean';\n            case 'number':\n              return 'Number';\n            case 'string':\n              return 'String';\n            case 'any':\n              return 'Object';\n            default:\n              return jsiiType.builtIn;\n          }\n      }\n    }\n  }\n\n  private renderProcedure(\n    node: ts.ConstructorDeclaration | ts.MethodDeclaration | ts.FunctionDeclaration,\n    renderer: JavaRenderer,\n    methodOrConstructorName: ts.Node | undefined,\n    returnType: string | undefined,\n  ): OTree {\n    const overloads = new Array<OTree>();\n    for (let i = 0; i < node.parameters.length; i++) {\n      const param = node.parameters[i];\n      if (!!param.questionToken || !!param.initializer) {\n        // The parameter is either optional, or has a default -\n        // render an overload that delegates to a version with one more parameter.\n        // Note that we don't check that all parameters with indexes > i are also optional/have a default -\n        // we assume the TypeScript compiler does that for us.\n\n        // parameters up to but excluding the current one\n        const parametersUpToIth = node.parameters.slice(0, i);\n        // how should the call to the next overload look\n        const callExpr = ts.isConstructorDeclaration(node) ? 'this' : renderer.convert(methodOrConstructorName);\n\n        overloads.push(\n          this.renderOverload(\n            returnType,\n            renderer,\n            methodOrConstructorName,\n            parametersUpToIth,\n            // the body is the call to the next overload\n            this.renderBlock([\n              new OTree(\n                ['\\n', callExpr, '('],\n                [\n                  ...parametersUpToIth.map((p) => renderer.convert(p.name)),\n                  param.initializer ? renderer.convert(param.initializer) : 'null',\n                ],\n                {\n                  separator: ', ',\n                  suffix: ');',\n                },\n              ),\n            ]),\n          ),\n        );\n      }\n    }\n    // render the primary overload\n    overloads.push(\n      this.renderOverload(returnType, renderer, methodOrConstructorName, node.parameters, renderer.convert(node.body)),\n    );\n\n    return new OTree([], overloads, {\n      canBreakLine: true,\n      separator: '\\n\\n',\n    });\n  }\n\n  private renderOverload(\n    returnType: string | undefined,\n    renderer: JavaRenderer,\n    methodOrConstructorName: ts.Node | undefined,\n    parameters: ts.ParameterDeclaration[] | ts.NodeArray<ts.ParameterDeclaration>,\n    body: OTree,\n  ): OTree {\n    return new OTree(\n      [\n        'public ',\n        returnType ? `${returnType} ` : undefined,\n        renderer.convert(methodOrConstructorName),\n        '(',\n        new OTree([], renderer.convertAll(parameters), { separator: ', ' }),\n        ') ',\n      ],\n      [body],\n      {\n        canBreakLine: true,\n      },\n    );\n  }\n\n  private renderBlock(blockContents: OTree[]): OTree {\n    return new OTree(['{'], blockContents, {\n      indent: 4,\n      suffix: '\\n}',\n    });\n  }\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction lastElement(strings: string[]): string {\n  return strings[strings.length - 1];\n}\n\n/**\n * Find the Java name of a module or type\n */\nfunction findJavaName(jsiiSymbol: JsiiSymbol): string | undefined {\n  if (!jsiiSymbol.sourceAssembly?.assembly) {\n    // Don't have accurate info, just guess\n    return jsiiSymbol.symbolType !== 'module' ? simpleName(jsiiSymbol.fqn) : guessJavaNamespaceName(jsiiSymbol.fqn);\n  }\n\n  const asm = jsiiSymbol.sourceAssembly?.assembly;\n  return recurse(jsiiSymbol.fqn);\n\n  function recurse(fqn: string): string {\n    if (fqn === asm.name) {\n      return jsiiTargetParameter(asm, 'java.package') ?? guessJavaNamespaceName(fqn);\n    }\n    if (asm.submodules?.[fqn]) {\n      const modName = jsiiTargetParameter(asm.submodules[fqn], 'java.package');\n      if (modName) {\n        return modName;\n      }\n    }\n\n    const ns = namespaceName(fqn);\n    const nsJavaName = recurse(ns);\n    const leaf = simpleName(fqn);\n    return `${nsJavaName}.${leaf}`;\n  }\n}\n\nfunction guessJavaNamespaceName(packageName: string) {\n  return packageName\n    .split(/[^a-zA-Z0-9]+/g)\n    .filter((s) => s !== '')\n    .join('.');\n}\n"]}