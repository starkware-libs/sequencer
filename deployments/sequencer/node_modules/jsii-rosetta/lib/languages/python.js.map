{"version":3,"file":"python.js","sourceRoot":"","sources":["../../src/languages/python.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AAEjC,uCAA2C;AAC3C,mDAAsF;AACtF,mDAS4B;AAC5B,+CAAuD;AACvD,kEAA8D;AAC9D,sCAAyD;AACzD,0CAAgE;AAEhE,uDAMiC;AAEjC,+CAAgE;AAChE,kCAAqE;AA8ErE,MAAa,aAAc,SAAQ,wBAAqC;IAwBtE,YAAoC,UAAgC,EAAE;QACpE,KAAK,EAAE,CAAC;QAD0B,YAAO,GAAP,OAAO,CAA2B;QAftD,aAAQ,GAAG,gCAAc,CAAC,MAAM,CAAC;QACjC,mBAAc,GAAG,EAAE,CAAC;QAEpC;;WAEG;QACc,YAAO,GAAG,IAAI,KAAK,EAAkB,CAAC;QAEvD;;WAEG;QACc,0BAAqB,GAAG,IAAI,KAAK,EAAU,CAAC;QAE1C,wBAAmB,GAAG,EAAE,CAAC;IAI5C,CAAC;IAEM,YAAY,CAAC,GAA0B,EAAE,MAAsC;QACpF,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;IACxC,CAAC;IAEe,YAAY,CAAC,OAAsB,EAAE,QAA8B;QACjF,MAAM,WAAW,GAAG,IAAA,+BAAmB,EAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,sBAAsB,CAAC,CAAC;QAC7G,MAAM,SAAS,GAAG,WAAW;aAC1B,KAAK,CAAC,IAAI,CAAC;aACX,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC;aACpB,IAAI,CAAC,IAAI,CAAC,CAAC;QACd,MAAM,sBAAsB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QAE1D,OAAO,IAAI,cAAK,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,SAAS,EAAE,sBAAsB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;YACnG,oEAAoE;YACpE,kDAAkD;YAClD,UAAU,EAAE,WAAW,OAAO,CAAC,GAAG,EAAE;SACrC,CAAC,CAAC;IACL,CAAC;IAEe,UAAU,CAAC,IAAmB,EAAE,OAA6B;QAC3E,IAAI,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAE/C,wBAAwB;QACxB,IAAI,IAAI,CAAC,qBAAqB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1C,QAAQ,GAAG,IAAI,cAAK,CAAC,CAAC,GAAG,IAAI,CAAC,sBAAsB,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC;QACrE,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;YAC5B,QAAQ,GAAG,IAAI,cAAK,CAAC,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACrE,CAAC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEe,eAAe,CAAC,IAAqB,EAAE,OAA6B;QAClF,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC;YACnC,MAAM,UAAU,GAAG,IAAA,WAAI,EAAC,IAAI,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,sBAAsB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAEvG,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;YACjE,IAAI,CAAC,SAAS,CAAC;gBACb,WAAW,EAAE,IAAI,CAAC,YAAY,EAAE,GAAG,IAAI,IAAI,CAAC,WAAW;gBACvD,UAAU;aACX,CAAC,CAAC;YAEH,OAAO,IAAI,cAAK,CAAC,CAAC,UAAU,UAAU,OAAO,gBAAgB,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAChF,YAAY,EAAE,IAAI;aACnB,CAAC,CAAC;QACL,CAAC;QACD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC;YACxC,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;gBACvC,IAAI,EAAE,CAAC,cAAc,EAAE,CAAC;oBACtB,IAAI,CAAC,SAAS,CAAC;wBACb,UAAU,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU;wBAC/C,WAAW,EAAE,EAAE,CAAC,cAAc,CAAC,GAAG;qBACnC,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YAED,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE;gBAC/C,MAAM,SAAS,GAAG,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,UAAU,CAAC;gBAC5C,MAAM,YAAY,GAAG,IAAA,WAAI,EAAC,IAAA,WAAI,EAAC,EAAE,CAAC,cAAc,EAAE,cAAc,CAAC,EAAE,uBAAU,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC;gBAEhG,OAAO,SAAS,KAAK,YAAY;oBAC/B,CAAC,CAAC,gBAAgB,CAAC,YAAY,CAAC;oBAChC,CAAC,CAAC,GAAG,gBAAgB,CAAC,YAAY,CAAC,OAAO,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC;YAC5E,CAAC,CAAC,CAAC;YAEH,MAAM,UAAU,GAAG,IAAA,WAAI,EAAC,IAAI,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,sBAAsB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAEvG,OAAO,IAAI,cAAK,CAAC,CAAC,QAAQ,UAAU,WAAW,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBACxE,YAAY,EAAE,IAAI;aACnB,CAAC,CAAC;QACL,CAAC;QAED,OAAO,IAAA,gBAAK,EAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACnC,CAAC;IAEe,KAAK,CAA0B,IAAiB,EAAE,OAA6B;QAC7F,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAClC,MAAM,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,MAAM,EAAE,CAAC;YACX,OAAO,IAAI,cAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7B,CAAC;QACD,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACpC,CAAC;IAEe,UAAU,CAAC,IAAmB,EAAE,OAA6B;QAC3E,MAAM,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC;QAErC,MAAM,iBAAiB,GAAG,OAAO,CAAC,cAAc,CAAC,iBAAiB,CAAC;QACnE,IACE,OAAO,CAAC,cAAc,CAAC,oBAAoB;YAC3C,iBAAiB;YACjB,iBAAiB,CAAC,IAAI;YACtB,iBAAiB,CAAC,YAAY,KAAK,kBAAkB,EACrD,CAAC;YACD,OAAO,IAAI,cAAK,CACd,EAAE,EACF,IAAA,+BAAkB,EAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,cAAK,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EACzG,EAAE,SAAS,EAAE,IAAI,EAAE,CACpB,CAAC;QACJ,CAAC;QAED,OAAO,IAAI,cAAK,CAAC,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC;IAEe,mBAAmB,CAAC,IAA4B,EAAE,OAA6B;QAC7F,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC1C,CAAC;IAEe,sBAAsB,CAAC,IAA+B,EAAE,OAA6B;QACnG,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,CAAC,CAAC;IACnE,CAAC;IAEe,iBAAiB,CAAC,IAA0B,EAAE,OAA6B;QACzF,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC1C,CAAC;IAEe,mBAAmB,CAAC,IAA4B,EAAE,OAA6B;QAC7F,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,IAAI,KAAK,MAAM,EAAE,CAAC;YACpB,OAAO,IAAI,cAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7B,CAAC;QACD,IAAI,IAAI,KAAK,OAAO,EAAE,CAAC;YACrB,OAAO,IAAI,cAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QAC9B,CAAC;QAED,OAAO,KAAK,CAAC,mBAAmB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAClD,CAAC;IAED,2CAA2C;IACpC,YAAY,CACjB,IAAoC,EACpC,OAA6B,EAC7B,OAAoC,EAAE;QAEtC,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,IAAA,mBAAU,EAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAE5F,MAAM,CAAC,UAAU,EAAE,iBAAiB,CAAC,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAErG,MAAM,GAAG,GAAG,IAAI,cAAK,CACnB;YACE,MAAM;YACN,UAAU;YACV,GAAG;YACH,IAAI,cAAK,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,EAAE,GAAG,UAAU,CAAC,EAAE;gBAClF,SAAS,EAAE,IAAI;aAChB,CAAC;YACF,KAAK;SACN,EACD,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,UAAU,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAChG;YACE,YAAY,EAAE,IAAI;SACnB,CACF,CAAC;QAEF,OAAO,GAAG,CAAC;IACb,CAAC;IAEe,KAAK,CAAC,IAAc,EAAE,OAA6B;QACjE,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,OAAO,IAAI,cAAK,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QACtE,CAAC;QAED,OAAO,IAAI,cAAK,CAAC,EAAE,EAAE,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACxD,SAAS,EAAE,EAAE;YACb,MAAM,EAAE,CAAC;YACT,YAAY,EAAE,IAAI;SACnB,CAAC,CAAC;IACL,CAAC;IAEe,qBAAqB,CAAC,IAAuB,EAAE,OAA6B;QAC1F,IAAI,cAAc,GAAmB,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAEtE,IAAI,IAAA,oBAAQ,EAAC,IAAI,CAAC,UAAU,EAAE,IAAA,sBAAU,EAAC,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,IAAI,OAAO,CAAC,cAAc,CAAC,iBAAiB,EAAE,CAAC;YAClH,cAAc,GAAG,WAAW,OAAO,CAAC,cAAc,CAAC,iBAAiB,EAAE,CAAC;QACzE,CAAC;QAED,MAAM,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAEjE,OAAO,IAAI,cAAK,CACd;YACE,cAAc;YACd,GAAG;YACH,IAAI,CAAC,4BAA4B,CAC/B,IAAI,CAAC,SAAS,EACd,OAAO,EACP,SAAS,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,gBAA2C,CAAC,CACjF;YACD,GAAG;SACJ,EACD,EAAE,EACF,EAAE,YAAY,EAAE,IAAI,EAAE,CACvB,CAAC;IACJ,CAAC;IAEe,wBAAwB,CACtC,IAAiC,EACjC,OAA6B,EAC7B,kBAAkD;QAElD,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACtC,IAAI,QAAQ,IAAI,iBAAiB,EAAE,CAAC;YAClC,OAAO,IAAI,cAAK,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAClD,CAAC;QAED,MAAM,iBAAiB,GAAG,OAAO,CAAC,cAAc,CAAC,iBAAiB,CAAC;QAEnE,4EAA4E;QAC5E,2DAA2D;QAC3D,IAAI,iBAAiB,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,iBAAiB,CAAC,YAAY,EAAE,CAAC;YAC5F,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QAED,IAAI,kBAAkB,IAAI,IAAI,EAAE,CAAC;YAC/B,OAAO,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACtD,CAAC;QAED,OAAO,KAAK,CAAC,wBAAwB,CAAC,IAAI,EAAE,OAAO,EAAE,kBAAkB,CAAC,CAAC;IAC3E,CAAC;IAEe,oBAAoB,CAAC,IAA6B,EAAE,OAA6B;QAC/F,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAExD,IACE,OAAO,CAAC,cAAc,CAAC,qBAAqB;YAC5C,IAAI;YACJ,IAAA,8BAAiB,EAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,KAAK,KAAK,EACtD,CAAC;YACD,4EAA4E;YAC5E,8BAA8B;YAC9B,IAAI,OAAO,CAAC,cAAc,CAAC,uBAAuB,EAAE,CAAC;gBACnD,OAAO,CAAC,cAAc,CAAC,uBAAuB,CAAC,KAAK,GAAG;oBACrD,YAAY,EAAE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;oBACvC,IAAI;iBACL,CAAC;YACJ,CAAC;YAED,oBAAoB;YACpB,OAAO,IAAI,cAAK,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,IAAA,+BAAkB,EAAC,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QACnH,CAAC;QAED,MAAM,MAAM,GAAG,IAAA,iCAAyB,EAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QAEpE,OAAO,IAAI,cAAK,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;QAEvF,SAAS,oBAAoB,CAAC,IAAoB;YAChD,MAAM,GAAG,GAAG,IAAA,2CAA8B,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;YAChE,OAAO,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QACzB,CAAC;IACH,CAAC;IAEe,WAAW,CAAC,IAAoB,EAAE,OAA6B;QAC7E,MAAM,MAAM,GAAG,IAAI,cAAK,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE;YAC/G,YAAY,EAAE,IAAI;SACnB,CAAC,CAAC;QACH,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa;YACjC,CAAC,CAAC,IAAI,cAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE;gBAC3D,YAAY,EAAE,IAAI;aACnB,CAAC;YACJ,CAAC,CAAC,SAAS,CAAC;QAEd,OAAO,QAAQ;YACb,CAAC,CAAC,IAAI,cAAK,CAAC,EAAE,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;gBAChC,SAAS,EAAE,IAAI;gBACf,YAAY,EAAE,IAAI;aACnB,CAAC;YACJ,CAAC,CAAC,MAAM,CAAC;IACb,CAAC;IAEe,kCAAkC,CAChD,IAAgC,EAChC,OAA6B;QAE7B,mEAAmE;QACnE,MAAM,WAAW,GAAG,OAAO,CAAC,aAAa,CAAC;YACxC,oBAAoB,EAAE,KAAK;YAC3B,gBAAgB,EAAE,KAAK;SACxB,CAAC,CAAC;QAEH,IAAI,OAAO,CAAC,cAAc,CAAC,oBAAoB,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,gBAAgB,EAAE,CAAC;YAC5F,iEAAiE;YACjE,OAAO,IAAI,CAAC,6BAA6B,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;QAC7E,CAAC;QACD,OAAO,IAAI,CAAC,6BAA6B,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;IAChF,CAAC;IAEe,kCAAkC,CAChD,IAAgC,EAChC,UAA+B,EAC/B,OAA6B;QAE7B,IAAI,OAAO,CAAC,cAAc,CAAC,oBAAoB,EAAE,CAAC;YAChD,8DAA8D;YAC9D,OAAO,IAAI,CAAC,6BAA6B,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QACzE,CAAC;QAED,MAAM,UAAU,GACd,UAAU,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAE5G,OAAO,IAAI,CAAC,6BAA6B,CAAC,GAAG,UAAU,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;IACxF,CAAC;IAEe,+BAA+B,CAC7C,IAAgC,EAChC,OAA6B;QAE7B,OAAO,IAAI,CAAC,6BAA6B,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,CAAC,aAAa,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IAC3G,CAAC;IAEe,sBAAsB,CAAC,QAAgC;QACrE,IAAI,QAAQ,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,EAAE,CAAC;YAChD,OAAO,MAAM,CAAC;QAChB,CAAC;QACD,OAAO,KAAK,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAChD,CAAC;IAEM,6BAA6B,CAClC,MAAc,EACd,MAAc,EACd,6BAAsC,EACtC,IAAgC,EAChC,OAA6B;QAE7B,OAAO,IAAI,cAAK,CAAC,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,CAAC,EAAE,6BAA6B,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC/G,MAAM,EAAE,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC;YAC/D,SAAS,EAAE,IAAI;YACf,MAAM,EAAE,CAAC;SACV,CAAC,CAAC;IACL,CAAC;IAEe,sBAAsB,CAAC,IAA+B,EAAE,OAA6B;QACnG,OAAO,IAAI,cAAK,CAAC,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACzD,MAAM,EAAE,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;YAC1D,SAAS,EAAE,IAAI;YACf,MAAM,EAAE,CAAC;SACV,CAAC,CAAC;IACL,CAAC;IAEe,kBAAkB,CAAC,IAA2B,EAAE,OAA6B;QAC3F,MAAM,GAAG,GAAG,OAAO,CAAC,cAAc,CAAC,6BAA6B,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;QAE9E,4EAA4E;QAC5E,0EAA0E;QAC1E,gCAAgC;QAChC,IAAI,IAAI,GAAG,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;YACtC,CAAC,CAAC,IAAI,cAAK,CAAC;gBACR,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,mCAAmC;oBAC9D,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;oBAChB,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;aACrC,CAAC;YACJ,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE/B,+FAA+F;QAC/F,IACE,OAAO,CAAC,cAAc,CAAC,KAAK;YAC5B,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,6BAA6B,IAAI,CAAC,EAAE,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAChG,CAAC;YACD,IAAI,GAAG,IAAI,cAAK,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;QACrC,CAAC;QAED,OAAO,IAAI,cAAK,CACd,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,CAAC,aAAa,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,oBAAoB,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAC3G,EAAE,EACF,EAAE,YAAY,EAAE,IAAI,EAAE,CACvB,CAAC;IACJ,CAAC;IAEe,2BAA2B,CACzC,IAAoC,EACpC,OAA6B;QAE7B,IAAI,MAAM,GAAG,GAAG,CAAC;QACjB,IAAI,GAAG,GAAG,KAAK,CAAC;QAEhB,IAAI,OAAO,CAAC,cAAc,CAAC,6BAA6B,EAAE,CAAC;YACzD,MAAM,GAAG,EAAE,CAAC;YACZ,GAAG,GAAG,GAAG,CAAC;QACZ,CAAC;QAED,OAAO,IAAI,cAAK,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;IACtH,CAAC;IAEe,aAAa,CAAC,IAAsB,EAAE,OAA6B;QACjF,OAAO,IAAI,cAAK,CACd,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,GAAG,CAAC,EACxG,EAAE,EACF,EAAE,YAAY,EAAE,IAAI,EAAE,CACvB,CAAC;IACJ,CAAC;IAEe,mBAAmB,CAAC,IAA4B,EAAE,OAA6B;QAC7F,IAAI,QAAQ,GAAG,QAAQ,CAAC;QACxB,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;YACd,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;QACjC,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,MAAM,IAAI,GACR,CAAC,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC5C,CAAC,IAAI,CAAC,WAAW,IAAI,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAEnE,MAAM,YAAY,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;YACtF,OAAO,IAAI,cAAK,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC;QAC/E,CAAC;QAED,OAAO,IAAI,cAAK,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE;YAC3F,YAAY,EAAE,IAAI;SACnB,CAAC,CAAC;IACL,CAAC;IAEM,WAAW;QAChB,OAAO,IAAI,cAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;IAC7B,CAAC;IAEe,cAAc,CAAC,IAAuB,EAAE,OAA6B;QACnF,8DAA8D;QAC9D,IAAI,YAAY,GAAG,KAAK,CAAC;QAEzB,IAAA,oBAAQ,EACN,IAAI,CAAC,WAAW,EAChB,IAAA,sBAAU,EAAC,EAAE,CAAC,UAAU,CAAC,uBAAuB,EAAE,IAAA,sBAAU,EAAC,KAAK,EAAE,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,EACvG,CAAC,QAAQ,EAAE,EAAE;YACX,YAAY,GAAG,gBAAgB,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QACrE,CAAC,CACF,CAAC;QAEF,OAAO,IAAI,cAAK,CACd,CAAC,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,EACtE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EACjC,EAAE,YAAY,EAAE,IAAI,EAAE,CACvB,CAAC;IACJ,CAAC;IAEe,gBAAgB,CAAC,IAAyB,EAAE,OAA6B;QACvF,MAAM,kBAAkB,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QAEtG,gDAAgD;QAChD,MAAM,MAAM,GAAG,kBAAkB,CAAC,GAAG,CACnC,CAAC,CAAC,EAAE,EAAE,CACJ,IAAA,WAAI,EAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAA,+BAAkB,EAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,IAAI,KAAK,CACjH,CAAC;QAEF,MAAM,cAAc,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtE,MAAM,cAAc,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QACvE,MAAM,WAAW,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;QAE9C,MAAM,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAClF,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,CAAC,IAAI,CAAC,IAAI,cAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QAC1C,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,cAAK,CACnB;YACE,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,mBAAmB,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,CAAC;YAC7F,QAAQ;YACR,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK;YAC7C,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACtB,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;YAC3D,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACtB,IAAI;SACL,EACD,OAAO,EACP;YACE,MAAM,EAAE,CAAC;YACT,YAAY,EAAE,IAAI;SACnB,CACF,CAAC;QAEF,OAAO,GAAG,CAAC;IACb,CAAC;IAEe,cAAc,CAAC,IAAiC,EAAE,OAA6B;QAC7F,OAAO,IAAI,cAAK,CAAC,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,cAAK,CAAC,EAAE,EAAE,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;IACtG,CAAC;IAEe,mBAAmB,CAAC,KAA6B,EAAE,QAA8B;QAC/F,OAAO,IAAI,cAAK,CAAC,EAAE,CAAC,CAAC;IACvB,CAAC;IAED;;;;;OAKG;IACa,oBAAoB,CAAC,KAA8B,EAAE,QAA8B;QACjG,0DAA0D;QAC1D,OAAO,kBAAS,CAAC;IACnB,CAAC;IAEe,iBAAiB,CAAC,KAA2B,EAAE,QAA8B;QAC3F,+BAA+B;QAC/B,OAAO,kBAAS,CAAC;IACnB,CAAC;IAEe,eAAe,CAAC,KAAyB,EAAE,QAA8B;QACvF,+BAA+B;QAC/B,OAAO,kBAAS,CAAC;IACnB,CAAC;IAEe,YAAY,CAAC,IAAqB,EAAE,OAA6B;QAC/E,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC1C,CAAC;IAEe,aAAa,CAC3B,IAAyD,EACzD,QAA8B;QAE9B,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YACtD,OAAO,IAAI,cAAK,CAAC;gBACf,KAAK;gBACL,IAAI,CAAC,IAAI;oBACP,iDAAiD;qBAChD,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC;oBACvB,6CAA6C;qBAC5C,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC;gBAC3B,KAAK;aACN,CAAC,CAAC;QACL,CAAC;QACD,OAAO,IAAI,cAAK,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC;IAEe,kBAAkB,CAAC,IAA2B,EAAE,OAA6B;QAC3F,MAAM,KAAK,GAAG,IAAI,KAAK,EAAU,CAAC;QAClC,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACtB,KAAK,CAAC,IAAI,CAAC,IAAA,8BAAkB,EAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACpD,CAAC;QACD,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACtC,KAAK,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACnD,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;gBACzB,KAAK,CAAC,IAAI,CAAC,IAAA,8BAAkB,EAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;YACvD,CAAC;QACH,CAAC;QAED,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;QAEtE,OAAO,IAAI,cAAK,CAAC,CAAC,IAAI,KAAK,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IACnD,CAAC;IAEe,qBAAqB,CAAC,IAAuB,EAAE,QAA8B;QAC3F,MAAM,GAAG,GAAG,IAAA,gCAAoB,EAAC,IAAI,CAAC,CAAC;QACvC,IAAI,GAAG,KAAK,OAAO,EAAE,CAAC;YACpB,OAAO,IAAI,cAAK,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QAC1D,CAAC;QACD,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;YAClB,OAAO,IAAI,cAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QAC5B,CAAC;QACD,OAAO,kBAAS,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,2CAA2C;IACnC,6BAA6B,CACnC,MAAyD,EACzD,OAA6B;QAE7B,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACnC,OAAO,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;QACzB,CAAC;QAED,MAAM,uBAAuB,GAA8B,EAAE,CAAC;QAE9D,uCAAuC;QACvC,MAAM,SAAS,GACb,MAAM,CAAC,MAAM,GAAG,CAAC;YACf,CAAC,CAAC;gBACE,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACzD,OAAO;qBACJ,aAAa,CAAC;oBACb,qBAAqB,EAAE,IAAI;oBAC3B,uBAAuB;iBACxB,CAAC;qBACD,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACzB;YACH,CAAC,CAAC,EAAE,CAAC;QAET,OAAO,CAAC,SAAS,EAAE,uBAAuB,CAAC,KAAK,CAAC,CAAC;IACpD,CAAC;IAED;;;;;;;OAOG;IACK,4BAA4B,CAClC,IAA6C,EAC7C,OAA6B,EAC7B,qBAA0D;QAE1D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,OAAO,kBAAS,CAAC;QACnB,CAAC;QAED,MAAM,SAAS,GAAG,OAAO,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;YACvE,MAAM,IAAI,GAAG,qBAAqB,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,qBAAqB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACxF,MAAM,gBAAgB,GAAG,IAAI,EAAE,cAAc,IAAI,IAAI,CAAC;YACtD,MAAM,oBAAoB,GAAG,KAAK,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAEtD,OAAO,GAAG,CAAC,aAAa,CAAC,EAAE,gBAAgB,EAAE,oBAAoB,EAAE,CAAC,CAAC;QACvE,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,cAAK,CAAC,EAAE,EAAE,SAAS,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;IAClE,CAAC;IAED;;;;OAIG;IACK,UAAU,CAAC,UAAmB,EAAE,IAAa,EAAE,QAA8B,EAAE,QAAgB;QACrG,OAAO,QAAQ,CAAC,IAAA,8BAAiB,EAAC,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;QAE/D,6CAA6C;QAC7C,SAAS,QAAQ,CAAC,QAAkB;YAClC,QAAQ,QAAQ,CAAC,IAAI,EAAE,CAAC;gBACtB,KAAK,SAAS;oBACZ,OAAO,QAAQ,CAAC;gBAClB,KAAK,OAAO;oBACV,QAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;oBAC9C,OAAO,QAAQ,CAAC;gBAClB,KAAK,KAAK;oBACR,OAAO,aAAa,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC;gBACxD,KAAK,MAAM;oBACT,OAAO,QAAQ,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC;gBACnD,KAAK,WAAW;oBACd,2EAA2E;oBAC3E,OAAO,QAAQ,CAAC;gBAClB,KAAK,SAAS;oBACZ,QAAQ,QAAQ,CAAC,OAAO,EAAE,CAAC;wBACzB,KAAK,SAAS;4BACZ,OAAO,MAAM,CAAC;wBAChB,KAAK,QAAQ;4BACX,OAAO,QAAQ,CAAC;wBAClB,KAAK,QAAQ;4BACX,OAAO,KAAK,CAAC;wBACf,KAAK,KAAK;4BACR,OAAO,KAAK,CAAC;wBACf;4BACE,OAAO,QAAQ,CAAC,OAAO,CAAC;oBAC5B,CAAC;YACL,CAAC;QACH,CAAC;IACH,CAAC;IAEO,SAAS,CAAC,CAAiB;QACjC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrB,sCAAsC;QACtC,IAAA,aAAM,EAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACK,mBAAmB,CAAC,OAAmB;QAC7C,wDAAwD;QACxD,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YAC/B,IAAI,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,WAAW,GAAG,CAAC,EAAE,CAAC;gBAClD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACpE,OAAO,GAAG,GAAG,CAAC,UAAU,IAAI,SAAS,EAAE,CAAC;YAC1C,CAAC;QACH,CAAC;QAED,yFAAyF;QACzF,MAAM,UAAU,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,UAAU,EAAE,CAAC;YACxD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC9C,CAAC;QACD,OAAO,IAAA,uBAAU,EAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACjC,CAAC;IAEO,sBAAsB;QAC5B,MAAM,OAAO,GAAG,IAAA,cAAO,EAAC,IAAI,CAAC,qBAAqB,EAAE,0BAAa,CAAC,CAAC;QACnE,OAAO,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,EAAE,IAAI,CAAC,EAAE,EAAE;YAC1D,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,uBAAU,CAAC,CAAC;YACzC,OAAO,QAAQ,YAAY,WAAW,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;QACnE,CAAC,CAAC,CAAC;IACL,CAAC;;AA1sBH,sCA2sBC;AA1sBC;;;;;GAKG;AACoB,qBAAO,GAAG,GAAG,AAAN,CAAO;AAssBvC,SAAS,gBAAgB,CAAC,kBAA0B;IAClD,IAAI,IAAA,0BAAmB,EAAC,kBAAkB,CAAC,EAAE,CAAC;QAC5C,gCAAgC;QAChC,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IACD,uBAAuB;IACvB,MAAM,KAAK,GAAG,kBAAkB,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;IACnH,OAAO,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC;AACnE,CAAC;AAED,MAAM,iBAAiB,GAA8B;IACnD,aAAa,EAAE,OAAO;IACtB,eAAe,EAAE,kBAAkB;IACnC,aAAa,EAAE,eAAe;CAC/B,CAAC;AAEF,MAAM,cAAc,GAA8B;IAChD,IAAI,EAAE,MAAM;IACZ,IAAI,EAAE,MAAM;IACZ,KAAK,EAAE,OAAO;CACf,CAAC;AAEF,MAAM,mBAAmB,GAAa,CAAC,QAAQ,CAAC,CAAC;AAEjD,SAAS,IAAI,CAAI,EAAgB;IAC/B,OAAO,EAAE,CAAC,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC3B,CAAC;AAED;;GAEG;AACH,SAAS,cAAc,CAAC,UAAsB;IAC5C,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,QAAQ,EAAE,CAAC;QACzC,uCAAuC;QACvC,OAAO,UAAU,CAAC,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAA,uBAAU,EAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,sBAAsB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAClH,CAAC;IAED,MAAM,GAAG,GAAG,UAAU,CAAC,cAAc,EAAE,QAAQ,CAAC;IAChD,OAAO,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAE/B,SAAS,OAAO,CAAC,GAAW;QAC1B,IAAI,GAAG,KAAK,GAAG,CAAC,IAAI,EAAE,CAAC;YACrB,OAAO,IAAA,8BAAmB,EAAC,GAAG,EAAE,eAAe,CAAC,IAAI,sBAAsB,CAAC,GAAG,CAAC,CAAC;QAClF,CAAC;QACD,IAAI,GAAG,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC;YAC1B,MAAM,OAAO,GAAG,IAAA,8BAAmB,EAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,eAAe,CAAC,CAAC;YAC1E,IAAI,OAAO,EAAE,CAAC;gBACZ,OAAO,OAAO,CAAC;YACjB,CAAC;QACH,CAAC;QAED,OAAO,GAAG,OAAO,CAAC,IAAA,0BAAa,EAAC,GAAG,CAAC,CAAC,IAAI,IAAA,uBAAU,EAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;IACxE,CAAC;AACH,CAAC;AAED;;GAEG;AACH,SAAS,sBAAsB,CAAC,GAAW;IACzC,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACtE,CAAC","sourcesContent":["import * as ts from 'typescript';\n\nimport { DefaultVisitor } from './default';\nimport { determineJsiiType, JsiiType, ObjectLiteralStruct } from '../jsii/jsii-types';\nimport {\n  propertiesOfStruct,\n  StructProperty,\n  structPropertyAcceptsUndefined,\n  analyzeStructType,\n  JsiiSymbol,\n  simpleName,\n  namespaceName,\n  isJsiiProtocolType,\n} from '../jsii/jsii-utils';\nimport { jsiiTargetParameter } from '../jsii/packages';\nimport { TargetLanguage } from '../languages/target-language';\nimport { NO_SYNTAX, OTree, renderTree } from '../o-tree';\nimport { AstRenderer, nimpl, CommentSyntax } from '../renderer';\nimport { SubmoduleReference } from '../submodule-reference';\nimport {\n  matchAst,\n  nodeOfType,\n  stripCommentMarkers,\n  voidExpressionString,\n  quoteStringLiteral,\n} from '../typescript/ast-utils';\nimport { ImportStatement } from '../typescript/imports';\nimport { parameterAcceptsUndefined } from '../typescript/types';\nimport { startsWithUppercase, sortBy, groupBy, fmap } from '../util';\n\ninterface StructVar {\n  variableName: string;\n  type: ts.Type | undefined;\n}\n\ntype ReturnFromTree<A> = { value?: A };\n\ninterface PythonLanguageContext {\n  /**\n   * Whether we're currently rendering a parameter in tail position\n   *\n   * If so, and the parameter is of type struct, explode it to keyword args\n   * and return its information in `returnExplodedParameter`.\n   */\n  readonly tailPositionParameter?: boolean;\n\n  /**\n   * Used to return details about any exploded parameter\n   */\n  readonly returnExplodedParameter?: ReturnFromTree<StructVar>;\n\n  /**\n   * Whether we're currently rendering a value/expression in tail position\n   *\n   * If so, and the expression seems to be of a struct type, explode it\n   * to keyword args.\n   */\n  readonly tailPositionArgument?: boolean;\n\n  /**\n   * Whether object literal members should render themselves as dict\n   * members or keyword args\n   */\n  readonly renderObjectLiteralAsKeywords?: boolean;\n\n  /**\n   * In a code block, if any parameter is exploded, information about the parameter here\n   */\n  readonly explodedParameter?: StructVar;\n\n  /**\n   * Whether we're rendering a method or property inside a class\n   */\n  readonly inClass?: boolean;\n\n  /**\n   * Whether the current property assignment is in the context of a map value.\n   * In this case, the keys should be strings (quoted where needed), and should\n   * not get mangled or case-converted.\n   */\n  readonly inMap?: boolean;\n\n  /**\n   * If we're in a method, what is it's name\n   *\n   * (Used to render super() call.);\n   */\n  readonly currentMethodName?: string;\n\n  /**\n   * If we're rendering a variadic argument value\n   */\n  readonly variadicArgument?: boolean;\n}\n\ntype PythonVisitorContext = AstRenderer<PythonLanguageContext>;\n\nexport interface PythonVisitorOptions {\n  disclaimer?: string;\n}\n\ninterface ImportedModule {\n  readonly importedFqn: string;\n  readonly importName: string;\n}\n\nexport class PythonVisitor extends DefaultVisitor<PythonLanguageContext> {\n  /**\n   * Translation version\n   *\n   * Bump this when you change something in the implementation to invalidate\n   * existing cached translations.\n   */\n  public static readonly VERSION = '2';\n\n  public readonly language = TargetLanguage.PYTHON;\n  public readonly defaultContext = {};\n\n  /**\n   * Keep track of module imports we've seen, so that if we need to render a type we can pick from these modules\n   */\n  private readonly imports = new Array<ImportedModule>();\n\n  /**\n   * Synthetic imports that need to be added as a final step\n   */\n  private readonly syntheticImportsToAdd = new Array<string>();\n\n  protected override statementTerminator = '';\n\n  public constructor(private readonly options: PythonVisitorOptions = {}) {\n    super();\n  }\n\n  public mergeContext(old: PythonLanguageContext, update: Partial<PythonLanguageContext>) {\n    return Object.assign({}, old, update);\n  }\n\n  public override commentRange(comment: CommentSyntax, _context: PythonVisitorContext): OTree {\n    const commentText = stripCommentMarkers(comment.text, comment.kind === ts.SyntaxKind.MultiLineCommentTrivia);\n    const hashLines = commentText\n      .split('\\n')\n      .map((l) => `# ${l}`)\n      .join('\\n');\n    const needsAdditionalTrailer = comment.hasTrailingNewLine;\n\n    return new OTree([comment.isTrailing ? ' ' : '', hashLines, needsAdditionalTrailer ? '\\n' : ''], [], {\n      // Make sure comment is rendered exactly once in the output tree, no\n      // matter how many source nodes it is attached to.\n      renderOnce: `comment-${comment.pos}`,\n    });\n  }\n\n  public override sourceFile(node: ts.SourceFile, context: PythonVisitorContext): OTree {\n    let rendered = super.sourceFile(node, context);\n\n    // Add synthetic imports\n    if (this.syntheticImportsToAdd.length > 0) {\n      rendered = new OTree([...this.renderSyntheticImports(), rendered]);\n    }\n\n    if (this.options.disclaimer) {\n      rendered = new OTree([`# ${this.options.disclaimer}\\n`, rendered]);\n    }\n    return rendered;\n  }\n\n  public override importStatement(node: ImportStatement, context: PythonVisitorContext): OTree {\n    if (node.imports.import === 'full') {\n      const moduleName = fmap(node.moduleSymbol, findPythonName) ?? guessPythonPackageName(node.packageName);\n\n      const importName = node.imports.alias ?? node.imports.sourceName;\n      this.addImport({\n        importedFqn: node.moduleSymbol?.fqn ?? node.packageName,\n        importName,\n      });\n\n      return new OTree([`import ${moduleName} as ${mangleIdentifier(importName)}`], [], {\n        canBreakLine: true,\n      });\n    }\n    if (node.imports.import === 'selective') {\n      for (const im of node.imports.elements) {\n        if (im.importedSymbol) {\n          this.addImport({\n            importName: im.alias ? im.alias : im.sourceName,\n            importedFqn: im.importedSymbol.fqn,\n          });\n        }\n      }\n\n      const imports = node.imports.elements.map((im) => {\n        const localName = im.alias ?? im.sourceName;\n        const originalName = fmap(fmap(im.importedSymbol, findPythonName), simpleName) ?? im.sourceName;\n\n        return localName === originalName\n          ? mangleIdentifier(originalName)\n          : `${mangleIdentifier(originalName)} as ${mangleIdentifier(localName)}`;\n      });\n\n      const moduleName = fmap(node.moduleSymbol, findPythonName) ?? guessPythonPackageName(node.packageName);\n\n      return new OTree([`from ${moduleName} import ${imports.join(', ')}`], [], {\n        canBreakLine: true,\n      });\n    }\n\n    return nimpl(node.node, context);\n  }\n\n  public override token<A extends ts.SyntaxKind>(node: ts.Token<A>, context: PythonVisitorContext): OTree {\n    const text = context.textOf(node);\n    const mapped = TOKEN_REWRITES[text];\n    if (mapped) {\n      return new OTree([mapped]);\n    }\n    return super.token(node, context);\n  }\n\n  public override identifier(node: ts.Identifier, context: PythonVisitorContext) {\n    const originalIdentifier = node.text;\n\n    const explodedParameter = context.currentContext.explodedParameter;\n    if (\n      context.currentContext.tailPositionArgument &&\n      explodedParameter &&\n      explodedParameter.type &&\n      explodedParameter.variableName === originalIdentifier\n    ) {\n      return new OTree(\n        [],\n        propertiesOfStruct(explodedParameter.type, context).map((prop) => new OTree([prop.name, '=', prop.name])),\n        { separator: ', ' },\n      );\n    }\n\n    return new OTree([mangleIdentifier(originalIdentifier)]);\n  }\n\n  public override functionDeclaration(node: ts.FunctionDeclaration, context: PythonVisitorContext): OTree {\n    return this.functionLike(node, context);\n  }\n\n  public override constructorDeclaration(node: ts.ConstructorDeclaration, context: PythonVisitorContext): OTree {\n    return this.functionLike(node, context, { isConstructor: true });\n  }\n\n  public override methodDeclaration(node: ts.MethodDeclaration, context: PythonVisitorContext): OTree {\n    return this.functionLike(node, context);\n  }\n\n  public override expressionStatement(node: ts.ExpressionStatement, context: PythonVisitorContext): OTree {\n    const text = context.textOf(node);\n    if (text === 'true') {\n      return new OTree(['True']);\n    }\n    if (text === 'false') {\n      return new OTree(['False']);\n    }\n\n    return super.expressionStatement(node, context);\n  }\n\n  // tslint:disable-next-line:max-line-length\n  public functionLike(\n    node: ts.FunctionLikeDeclarationBase,\n    context: PythonVisitorContext,\n    opts: { isConstructor?: boolean } = {},\n  ): OTree {\n    const methodName = opts.isConstructor ? '__init__' : renderTree(context.convert(node.name));\n\n    const [paramDecls, explodedParameter] = this.convertFunctionCallParameters(node.parameters, context);\n\n    const ret = new OTree(\n      [\n        'def ',\n        methodName,\n        '(',\n        new OTree([], [context.currentContext.inClass ? 'self' : undefined, ...paramDecls], {\n          separator: ', ',\n        }),\n        '): ',\n      ],\n      [context.updateContext({ explodedParameter, currentMethodName: methodName }).convert(node.body)],\n      {\n        canBreakLine: true,\n      },\n    );\n\n    return ret;\n  }\n\n  public override block(node: ts.Block, context: PythonVisitorContext): OTree {\n    if (node.statements.length === 0) {\n      return new OTree([], ['\\npass'], { indent: 4, canBreakLine: true });\n    }\n\n    return new OTree([], context.convertAll(node.statements), {\n      separator: '',\n      indent: 4,\n      canBreakLine: true,\n    });\n  }\n\n  public override regularCallExpression(node: ts.CallExpression, context: PythonVisitorContext): OTree {\n    let expressionText: OTree | string = context.convert(node.expression);\n\n    if (matchAst(node.expression, nodeOfType(ts.SyntaxKind.SuperKeyword)) && context.currentContext.currentMethodName) {\n      expressionText = `super().${context.currentContext.currentMethodName}`;\n    }\n\n    const signature = context.typeChecker.getResolvedSignature(node);\n\n    return new OTree(\n      [\n        expressionText,\n        '(',\n        this.convertFunctionCallArguments(\n          node.arguments,\n          context,\n          signature?.parameters?.map((p) => p.valueDeclaration as ts.ParameterDeclaration),\n        ),\n        ')',\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    context: PythonVisitorContext,\n    submoduleReference: SubmoduleReference | undefined,\n  ) {\n    const fullText = context.textOf(node);\n    if (fullText in BUILTIN_FUNCTIONS) {\n      return new OTree([BUILTIN_FUNCTIONS[fullText]]);\n    }\n\n    const explodedParameter = context.currentContext.explodedParameter;\n\n    // We might be in a context where we've exploded this struct into arguments,\n    // in which case we will return just the accessed variable.\n    if (explodedParameter && context.textOf(node.expression) === explodedParameter.variableName) {\n      return context.convert(node.name);\n    }\n\n    if (submoduleReference != null) {\n      return context.convert(submoduleReference.lastNode);\n    }\n\n    return super.propertyAccessExpression(node, context, submoduleReference);\n  }\n\n  public override parameterDeclaration(node: ts.ParameterDeclaration, context: PythonVisitorContext): OTree {\n    const type = node.type && context.typeOfType(node.type);\n\n    if (\n      context.currentContext.tailPositionParameter &&\n      type &&\n      analyzeStructType(context.typeChecker, type) !== false\n    ) {\n      // Return the parameter that we exploded so that we can use this information\n      // while translating the body.\n      if (context.currentContext.returnExplodedParameter) {\n        context.currentContext.returnExplodedParameter.value = {\n          variableName: context.textOf(node.name),\n          type,\n        };\n      }\n\n      // Explode to fields\n      return new OTree([], ['*', ...propertiesOfStruct(type, context).map(renderStructProperty)], { separator: ', ' });\n    }\n\n    const suffix = parameterAcceptsUndefined(node, type) ? '=None' : '';\n\n    return new OTree([node.dotDotDotToken ? '*' : '', context.convert(node.name), suffix]);\n\n    function renderStructProperty(prop: StructProperty): string {\n      const sfx = structPropertyAcceptsUndefined(prop) ? '=None' : '';\n      return prop.name + sfx;\n    }\n  }\n\n  public override ifStatement(node: ts.IfStatement, context: PythonVisitorContext): OTree {\n    const ifStmt = new OTree(['if ', context.convert(node.expression), ': '], [context.convert(node.thenStatement)], {\n      canBreakLine: true,\n    });\n    const elseStmt = node.elseStatement\n      ? new OTree(['else: '], [context.convert(node.elseStatement)], {\n          canBreakLine: true,\n        })\n      : undefined;\n\n    return elseStmt\n      ? new OTree([], [ifStmt, elseStmt], {\n          separator: '\\n',\n          canBreakLine: true,\n        })\n      : ifStmt;\n  }\n\n  public override unknownTypeObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    context: PythonVisitorContext,\n  ): OTree {\n    // Neutralize local modifiers if any for transforming further down.\n    const downContext = context.updateContext({\n      tailPositionArgument: false,\n      variadicArgument: false,\n    });\n\n    if (context.currentContext.tailPositionArgument && !context.currentContext.variadicArgument) {\n      // Guess that it's a struct we can probably inline the kwargs for\n      return this.renderObjectLiteralExpression('', '', true, node, downContext);\n    }\n    return this.renderObjectLiteralExpression('{', '}', false, node, downContext);\n  }\n\n  public override knownStructObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    structType: ObjectLiteralStruct,\n    context: PythonVisitorContext,\n  ): OTree {\n    if (context.currentContext.tailPositionArgument) {\n      // We know it's a struct we can DEFINITELY inline the args for\n      return this.renderObjectLiteralExpression('', '', true, node, context);\n    }\n\n    const structName =\n      structType.kind === 'struct' ? this.importedNameForType(structType.jsiiSym) : structType.type.symbol.name;\n\n    return this.renderObjectLiteralExpression(`${structName}(`, ')', true, node, context);\n  }\n\n  public override keyValueObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    context: PythonVisitorContext,\n  ): OTree {\n    return this.renderObjectLiteralExpression('{', '}', false, node, context.updateContext({ inMap: true }));\n  }\n\n  public override translateUnaryOperator(operator: ts.PrefixUnaryOperator) {\n    if (operator === ts.SyntaxKind.ExclamationToken) {\n      return 'not ';\n    }\n    return super.translateUnaryOperator(operator);\n  }\n\n  public renderObjectLiteralExpression(\n    prefix: string,\n    suffix: string,\n    renderObjectLiteralAsKeywords: boolean,\n    node: ts.ObjectLiteralExpression,\n    context: PythonVisitorContext,\n  ): OTree {\n    return new OTree([prefix], context.updateContext({ renderObjectLiteralAsKeywords }).convertAll(node.properties), {\n      suffix: context.mirrorNewlineBefore(node.properties[0], suffix),\n      separator: ', ',\n      indent: 4,\n    });\n  }\n\n  public override arrayLiteralExpression(node: ts.ArrayLiteralExpression, context: PythonVisitorContext): OTree {\n    return new OTree(['['], context.convertAll(node.elements), {\n      suffix: context.mirrorNewlineBefore(node.elements[0], ']'),\n      separator: ', ',\n      indent: 4,\n    });\n  }\n\n  public override propertyAssignment(node: ts.PropertyAssignment, context: PythonVisitorContext): OTree {\n    const mid = context.currentContext.renderObjectLiteralAsKeywords ? '=' : ': ';\n\n    // node.name is either an identifier or a string literal. The string literal\n    // needs to be converted differently depending on whether it needs to be a\n    // string or a keyword argument.\n    let name = ts.isStringLiteral(node.name)\n      ? new OTree([\n          context.currentContext.inMap // If in map, don't mangle the keys\n            ? node.name.text\n            : mangleIdentifier(node.name.text),\n        ])\n      : context.convert(node.name);\n\n    // If this isn't a computed property, we must quote the key (unless it's rendered as a keyword)\n    if (\n      context.currentContext.inMap ||\n      (!context.currentContext.renderObjectLiteralAsKeywords && !ts.isComputedPropertyName(node.name))\n    ) {\n      name = new OTree(['\"', name, '\"']);\n    }\n\n    return new OTree(\n      [name, mid, context.updateContext({ inMap: false, tailPositionArgument: false }).convert(node.initializer)],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override shorthandPropertyAssignment(\n    node: ts.ShorthandPropertyAssignment,\n    context: PythonVisitorContext,\n  ): OTree {\n    let before = '\"';\n    let mid = '\": ';\n\n    if (context.currentContext.renderObjectLiteralAsKeywords) {\n      before = '';\n      mid = '=';\n    }\n\n    return new OTree([before, context.convert(node.name), mid, context.convert(node.name)], [], { canBreakLine: true });\n  }\n\n  public override newExpression(node: ts.NewExpression, context: PythonVisitorContext): OTree {\n    return new OTree(\n      [context.convert(node.expression), '(', this.convertFunctionCallArguments(node.arguments, context), ')'],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override variableDeclaration(node: ts.VariableDeclaration, context: PythonVisitorContext): OTree {\n    let fallback = 'object';\n    if (node.type) {\n      fallback = node.type.getText();\n    }\n\n    if (!node.initializer) {\n      const type =\n        (node.type && context.typeOfType(node.type)) ||\n        (node.initializer && context.typeOfExpression(node.initializer));\n\n      const renderedType = type ? this.renderType(node, type, context, fallback) : fallback;\n      return new OTree(['# ', context.convert(node.name), ': ', renderedType], []);\n    }\n\n    return new OTree([context.convert(node.name), ' = ', context.convert(node.initializer)], [], {\n      canBreakLine: true,\n    });\n  }\n\n  public thisKeyword() {\n    return new OTree(['self']);\n  }\n\n  public override forOfStatement(node: ts.ForOfStatement, context: PythonVisitorContext): OTree {\n    // This is what a \"for (const x of ...)\" looks like in the AST\n    let variableName = '???';\n\n    matchAst(\n      node.initializer,\n      nodeOfType(ts.SyntaxKind.VariableDeclarationList, nodeOfType('var', ts.SyntaxKind.VariableDeclaration)),\n      (bindings) => {\n        variableName = mangleIdentifier(context.textOf(bindings.var.name));\n      },\n    );\n\n    return new OTree(\n      ['for ', variableName, ' in ', context.convert(node.expression), ': '],\n      [context.convert(node.statement)],\n      { canBreakLine: true },\n    );\n  }\n\n  public override classDeclaration(node: ts.ClassDeclaration, context: PythonVisitorContext): OTree {\n    const allHeritageClauses = Array.from(node.heritageClauses ?? []).flatMap((h) => Array.from(h.types));\n\n    // List of booleans matching `allHeritage` array\n    const isJsii = allHeritageClauses.map(\n      (e) =>\n        fmap(context.typeOfExpression(e.expression), (type) => isJsiiProtocolType(context.typeChecker, type)) ?? false,\n    );\n\n    const jsiiImplements = allHeritageClauses.filter((_, i) => isJsii[i]);\n\n    const inlineHeritage = allHeritageClauses.filter((_, i) => !isJsii[i]);\n    const hasHeritage = inlineHeritage.length > 0;\n\n    const members = context.updateContext({ inClass: true }).convertAll(node.members);\n    if (members.length === 0) {\n      members.push(new OTree(['\\npass'], []));\n    }\n\n    const ret = new OTree(\n      [\n        ...jsiiImplements.flatMap((i) => ['@jsii.implements(', context.convert(i.expression), ')\\n']),\n        'class ',\n        node.name ? context.textOf(node.name) : '???',\n        hasHeritage ? '(' : '',\n        ...inlineHeritage.map((t) => context.convert(t.expression)),\n        hasHeritage ? ')' : '',\n        ': ',\n      ],\n      members,\n      {\n        indent: 4,\n        canBreakLine: true,\n      },\n    );\n\n    return ret;\n  }\n\n  public override printStatement(args: ts.NodeArray<ts.Expression>, context: PythonVisitorContext) {\n    return new OTree(['print', '(', new OTree([], context.convertAll(args), { separator: ', ' }), ')']);\n  }\n\n  public override propertyDeclaration(_node: ts.PropertyDeclaration, _context: PythonVisitorContext): OTree {\n    return new OTree([]);\n  }\n\n  /**\n   * We have to do something special here\n   *\n   * Best-effort, we remember the fields of struct interfaces and keep track of\n   * them. Fortunately we can determine from the name whether what to do.\n   */\n  public override interfaceDeclaration(_node: ts.InterfaceDeclaration, _context: PythonVisitorContext): OTree {\n    // Whatever we do, nothing here will have a representation\n    return NO_SYNTAX;\n  }\n\n  public override propertySignature(_node: ts.PropertySignature, _context: PythonVisitorContext): OTree {\n    // Does not represent in Python\n    return NO_SYNTAX;\n  }\n\n  public override methodSignature(_node: ts.MethodSignature, _context: PythonVisitorContext): OTree {\n    // Does not represent in Python\n    return NO_SYNTAX;\n  }\n\n  public override asExpression(node: ts.AsExpression, context: PythonVisitorContext): OTree {\n    return context.convert(node.expression);\n  }\n\n  public override stringLiteral(\n    node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    _context: PythonVisitorContext,\n  ): OTree {\n    if (node.getText(node.getSourceFile()).includes('\\n')) {\n      return new OTree([\n        '\"\"\"',\n        node.text\n          // Escape all occurrences of back-slash once more\n          .replace(/\\\\/g, '\\\\\\\\')\n          // Escape only the first one in triple-quotes\n          .replace(/\"\"\"/g, '\\\\\"\"\"'),\n        '\"\"\"',\n      ]);\n    }\n    return new OTree([JSON.stringify(node.text)]);\n  }\n\n  public override templateExpression(node: ts.TemplateExpression, context: PythonVisitorContext): OTree {\n    const parts = new Array<string>();\n    if (node.head.rawText) {\n      parts.push(quoteStringLiteral(node.head.rawText));\n    }\n    for (const span of node.templateSpans) {\n      parts.push(`{${context.textOf(span.expression)}}`);\n      if (span.literal.rawText) {\n        parts.push(quoteStringLiteral(span.literal.rawText));\n      }\n    }\n\n    const quote = parts.some((part) => part.includes('\\n')) ? '\"\"\"' : '\"';\n\n    return new OTree([`f${quote}`, ...parts, quote]);\n  }\n\n  public override maskingVoidExpression(node: ts.VoidExpression, _context: PythonVisitorContext): OTree {\n    const arg = voidExpressionString(node);\n    if (arg === 'block') {\n      return new OTree(['# ...'], [], { canBreakLine: true });\n    }\n    if (arg === '...') {\n      return new OTree(['...']);\n    }\n    return NO_SYNTAX;\n  }\n\n  /**\n   * Convert parameters\n   *\n   * If the last one has the type of a known struct, explode to keyword-only arguments.\n   *\n   * Returns a pair of [decls, excploded-var-name].\n   */\n  // tslint:disable-next-line:max-line-length\n  private convertFunctionCallParameters(\n    params: ts.NodeArray<ts.ParameterDeclaration> | undefined,\n    context: PythonVisitorContext,\n  ): [Array<string | OTree>, StructVar | undefined] {\n    if (!params || params.length === 0) {\n      return [[], undefined];\n    }\n\n    const returnExplodedParameter: ReturnFromTree<StructVar> = {};\n\n    // Convert the last element differently\n    const converted: Array<string | OTree> =\n      params.length > 0\n        ? [\n            ...context.convertAll(params.slice(0, params.length - 1)),\n            context\n              .updateContext({\n                tailPositionParameter: true,\n                returnExplodedParameter,\n              })\n              .convert(last(params)),\n          ]\n        : [];\n\n    return [converted, returnExplodedParameter.value];\n  }\n\n  /**\n   * Convert arguments.\n   *\n   * If the last argument:\n   *\n   * - is an object literal, explode it.\n   * - is itself an exploded argument in our call signature, explode the fields\n   */\n  private convertFunctionCallArguments(\n    args: ts.NodeArray<ts.Expression> | undefined,\n    context: PythonVisitorContext,\n    parameterDeclarations?: readonly ts.ParameterDeclaration[],\n  ) {\n    if (!args) {\n      return NO_SYNTAX;\n    }\n\n    const converted = context.convertWithModifier(args, (ctx, _arg, index) => {\n      const decl = parameterDeclarations?.[Math.min(index, parameterDeclarations.length - 1)];\n      const variadicArgument = decl?.dotDotDotToken != null;\n      const tailPositionArgument = index >= args.length - 1;\n\n      return ctx.updateContext({ variadicArgument, tailPositionArgument });\n    });\n\n    return new OTree([], converted, { separator: ', ', indent: 4 });\n  }\n\n  /**\n   * Render a type.\n   *\n   * Not usually a thing in Python, but useful for declared variables.\n   */\n  private renderType(owningNode: ts.Node, type: ts.Type, renderer: PythonVisitorContext, fallback: string): string {\n    return doRender(determineJsiiType(renderer.typeChecker, type));\n\n    // eslint-disable-next-line consistent-return\n    function doRender(jsiiType: JsiiType): string {\n      switch (jsiiType.kind) {\n        case 'unknown':\n          return fallback;\n        case 'error':\n          renderer.report(owningNode, jsiiType.message);\n          return fallback;\n        case 'map':\n          return `Dict[str, ${doRender(jsiiType.elementType)}]`;\n        case 'list':\n          return `List[${doRender(jsiiType.elementType)}]`;\n        case 'namedType':\n          // in this case, the fallback will hold more information than jsiiType.name\n          return fallback;\n        case 'builtIn':\n          switch (jsiiType.builtIn) {\n            case 'boolean':\n              return 'bool';\n            case 'number':\n              return 'number';\n            case 'string':\n              return 'str';\n            case 'any':\n              return 'Any';\n            default:\n              return jsiiType.builtIn;\n          }\n      }\n    }\n  }\n\n  private addImport(x: ImportedModule) {\n    this.imports.push(x);\n    // Sort in reverse order of FQN length\n    sortBy(this.imports, (i) => [-i.importedFqn.length]);\n  }\n\n  /**\n   * Find the import for the FQNs submodule, and return it and the rest of the name\n   */\n  private importedNameForType(jsiiSym: JsiiSymbol) {\n    // Look for an existing import that contains this symbol\n    for (const imp of this.imports) {\n      if (jsiiSym.fqn.startsWith(`${imp.importedFqn}.`)) {\n        const remainder = jsiiSym.fqn.substring(imp.importedFqn.length + 1);\n        return `${imp.importName}.${remainder}`;\n      }\n    }\n\n    // Otherwise look up the Python name of this symbol (but not for fake imports from tests)\n    const pythonName = findPythonName(jsiiSym);\n    if (!jsiiSym.fqn.startsWith('fake_jsii.') && pythonName) {\n      this.syntheticImportsToAdd.push(pythonName);\n    }\n    return simpleName(jsiiSym.fqn);\n  }\n\n  private renderSyntheticImports(): string[] {\n    const grouped = groupBy(this.syntheticImportsToAdd, namespaceName);\n    return Object.entries(grouped).map(([namespaceFqn, fqns]) => {\n      const simpleNames = fqns.map(simpleName);\n      return `from ${namespaceFqn} import ${simpleNames.join(', ')}\\n`;\n    });\n  }\n}\n\nfunction mangleIdentifier(originalIdentifier: string) {\n  if (startsWithUppercase(originalIdentifier)) {\n    // Probably a class, leave as-is\n    return originalIdentifier;\n  }\n  // Turn into snake-case\n  const cased = originalIdentifier.replace(/[^A-Z][A-Z]/g, (m) => `${m[0].slice(0, 1)}_${m.slice(1).toLowerCase()}`);\n  return IDENTIFIER_KEYWORDS.includes(cased) ? `${cased}_` : cased;\n}\n\nconst BUILTIN_FUNCTIONS: { [key: string]: string } = {\n  'console.log': 'print',\n  'console.error': 'sys.stderr.write',\n  'Math.random': 'random.random',\n};\n\nconst TOKEN_REWRITES: { [key: string]: string } = {\n  this: 'self',\n  true: 'True',\n  false: 'False',\n};\n\nconst IDENTIFIER_KEYWORDS: string[] = ['lambda'];\n\nfunction last<A>(xs: readonly A[]): A {\n  return xs[xs.length - 1];\n}\n\n/**\n * Find the Python name of a module or type\n */\nfunction findPythonName(jsiiSymbol: JsiiSymbol): string | undefined {\n  if (!jsiiSymbol.sourceAssembly?.assembly) {\n    // Don't have accurate info, just guess\n    return jsiiSymbol.symbolType !== 'module' ? simpleName(jsiiSymbol.fqn) : guessPythonPackageName(jsiiSymbol.fqn);\n  }\n\n  const asm = jsiiSymbol.sourceAssembly?.assembly;\n  return recurse(jsiiSymbol.fqn);\n\n  function recurse(fqn: string): string {\n    if (fqn === asm.name) {\n      return jsiiTargetParameter(asm, 'python.module') ?? guessPythonPackageName(fqn);\n    }\n    if (asm.submodules?.[fqn]) {\n      const modName = jsiiTargetParameter(asm.submodules[fqn], 'python.module');\n      if (modName) {\n        return modName;\n      }\n    }\n\n    return `${recurse(namespaceName(fqn))}.${simpleName(jsiiSymbol.fqn)}`;\n  }\n}\n\n/**\n * Pythonify an assembly name and hope it is correct\n */\nfunction guessPythonPackageName(ref: string) {\n  return ref.replace(/^@/, '').replace(/\\//g, '.').replace(/-/g, '_');\n}\n"]}