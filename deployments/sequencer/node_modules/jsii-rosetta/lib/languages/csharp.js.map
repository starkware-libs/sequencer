{"version":3,"file":"csharp.js","sourceRoot":"","sources":["../../src/languages/csharp.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { DefaultVisitor } from './default';\nimport { TargetLanguage } from './target-language';\nimport { determineJsiiType, JsiiType, ObjectLiteralStruct } from '../jsii/jsii-types';\nimport { JsiiSymbol, simpleName, namespaceName } from '../jsii/jsii-utils';\nimport { jsiiTargetParameter } from '../jsii/packages';\nimport { OTree, NO_SYNTAX } from '../o-tree';\nimport { AstRenderer, nimpl } from '../renderer';\nimport {\n  matchAst,\n  nodeOfType,\n  quoteStringLiteral,\n  visibility,\n  isReadOnly,\n  findSuperCall,\n  privatePropertyNames,\n  findEnclosingClassDeclaration,\n} from '../typescript/ast-utils';\nimport { ImportStatement } from '../typescript/imports';\nimport {\n  typeContainsUndefined,\n  parameterAcceptsUndefined,\n  inferMapElementType,\n  determineReturnType,\n} from '../typescript/types';\nimport { flat, fmap } from '../util';\n\ninterface CSharpLanguageContext {\n  /**\n   * Used to capitalize member accesses\n   */\n  readonly propertyOrMethod: boolean;\n\n  /**\n   * So we know how to render property signatures\n   */\n  readonly inStructInterface: boolean;\n\n  /**\n   * So we know how to render property signatures\n   */\n  readonly inRegularInterface: boolean;\n\n  /**\n   * So we know how to render property assignments\n   */\n  readonly inKeyValueList: boolean;\n\n  /**\n   * Whether a string literal is currently in the position of having to render as an identifier (LHS in property assignment)\n   */\n  readonly stringAsIdentifier: boolean;\n\n  /**\n   * Whether an identifier literal is currently in the position of having to render as a string (LHS in property assignment)\n   */\n  readonly identifierAsString: boolean;\n\n  /**\n   * When parsing an object literal and no type information is available, prefer parsing it as a struct to parsing it as a map\n   */\n  readonly preferObjectLiteralAsStruct: boolean;\n\n  /**\n   * When encountering these properties, render them as lowercase instead of uppercase\n   */\n  readonly privatePropertyNames: string[];\n}\n\ntype CSharpRenderer = AstRenderer<CSharpLanguageContext>;\n\nexport class CSharpVisitor extends DefaultVisitor<CSharpLanguageContext> {\n  /**\n   * Translation version\n   *\n   * Bump this when you change something in the implementation to invalidate\n   * existing cached translations.\n   */\n  public static readonly VERSION = '1';\n\n  public readonly language = TargetLanguage.CSHARP;\n\n  public readonly defaultContext = {\n    propertyOrMethod: false,\n    inStructInterface: false,\n    inRegularInterface: false,\n    inKeyValueList: false,\n    stringAsIdentifier: false,\n    identifierAsString: false,\n    preferObjectLiteralAsStruct: true,\n    privatePropertyNames: [],\n  };\n\n  /**\n   * Aliases for modules\n   *\n   * If these are encountered in the LHS of a property access, they will be dropped.\n   */\n  private readonly dropPropertyAccesses = new Set<string>();\n\n  /**\n   * Already imported modules so we don't emit duplicate imports\n   */\n  private readonly alreadyImportedNamespaces = new Set<string>();\n\n  /**\n   * A map to undo import renames\n   *\n   * We will always reference the original name in the translation.\n   *\n   * Maps a local-name to a C# name.\n   */\n  private readonly renamedSymbols = new Map<string, string>();\n\n  public mergeContext(old: CSharpLanguageContext, update: Partial<CSharpLanguageContext>): CSharpLanguageContext {\n    return Object.assign({}, old, update);\n  }\n\n  public override identifier(\n    node: ts.Identifier | ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: CSharpRenderer,\n  ) {\n    let text = node.text;\n\n    if (renderer.currentContext.identifierAsString) {\n      return new OTree([JSON.stringify(text)]);\n    }\n\n    // Uppercase methods and properties, leave the rest as-is\n    if (renderer.currentContext.propertyOrMethod && !renderer.currentContext.privatePropertyNames.includes(text)) {\n      text = ucFirst(text);\n    }\n\n    return new OTree([text]);\n  }\n\n  public override importStatement(importStatement: ImportStatement, context: CSharpRenderer): OTree {\n    const guessedNamespace = guessDotnetNamespace(importStatement.packageName);\n    const namespace = fmap(importStatement.moduleSymbol, findDotnetName) ?? guessedNamespace;\n\n    if (importStatement.imports.import === 'full') {\n      this.dropPropertyAccesses.add(importStatement.imports.sourceName);\n      this.alreadyImportedNamespaces.add(namespace);\n      return new OTree([`using ${namespace};`], [], { canBreakLine: true });\n    }\n    if (importStatement.imports.import === 'selective') {\n      const statements = new Array<string>();\n\n      for (const el of importStatement.imports.elements) {\n        const dotnetNs = fmap(el.importedSymbol, findDotnetName) ?? `${guessedNamespace}.${ucFirst(el.sourceName)}`;\n\n        // If this is an alias, we only honor it if it's NOT for sure a module\n        // (could be an alias import of a class or enum).\n        if (el.alias && el.importedSymbol?.symbolType !== 'module') {\n          this.renamedSymbols.set(el.alias, simpleName(dotnetNs));\n          statements.push(`using ${ucFirst(el.alias)} = ${dotnetNs};`);\n          continue;\n        }\n\n        // If we are importing a module directly, drop the occurrences of that\n        // identifier further down (turn `mod.MyClass` into `MyClass`).\n        if (el.importedSymbol?.symbolType === 'module') {\n          this.dropPropertyAccesses.add(el.alias ?? el.sourceName);\n        }\n\n        // Output an import statement for the containing namespace\n        const importableNamespace = el.importedSymbol?.symbolType === 'module' ? dotnetNs : namespaceName(dotnetNs);\n        if (this.alreadyImportedNamespaces.has(importableNamespace)) {\n          continue;\n        }\n\n        this.alreadyImportedNamespaces.add(importableNamespace);\n        statements.push(`using ${importableNamespace};`);\n      }\n\n      return new OTree([], statements, { canBreakLine: true, separator: '\\n' });\n    }\n\n    return nimpl(importStatement.node, context);\n  }\n\n  public override functionDeclaration(node: ts.FunctionDeclaration, renderer: CSharpRenderer): OTree {\n    return this.functionLike(node, renderer);\n  }\n\n  public override constructorDeclaration(node: ts.ConstructorDeclaration, renderer: CSharpRenderer): OTree {\n    return this.functionLike(node, renderer, { isConstructor: true });\n  }\n\n  public override methodDeclaration(node: ts.MethodDeclaration, renderer: CSharpRenderer): OTree {\n    return this.functionLike(node, renderer);\n  }\n\n  public override methodSignature(node: ts.MethodSignature, renderer: CSharpRenderer): OTree {\n    return new OTree(\n      [\n        this.renderTypeNode(node.type, false, renderer),\n        ' ',\n        renderer.updateContext({ propertyOrMethod: true }).convert(node.name),\n        '(',\n        new OTree([], renderer.convertAll(node.parameters), {\n          separator: ', ',\n        }),\n        ');',\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  // tslint:disable-next-line:max-line-length\n  public functionLike(\n    node: ts.FunctionLikeDeclaration | ts.ConstructorDeclaration | ts.MethodDeclaration,\n    renderer: CSharpRenderer,\n    opts: { isConstructor?: boolean } = {},\n  ): OTree {\n    const methodName = opts.isConstructor\n      ? findEnclosingClassDeclaration(node)?.name?.text ?? 'MyClass'\n      : renderer.updateContext({ propertyOrMethod: true }).convert(node.name);\n\n    const retType = determineReturnType(renderer.typeChecker, node);\n    const returnType = opts.isConstructor ? '' : this.renderType(node, retType, false, 'void', renderer);\n\n    const baseConstructorCall = new Array<string | OTree>();\n    if (opts.isConstructor) {\n      const superCall = findSuperCall(node.body, renderer);\n      if (superCall) {\n        baseConstructorCall.push(': base(', this.argumentList(superCall.arguments, renderer), ') ');\n      }\n    }\n\n    const ret = new OTree(\n      [\n        visibility(node),\n        ' ',\n        returnType,\n        returnType ? ' ' : '',\n        methodName,\n        '(',\n        new OTree([], renderer.convertAll(node.parameters), {\n          separator: ', ',\n        }),\n        ') ',\n        ...baseConstructorCall,\n      ],\n      [renderer.convert(node.body)],\n      {\n        canBreakLine: true,\n      },\n    );\n\n    return ret;\n  }\n\n  public override propertyDeclaration(node: ts.PropertyDeclaration, renderer: CSharpRenderer): OTree {\n    const vis = visibility(node);\n    const propertyOrMethod = vis !== 'private'; // Capitalize non-private fields\n\n    if (vis === 'private' || node.initializer) {\n      // Emit member field\n      return new OTree(\n        [\n          vis,\n          isReadOnly(node) ? ' readonly' : '',\n          ' ',\n          this.renderTypeNode(node.type, node.questionToken !== undefined, renderer),\n          ' ',\n          renderer.updateContext({ propertyOrMethod }).convert(node.name),\n          ...(node.initializer ? [' = ', renderer.convert(node.initializer)] : []),\n          ';',\n        ],\n        [],\n        { canBreakLine: true },\n      );\n    }\n\n    // Emit property. No functional difference but slightly more idiomatic\n    return new OTree(\n      [\n        vis,\n        ' ',\n        this.renderTypeNode(node.type, node.questionToken !== undefined, renderer),\n        ' ',\n        renderer.updateContext({ propertyOrMethod }).convert(node.name),\n        ' ',\n        isReadOnly(node) ? '{ get; }' : '{ get; set; }',\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override printStatement(args: ts.NodeArray<ts.Expression>, renderer: CSharpRenderer) {\n    const renderedArgs =\n      args.length === 1\n        ? renderer.convertAll(args)\n        : [\n            '$\"',\n            new OTree(\n              [],\n              args.map((a) => new OTree(['{', renderer.convert(a), '}'])),\n              { separator: ' ' },\n            ),\n            '\"',\n          ];\n\n    return new OTree(['Console.WriteLine(', ...renderedArgs, ')']);\n  }\n\n  public override superCallExpression(_node: ts.CallExpression, _renderer: CSharpRenderer): OTree {\n    // super() call rendered as part of the constructor already\n    return NO_SYNTAX;\n  }\n\n  public override stringLiteral(\n    node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral,\n    renderer: CSharpRenderer,\n  ): OTree {\n    if (renderer.currentContext.stringAsIdentifier) {\n      return this.identifier(node, renderer);\n    }\n    if (node.text.includes('\\n')) {\n      // Multi-line string literals (@\"string\") in C# do not do escaping. Only \" needs to be doubled.\n      return new OTree(['@\"', node.text.replace(/\"/g, '\"\"'), '\"']);\n    }\n    return new OTree([JSON.stringify(node.text)]);\n  }\n\n  public override expressionStatement(node: ts.ExpressionStatement, renderer: CSharpRenderer): OTree {\n    const inner = renderer.convert(node.expression);\n    if (inner.isEmpty) {\n      return inner;\n    }\n    return new OTree([inner, ';'], [], { canBreakLine: true });\n  }\n\n  public override propertyAccessExpression(node: ts.PropertyAccessExpression, renderer: CSharpRenderer): OTree {\n    const lhs = renderer.textOf(node.expression);\n\n    // Suppress the LHS of the dot operator if it's \"this.\" (not necessary in C#)\n    // or if it's an imported module reference (C# has namespace-wide imports).\n    const objectExpression =\n      lhs === 'this' || this.dropPropertyAccesses.has(lhs)\n        ? []\n        : [renderer.updateContext({ propertyOrMethod: false }).convert(node.expression), '.'];\n\n    return new OTree([...objectExpression, renderer.updateContext({ propertyOrMethod: true }).convert(node.name)]);\n  }\n\n  public override parameterDeclaration(node: ts.ParameterDeclaration, renderer: CSharpRenderer): OTree {\n    return new OTree([\n      ...(node.dotDotDotToken ? ['params '] : []), // Varargs. Render with 'params' keyword\n      this.renderTypeNode(node.type, node.questionToken !== undefined, renderer),\n      ' ',\n      renderer.convert(node.name),\n      ...(parameterAcceptsUndefined(node, node.type && renderer.typeOfType(node.type))\n        ? ['=', node.initializer ? renderer.convert(node.initializer) : 'null']\n        : []),\n    ]);\n  }\n\n  public override propertySignature(node: ts.PropertySignature, renderer: CSharpRenderer): OTree {\n    const canSet = renderer.currentContext.inStructInterface || !isReadOnly(node);\n\n    return new OTree(\n      [\n        !renderer.currentContext.inRegularInterface ? `${visibility(node)} ` : NO_SYNTAX,\n        this.renderTypeNode(node.type, node.questionToken !== undefined, renderer),\n        ' ',\n        renderer.updateContext({ propertyOrMethod: true }).convert(node.name),\n        ' ',\n        canSet ? '{ get; set; }' : '{ get; }',\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  /**\n   * Do some work on property accesses to translate common JavaScript-isms to language-specific idioms\n   */\n  public override regularCallExpression(node: ts.CallExpression, renderer: CSharpRenderer): OTree {\n    return new OTree([\n      renderer.updateContext({ propertyOrMethod: true }).convert(node.expression),\n      '(',\n      this.argumentList(node.arguments, renderer),\n      ')',\n    ]);\n  }\n\n  public override classDeclaration(node: ts.ClassDeclaration, renderer: CSharpRenderer): OTree {\n    return new OTree(\n      ['class ', renderer.convert(node.name), ...this.classHeritage(node, renderer), '\\n{'],\n      renderer\n        .updateContext({\n          privatePropertyNames: privatePropertyNames(node.members, renderer),\n        })\n        .convertAll(node.members),\n      {\n        indent: 4,\n        canBreakLine: true,\n        suffix: '\\n}',\n      },\n    );\n  }\n\n  public override structInterfaceDeclaration(node: ts.InterfaceDeclaration, renderer: CSharpRenderer): OTree {\n    return new OTree(\n      ['class ', renderer.convert(node.name), ...this.classHeritage(node, renderer), '\\n{'],\n      renderer.updateContext({ inStructInterface: true }).convertAll(node.members),\n      {\n        indent: 4,\n        canBreakLine: true,\n        suffix: '\\n}',\n      },\n    );\n  }\n\n  public override regularInterfaceDeclaration(node: ts.InterfaceDeclaration, renderer: CSharpRenderer): OTree {\n    return new OTree(\n      ['interface ', renderer.convert(node.name), ...this.classHeritage(node, renderer), '\\n{'],\n      renderer.updateContext({ inRegularInterface: true }).convertAll(node.members),\n      {\n        indent: 4,\n        canBreakLine: true,\n        suffix: '\\n}',\n      },\n    );\n  }\n\n  public override block(node: ts.Block, children: CSharpRenderer): OTree {\n    return new OTree(['\\n{'], [...children.convertAll(node.statements)], {\n      indent: 4,\n      suffix: '\\n}',\n    });\n  }\n\n  public override unknownTypeObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    renderer: CSharpRenderer,\n  ): OTree {\n    if (renderer.currentContext.preferObjectLiteralAsStruct) {\n      // Type information missing and from context we prefer a struct\n      return new OTree(['new Struct { '], renderer.convertAll(node.properties), {\n        suffix: renderer.mirrorNewlineBefore(node.properties[0], '}', ' '),\n        separator: ', ',\n        indent: 4,\n      });\n    }\n    // Type information missing and from context we prefer a map\n    return this.keyValueObjectLiteralExpression(node, renderer);\n  }\n\n  public override knownStructObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    structType: ObjectLiteralStruct,\n    renderer: CSharpRenderer,\n  ): OTree {\n    return new OTree(['new ', structType.type.symbol.name, ' { '], renderer.convertAll(node.properties), {\n      suffix: renderer.mirrorNewlineBefore(node.properties[0], '}', ' '),\n      separator: ', ',\n      indent: 4,\n    });\n  }\n\n  public override keyValueObjectLiteralExpression(node: ts.ObjectLiteralExpression, renderer: CSharpRenderer): OTree {\n    // Try to infer an element type from the elements\n    const valueType = inferMapElementType(node.properties, renderer.typeChecker);\n\n    return new OTree(\n      ['new Dictionary<string, ', this.renderType(node, valueType, false, 'object', renderer), '> { '],\n      renderer.updateContext({ inKeyValueList: true }).convertAll(node.properties),\n      {\n        suffix: renderer.mirrorNewlineBefore(node.properties[0], '}', ' '),\n        separator: ', ',\n        indent: 4,\n      },\n    );\n  }\n\n  public override shorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, renderer: CSharpRenderer): OTree {\n    return this.renderPropertyAssignment(node.name, node.name, renderer);\n  }\n\n  public override propertyAssignment(node: ts.PropertyAssignment, renderer: CSharpRenderer): OTree {\n    return this.renderPropertyAssignment(node.name, node.initializer, renderer);\n  }\n\n  public renderPropertyAssignment(key: ts.Node, value: ts.Node, renderer: CSharpRenderer): OTree {\n    if (renderer.currentContext.inKeyValueList) {\n      return new OTree(\n        [\n          '{ ',\n          renderer\n            .updateContext({\n              propertyOrMethod: false,\n              identifierAsString: !ts.isComputedPropertyName(key),\n            })\n            .convert(key),\n          ', ',\n          renderer.updateContext({ inKeyValueList: false }).convert(value),\n          ' }',\n        ],\n        [],\n        { canBreakLine: true },\n      );\n    }\n    return new OTree(\n      [\n        renderer.updateContext({ propertyOrMethod: true, stringAsIdentifier: true }).convert(key),\n        ' = ',\n        renderer.convert(value),\n      ],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public override arrayLiteralExpression(node: ts.ArrayLiteralExpression, renderer: CSharpRenderer): OTree {\n    return new OTree(['new [] { '], renderer.convertAll(node.elements), {\n      separator: ', ',\n      suffix: ' }',\n      indent: 4,\n    });\n  }\n\n  public override ifStatement(node: ts.IfStatement, renderer: CSharpRenderer): OTree {\n    const ifStmt = new OTree(\n      ['if (', renderer.convert(node.expression), ') '],\n      [renderer.convert(node.thenStatement)],\n      { canBreakLine: true },\n    );\n    const elseStmt = node.elseStatement\n      ? new OTree(['else '], [renderer.convert(node.elseStatement)], {\n          canBreakLine: true,\n        })\n      : undefined;\n\n    return elseStmt\n      ? new OTree([], [ifStmt, elseStmt], {\n          separator: '\\n',\n          canBreakLine: true,\n        })\n      : ifStmt;\n  }\n\n  public override forOfStatement(node: ts.ForOfStatement, renderer: CSharpRenderer): OTree {\n    // This is what a \"for (const x of ...)\" looks like in the AST\n    let variableName = '???';\n\n    matchAst(\n      node.initializer,\n      nodeOfType(ts.SyntaxKind.VariableDeclarationList, nodeOfType('var', ts.SyntaxKind.VariableDeclaration)),\n      (bindings) => {\n        variableName = renderer.textOf(bindings.var.name);\n      },\n    );\n\n    return new OTree(\n      ['for (var ', variableName, ' in ', renderer.convert(node.expression), ') '],\n      [renderer.convert(node.statement)],\n      { canBreakLine: true },\n    );\n  }\n\n  public override asExpression(node: ts.AsExpression, context: CSharpRenderer): OTree {\n    return new OTree(['(', this.renderTypeNode(node.type, false, context), ')', context.convert(node.expression)]);\n  }\n\n  public override variableDeclaration(node: ts.VariableDeclaration, renderer: CSharpRenderer): OTree {\n    let typeOrVar = 'var';\n\n    const fallback = node.type?.getText() ?? 'var';\n    const type =\n      (node.type && renderer.typeOfType(node.type)) ??\n      (node.initializer && renderer.typeOfExpression(node.initializer));\n\n    const varType = this.renderType(node, type, false, fallback, renderer);\n    // If there is an initializer, and the value isn't \"IDictionary<...\", we always use var, as this is the\n    // recommendation from Roslyn.\n    if (varType !== 'object' && (varType.startsWith('IDictionary<') || node.initializer == null)) {\n      typeOrVar = varType;\n    }\n\n    if (!node.initializer) {\n      return new OTree([typeOrVar, ' ', renderer.convert(node.name), ';']);\n    }\n\n    return new OTree(\n      [\n        typeOrVar,\n        ' ',\n        renderer.convert(node.name),\n        ' = ',\n        renderer.updateContext({ preferObjectLiteralAsStruct: false }).convert(node.initializer),\n        ';',\n      ],\n      undefined,\n      { canBreakLine: true },\n    );\n  }\n\n  public override templateExpression(node: ts.TemplateExpression, context: CSharpRenderer): OTree {\n    // If this is a multi-line string literal, we need not quote much, as @\"string\" literals in C#\n    // do not perform any quoting. The literal quotes in the text however must be doubled.\n    const isMultiLine =\n      !!node.head.rawText?.includes('\\n') || node.templateSpans.some((span) => span.literal.rawText?.includes('\\n'));\n\n    const parts = new Array<string>();\n    if (node.head.rawText) {\n      parts.push(isMultiLine ? node.head.rawText.replace(/\"/g, '\"\"') : quoteStringLiteral(node.head.rawText));\n    }\n    for (const span of node.templateSpans) {\n      parts.push(`{${context.textOf(span.expression)}}`);\n      if (span.literal.rawText) {\n        parts.push(isMultiLine ? span.literal.rawText.replace(/\"/g, '\"\"') : quoteStringLiteral(span.literal.rawText));\n      }\n    }\n\n    return new OTree([isMultiLine ? '$@\"' : '$\"', ...parts, '\"']);\n  }\n\n  protected override argumentList(args: readonly ts.Node[] | undefined, renderer: CSharpRenderer): OTree {\n    return new OTree([], args ? renderer.updateContext({ preferObjectLiteralAsStruct: true }).convertAll(args) : [], {\n      separator: ', ',\n    });\n  }\n\n  private renderTypeNode(typeNode: ts.TypeNode | undefined, questionMark: boolean, renderer: CSharpRenderer): string {\n    if (!typeNode) {\n      return 'void';\n    }\n    return this.renderType(typeNode, renderer.typeOfType(typeNode), questionMark, renderer.textOf(typeNode), renderer);\n  }\n\n  private renderType(\n    typeNode: ts.Node,\n    type: ts.Type | undefined,\n    questionMark: boolean,\n    fallback: string,\n    renderer: CSharpRenderer,\n  ): string {\n    if (type === undefined) {\n      return fallback;\n    }\n\n    const renderedType = doRender(determineJsiiType(renderer.typeChecker, type));\n\n    const suffix = questionMark || typeContainsUndefined(type) ? '?' : '';\n\n    return renderedType + suffix;\n\n    // eslint-disable-next-line consistent-return\n    function doRender(jsiiType: JsiiType): string {\n      switch (jsiiType.kind) {\n        case 'unknown':\n          return fallback;\n        case 'error':\n          renderer.report(typeNode, jsiiType.message);\n          return fallback;\n        case 'map':\n          return `IDictionary<string, ${doRender(jsiiType.elementType)}>`;\n        case 'list':\n          return `${doRender(jsiiType.elementType)}[]`;\n        case 'namedType':\n          return jsiiType.name;\n        case 'builtIn':\n          switch (jsiiType.builtIn) {\n            case 'boolean':\n              return 'boolean';\n            case 'number':\n              return 'int';\n            case 'string':\n              return 'string';\n            case 'any':\n              return 'object';\n            case 'void':\n              return 'void';\n          }\n      }\n    }\n  }\n\n  private classHeritage(node: ts.ClassDeclaration | ts.InterfaceDeclaration, renderer: CSharpRenderer) {\n    const heritage = flat(Array.from(node.heritageClauses ?? []).map((h) => Array.from(h.types))).map((t) =>\n      renderer.convert(t.expression),\n    );\n\n    return heritage.length > 0 ? [' : ', new OTree([], heritage, { separator: ', ' })] : [];\n  }\n}\n\n/**\n * Uppercase the first letter\n */\nfunction ucFirst(x: string) {\n  return x.slice(0, 1).toUpperCase() + x.slice(1);\n}\n\n/**\n * Find the Java name of a module or type\n */\nfunction findDotnetName(jsiiSymbol: JsiiSymbol): string | undefined {\n  if (!jsiiSymbol.sourceAssembly?.assembly) {\n    // Don't have accurate info, just guess\n    return jsiiSymbol.symbolType !== 'module' ? simpleName(jsiiSymbol.fqn) : guessDotnetNamespace(jsiiSymbol.fqn);\n  }\n\n  const asm = jsiiSymbol.sourceAssembly?.assembly;\n  return recurse(jsiiSymbol.fqn);\n\n  function recurse(fqn: string): string {\n    if (fqn === asm.name) {\n      return jsiiTargetParameter(asm, 'dotnet.namespace') ?? guessDotnetNamespace(fqn);\n    }\n    if (asm.submodules?.[fqn]) {\n      const modName = jsiiTargetParameter(asm.submodules[fqn], 'dotnet.namespace');\n      if (modName) {\n        return modName;\n      }\n    }\n\n    return `${recurse(namespaceName(fqn))}.${ucFirst(simpleName(jsiiSymbol.fqn))}`;\n  }\n}\n\nfunction guessDotnetNamespace(ref: string) {\n  return ref\n    .split(/[^a-zA-Z0-9]+/g)\n    .filter((s) => s !== '')\n    .map(ucFirst)\n    .join('.');\n}\n"]}