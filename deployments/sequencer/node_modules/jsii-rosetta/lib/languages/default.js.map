{"version":3,"file":"default.js","sourceRoot":"","sources":["../../src/languages/default.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport type { TargetLanguage } from './target-language';\nimport { analyzeObjectLiteral, ObjectLiteralStruct } from '../jsii/jsii-types';\nimport { isNamedLikeStruct, isJsiiProtocolType } from '../jsii/jsii-utils';\nimport { OTree, NO_SYNTAX } from '../o-tree';\nimport { AstRenderer, AstHandler, nimpl, CommentSyntax } from '../renderer';\nimport { SubmoduleReference } from '../submodule-reference';\nimport { voidExpressionString } from '../typescript/ast-utils';\nimport { ImportStatement } from '../typescript/imports';\nimport { inferredTypeOfExpression } from '../typescript/types';\n\n/**\n * A basic visitor that applies for most curly-braces-based languages\n */\nexport abstract class DefaultVisitor<C> implements AstHandler<C> {\n  public abstract readonly defaultContext: C;\n  public abstract readonly language: TargetLanguage;\n\n  protected statementTerminator = ';';\n\n  public abstract mergeContext(old: C, update: C): C;\n\n  public commentRange(comment: CommentSyntax, _context: AstRenderer<C>): OTree {\n    return new OTree([comment.isTrailing ? ' ' : '', comment.text, comment.hasTrailingNewLine ? '\\n' : '']);\n  }\n\n  public sourceFile(node: ts.SourceFile, context: AstRenderer<C>): OTree {\n    return new OTree(context.convertAll(node.statements));\n  }\n\n  public jsDoc(_node: ts.JSDoc, _context: AstRenderer<C>): OTree {\n    // Already handled by other doc handlers\n    return new OTree([]);\n  }\n\n  public importStatement(node: ImportStatement, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node.node, context);\n  }\n\n  public functionDeclaration(node: ts.FunctionDeclaration, children: AstRenderer<C>): OTree {\n    return this.notImplemented(node, children);\n  }\n\n  public stringLiteral(node: ts.StringLiteral | ts.NoSubstitutionTemplateLiteral, _renderer: AstRenderer<C>): OTree {\n    return new OTree([JSON.stringify(node.text)]);\n  }\n\n  public numericLiteral(node: ts.NumericLiteral, _children: AstRenderer<C>): OTree {\n    return new OTree([node.text]);\n  }\n\n  public identifier(node: ts.Identifier, _children: AstRenderer<C>): OTree {\n    return new OTree([node.text]);\n  }\n\n  public block(node: ts.Block, children: AstRenderer<C>): OTree {\n    return new OTree(['{'], ['\\n', ...children.convertAll(node.statements)], {\n      indent: 4,\n      suffix: '}',\n    });\n  }\n\n  public parameterDeclaration(node: ts.ParameterDeclaration, children: AstRenderer<C>): OTree {\n    return this.notImplemented(node, children);\n  }\n\n  public returnStatement(node: ts.ReturnStatement, children: AstRenderer<C>): OTree {\n    return new OTree(['return ', children.convert(node.expression), this.statementTerminator], [], {\n      canBreakLine: true,\n    });\n  }\n\n  public binaryExpression(node: ts.BinaryExpression, context: AstRenderer<C>): OTree {\n    const operator = context.textOf(node.operatorToken);\n    if (operator === '??') {\n      context.reportUnsupported(node.operatorToken, undefined);\n    }\n    const operatorToken = this.translateBinaryOperator(operator);\n    return new OTree([context.convert(node.left), ' ', operatorToken, ' ', context.convert(node.right)]);\n  }\n\n  public prefixUnaryExpression(node: ts.PrefixUnaryExpression, context: AstRenderer<C>): OTree {\n    return new OTree([this.translateUnaryOperator(node.operator), context.convert(node.operand)]);\n  }\n\n  public translateUnaryOperator(operator: ts.PrefixUnaryOperator) {\n    return UNARY_OPS[operator];\n  }\n\n  public translateBinaryOperator(operator: string) {\n    if (operator === '===') {\n      return '==';\n    }\n    return operator;\n  }\n\n  public ifStatement(node: ts.IfStatement, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    context: AstRenderer<C>,\n    _submoduleReference: SubmoduleReference | undefined,\n  ): OTree {\n    return new OTree([context.convert(node.expression), '.', context.convert(node.name)]);\n  }\n\n  /**\n   * Do some work on property accesses to translate common JavaScript-isms to language-specific idioms\n   */\n  public callExpression(node: ts.CallExpression, context: AstRenderer<C>): OTree {\n    const functionText = context.textOf(node.expression);\n    if (functionText === 'console.log' || functionText === 'console.error') {\n      return this.printStatement(node.arguments, context);\n    }\n    if (functionText === 'super') {\n      return this.superCallExpression(node, context);\n    }\n\n    return this.regularCallExpression(node, context);\n  }\n\n  public awaitExpression(node: ts.AwaitExpression, context: AstRenderer<C>): OTree {\n    return context.convert(node.expression);\n  }\n\n  public regularCallExpression(node: ts.CallExpression, context: AstRenderer<C>): OTree {\n    return new OTree([context.convert(node.expression), '(', this.argumentList(node.arguments, context), ')']);\n  }\n\n  public superCallExpression(node: ts.CallExpression, context: AstRenderer<C>): OTree {\n    return this.regularCallExpression(node, context);\n  }\n\n  public printStatement(args: ts.NodeArray<ts.Expression>, context: AstRenderer<C>) {\n    return new OTree(['<PRINT>', '(', this.argumentList(args, context), ')']);\n  }\n\n  public expressionStatement(node: ts.ExpressionStatement, context: AstRenderer<C>): OTree {\n    return new OTree([context.convert(node.expression)], [], {\n      canBreakLine: true,\n    });\n  }\n\n  public token<A extends ts.SyntaxKind>(node: ts.Token<A>, context: AstRenderer<C>): OTree {\n    return new OTree([context.textOf(node)]);\n  }\n\n  /**\n   * An object literal can render as one of three things:\n   *\n   * - Don't know the type (render as an unknown struct)\n   * - Know the type:\n   *     - It's a struct (render as known struct)\n   *     - It's not a struct (render as key-value map)\n   */\n  public objectLiteralExpression(node: ts.ObjectLiteralExpression, context: AstRenderer<C>): OTree {\n    // If any of the elements of the objectLiteralExpression are not a literal property\n    // assignment, report them. We can't support those.\n    const unsupported = node.properties.filter(\n      (p) => !ts.isPropertyAssignment(p) && !ts.isShorthandPropertyAssignment(p),\n    );\n    for (const unsup of unsupported) {\n      context.report(unsup, `Use of ${ts.SyntaxKind[unsup.kind]} in an object literal is not supported.`);\n    }\n\n    const anyMembersFunctions = node.properties.some((p) =>\n      ts.isPropertyAssignment(p)\n        ? isExpressionOfFunctionType(context.typeChecker, p.initializer)\n        : ts.isShorthandPropertyAssignment(p)\n        ? isExpressionOfFunctionType(context.typeChecker, p.name)\n        : false,\n    );\n\n    const inferredType = inferredTypeOfExpression(context.typeChecker, node);\n    if ((inferredType && isJsiiProtocolType(context.typeChecker, inferredType)) || anyMembersFunctions) {\n      context.report(\n        node,\n        `You cannot use an object literal to make an instance of an interface. Define a class instead.`,\n      );\n    }\n\n    const lit = analyzeObjectLiteral(context.typeChecker, node);\n\n    switch (lit.kind) {\n      case 'unknown':\n        return this.unknownTypeObjectLiteralExpression(node, context);\n      case 'struct':\n      case 'local-struct':\n        return this.knownStructObjectLiteralExpression(node, lit, context);\n      case 'map':\n        return this.keyValueObjectLiteralExpression(node, context);\n    }\n  }\n\n  public unknownTypeObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public knownStructObjectLiteralExpression(\n    node: ts.ObjectLiteralExpression,\n    _structType: ObjectLiteralStruct,\n    context: AstRenderer<C>,\n  ): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public keyValueObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public newExpression(node: ts.NewExpression, context: AstRenderer<C>): OTree {\n    return new OTree(\n      ['new ', context.convert(node.expression), '(', this.argumentList(node.arguments, context), ')'],\n      [],\n      { canBreakLine: true },\n    );\n  }\n\n  public propertyAssignment(node: ts.PropertyAssignment, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public variableStatement(node: ts.VariableStatement, context: AstRenderer<C>): OTree {\n    return new OTree([context.convert(node.declarationList)], [], {\n      canBreakLine: true,\n    });\n  }\n\n  public variableDeclarationList(node: ts.VariableDeclarationList, context: AstRenderer<C>): OTree {\n    return new OTree([], context.convertAll(node.declarations));\n  }\n\n  public variableDeclaration(node: ts.VariableDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public arrayLiteralExpression(node: ts.ArrayLiteralExpression, context: AstRenderer<C>): OTree {\n    return new OTree(['['], context.convertAll(node.elements), {\n      separator: ', ',\n      suffix: ']',\n    });\n  }\n\n  public shorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public forOfStatement(node: ts.ForOfStatement, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public classDeclaration(node: ts.ClassDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public constructorDeclaration(node: ts.ConstructorDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public propertyDeclaration(node: ts.PropertyDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public computedPropertyName(node: ts.Expression, context: AstRenderer<C>): OTree {\n    return context.convert(node);\n  }\n\n  public methodDeclaration(node: ts.MethodDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public interfaceDeclaration(node: ts.InterfaceDeclaration, context: AstRenderer<C>): OTree {\n    if (isNamedLikeStruct(context.textOf(node.name))) {\n      return this.structInterfaceDeclaration(node, context);\n    }\n    return this.regularInterfaceDeclaration(node, context);\n  }\n\n  public structInterfaceDeclaration(node: ts.InterfaceDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public regularInterfaceDeclaration(node: ts.InterfaceDeclaration, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public propertySignature(node: ts.PropertySignature, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public methodSignature(node: ts.MethodSignature, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public asExpression(node: ts.AsExpression, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public spreadElement(node: ts.SpreadElement, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public spreadAssignment(node: ts.SpreadAssignment, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public ellipsis(_node: ts.SpreadElement | ts.SpreadAssignment, _context: AstRenderer<C>): OTree {\n    return new OTree(['...']);\n  }\n\n  public templateExpression(node: ts.TemplateExpression, context: AstRenderer<C>): OTree {\n    return this.notImplemented(node, context);\n  }\n\n  public elementAccessExpression(node: ts.ElementAccessExpression, context: AstRenderer<C>): OTree {\n    const expression = context.convert(node.expression);\n    const index = context.convert(node.argumentExpression);\n\n    return new OTree([expression, '[', index, ']']);\n  }\n\n  public nonNullExpression(node: ts.NonNullExpression, context: AstRenderer<C>): OTree {\n    // We default we drop the non-null assertion\n    return context.convert(node.expression);\n  }\n\n  public parenthesizedExpression(node: ts.ParenthesizedExpression, context: AstRenderer<C>): OTree {\n    return new OTree(['(', context.convert(node.expression), ')']);\n  }\n\n  public maskingVoidExpression(node: ts.VoidExpression, context: AstRenderer<C>): OTree {\n    // Don't render anything by default when nodes are masked\n    const arg = voidExpressionString(node);\n    if (arg === 'block') {\n      return this.commentRange(\n        {\n          pos: context.getPosition(node).start,\n          text: '\\n// ...',\n          kind: ts.SyntaxKind.SingleLineCommentTrivia,\n          hasTrailingNewLine: false,\n        },\n        context,\n      );\n    }\n    if (arg === '...') {\n      return new OTree(['...']);\n    }\n    return NO_SYNTAX;\n  }\n\n  protected argumentList(args: readonly ts.Node[] | undefined, context: AstRenderer<C>): OTree {\n    return new OTree([], args ? context.convertAll(args) : [], {\n      separator: ', ',\n    });\n  }\n\n  private notImplemented(node: ts.Node, context: AstRenderer<C>) {\n    context.reportUnsupported(node, this.language);\n    return nimpl(node, context);\n  }\n}\n\nconst UNARY_OPS: { [op in ts.PrefixUnaryOperator]: string } = {\n  [ts.SyntaxKind.PlusPlusToken]: '++',\n  [ts.SyntaxKind.MinusMinusToken]: '--',\n  [ts.SyntaxKind.PlusToken]: '+',\n  [ts.SyntaxKind.MinusToken]: '-',\n  [ts.SyntaxKind.TildeToken]: '~',\n  [ts.SyntaxKind.ExclamationToken]: '!',\n};\n\n/**\n * Whether the given expression evaluates to a value that is of type \"function\"\n *\n * Examples of function types:\n *\n * ```ts\n * // GIVEN\n * function someFunction() { }\n *\n * // THEN\n * const x = someFunction; // <- function type\n * const y = () => 42; // <- function type\n * const z = x; // <- function type\n * Array.isArray; // <- function type\n * ```\n */\nfunction isExpressionOfFunctionType(typeChecker: ts.TypeChecker, expr: ts.Expression) {\n  const type = typeChecker.getTypeAtLocation(expr).getNonNullableType();\n  return type.getCallSignatures().length > 0;\n}\n"]}