{"version":3,"file":"record-references.js","sourceRoot":"","sources":["../../src/languages/record-references.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { DefaultVisitor } from './default';\nimport { RECORD_REFERENCES_VERSION } from './record-references-version';\nimport { lookupJsiiSymbol } from '../jsii/jsii-utils';\nimport { TargetLanguage } from '../languages/target-language';\nimport { OTree, NO_SYNTAX } from '../o-tree';\nimport { AstRenderer } from '../renderer';\nimport { SubmoduleReference } from '../submodule-reference';\nimport { Spans } from '../typescript/visible-spans';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface RecordReferencesContext {}\n\ntype RecordReferencesRenderer = AstRenderer<RecordReferencesContext>;\n\n/**\n * A visitor that collects all types referenced in a particular piece of sample code\n */\nexport class RecordReferencesVisitor extends DefaultVisitor<RecordReferencesContext> {\n  public static readonly VERSION = RECORD_REFERENCES_VERSION;\n\n  public readonly language = TargetLanguage.VISUALIZE;\n  public readonly defaultContext = {};\n  private readonly references = new Set<string>();\n\n  public constructor(private readonly visibleSpans: Spans) {\n    super();\n  }\n\n  public fqnsReferenced() {\n    return Array.from(this.references).sort();\n  }\n\n  public mergeContext(old: RecordReferencesContext, update: Partial<RecordReferencesContext>): RecordReferencesContext {\n    return Object.assign({}, old, update);\n  }\n\n  /**\n   * For a variable declaration, a type counts as \"referenced\" if it gets assigned a value via an initializer\n   *\n   * This skips \"declare\" statements which aren't really interesting.\n   */\n  public override variableDeclaration(node: ts.VariableDeclaration, renderer: RecordReferencesRenderer): OTree {\n    if (this.visibleSpans.containsStartOfNode(node) && node.initializer) {\n      const type =\n        (node.type && renderer.typeOfType(node.type)) ||\n        (node.initializer && renderer.typeOfExpression(node.initializer));\n\n      this.recordSymbol(type.symbol, renderer);\n    }\n\n    return super.variableDeclaration(node, renderer);\n  }\n\n  public override newExpression(node: ts.NewExpression, context: RecordReferencesRenderer): OTree {\n    // Constructor\n    if (this.visibleSpans.containsStartOfNode(node)) {\n      this.recordNode(node.expression, context);\n      if (node.arguments) {\n        this.visitArgumentTypes(node.arguments, context);\n      }\n    }\n\n    return super.newExpression(node, context);\n  }\n\n  public override propertyAccessExpression(\n    node: ts.PropertyAccessExpression,\n    context: RecordReferencesRenderer,\n    submoduleReference: SubmoduleReference | undefined,\n  ): OTree {\n    if (this.visibleSpans.containsStartOfNode(node)) {\n      // The property itself\n      this.recordNode(node, context);\n\n      // Not currently considering the return type as \"referenced\"\n    }\n\n    return super.propertyAccessExpression(node, context, submoduleReference);\n  }\n\n  public override regularCallExpression(node: ts.CallExpression, context: RecordReferencesRenderer): OTree {\n    if (this.visibleSpans.containsStartOfNode(node)) {\n      // The method itself\n      this.recordNode(node.expression, context);\n\n      if (node.arguments) {\n        this.visitArgumentTypes(node.arguments, context);\n      }\n\n      // Not currently considering the return type as \"referenced\"\n    }\n\n    return super.regularCallExpression(node, context);\n  }\n\n  public override objectLiteralExpression(node: ts.ObjectLiteralExpression, context: RecordReferencesRenderer): OTree {\n    context.convertAll(node.properties);\n    return NO_SYNTAX;\n  }\n\n  public override propertyAssignment(node: ts.PropertyAssignment, renderer: RecordReferencesRenderer): OTree {\n    const type = renderer.typeOfExpression(node.initializer).getNonNullableType();\n    this.recordSymbol(type?.symbol, renderer);\n    return super.propertyAssignment(node, renderer);\n  }\n\n  public override shorthandPropertyAssignment(\n    node: ts.ShorthandPropertyAssignment,\n    renderer: RecordReferencesRenderer,\n  ): OTree {\n    const type = renderer.typeOfExpression(node.name).getNonNullableType();\n    this.recordSymbol(type?.symbol, renderer);\n    return super.shorthandPropertyAssignment(node, renderer);\n  }\n\n  /**\n   * Visit the arguments by type (instead of by node)\n   *\n   * This will make sure we recognize the use of a `BucketProps` in a `new Bucket(..., { ... })` call.\n   */\n  private visitArgumentTypes(args: ts.NodeArray<ts.Expression>, context: RecordReferencesRenderer) {\n    for (const argument of args) {\n      const type = context.inferredTypeOfExpression(argument);\n      this.recordSymbol(type?.symbol, context);\n    }\n  }\n\n  private recordNode(node: ts.Node, context: RecordReferencesRenderer) {\n    this.recordSymbol(context.typeChecker.getSymbolAtLocation(node), context);\n  }\n\n  private recordSymbol(symbol: ts.Symbol | undefined, context: RecordReferencesRenderer) {\n    if (!symbol) {\n      return;\n    }\n    const jsiiSym = lookupJsiiSymbol(context.typeChecker, symbol);\n    if (!jsiiSym) {\n      return;\n    }\n\n    this.references.add(jsiiSym.fqn);\n  }\n}\n"]}