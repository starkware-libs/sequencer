{"version":3,"file":"translate_all.js","sourceRoot":"","sources":["../src/translate_all.ts"],"names":[],"mappings":";;AAoBA,oCAsCC;AA1DD,8BAA8B;AAC9B,kCAAkC;AAClC,yCAAyC;AAEzC,qCAAqC;AAErC,+CAAsD;AAItD;;;;;;;;;GASG;AACI,KAAK,UAAU,YAAY,CAChC,QAA6B,EAC7B,0BAAmC;IAEnC,6EAA6E;IAC7E,6EAA6E;IAC7E,qDAAqD;IACrD,2FAA2F;IAC3F,MAAM,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,6BAA6B;QACjD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC;QACrD,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/D,MAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACxC,OAAO,CAAC,IAAI,CAAC,eAAe,UAAU,CAAC,MAAM,mBAAmB,CAAC,UAAU,CAAC,CAAC;IAE7E,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,yBAAyB,CAAC,EAAE;QAC5E,UAAU,EAAE,CAAC;KACd,CAAC,CAAC;IAEH,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,aAAa,CAAC,UAAU,EAAE,0BAA0B,CAAC,CAAC;QAEvE,MAAM,SAAS,GAA6B,MAAM,OAAO,CAAC,GAAG,CAC3D,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAClE,CAAC;QAEF,MAAM,WAAW,GAAG,IAAI,KAAK,EAAqB,CAAC;QACnD,MAAM,kBAAkB,GAAG,IAAI,KAAK,EAAqB,CAAC;QAE1D,kBAAkB;QAClB,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;YACjC,WAAW,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC;YAC1C,kBAAkB,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,iBAAiB,CAAC,GAAG,CAAC,2BAAiB,CAAC,UAAU,CAAC,CAAC,CAAC;QAC3F,CAAC;QACD,OAAO,EAAE,WAAW,EAAE,kBAAkB,EAAE,CAAC;IAC7C,CAAC;YAAS,CAAC;QACT,yBAAyB;QACzB,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;IACxB,CAAC;AACH,CAAC;AAED,SAAS,aAAa,CACpB,QAA6B,EAC7B,0BAAmC,EACnC,SAAS,GAAG,EAAE;IAEd,MAAM,GAAG,GAAG,EAAE,CAAC;IAEf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC;QACpD,GAAG,CAAC,IAAI,CAAC;YACP,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC;YAC1C,0BAA0B;SAC3B,CAAC,CAAC;IACL,CAAC;IAED,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import * as os from 'node:os';\nimport * as path from 'node:path';\nimport * as workerpool from 'workerpool';\n\nimport * as logging from './logging';\nimport { TypeScriptSnippet } from './snippet';\nimport { TranslatedSnippet } from './tablets/tablets';\nimport { RosettaDiagnostic } from './translate';\nimport type { TranslateBatchRequest, TranslateBatchResponse } from './translate_all_worker';\n\n/**\n * Divide the work evenly over all processors by running 'translate_all_worker' in Worker Threads, then combine results\n *\n * The workers are fed small queues of work each. We used to divide the entire queue into N\n * but since the work is divided unevenly that led to some workers stopping early, idling while\n * waiting for more work.\n *\n * Never include 'translate_all_worker' directly, only do TypeScript type references (so that in\n * the script we may assume that 'worker_threads' successfully imports).\n */\nexport async function translateAll(\n  snippets: TypeScriptSnippet[],\n  includeCompilerDiagnostics: boolean,\n): Promise<TranslateAllResult> {\n  // Use about half the advertised cores because hyperthreading doesn't seem to\n  // help that much, or we become I/O-bound at some point. On my machine, using\n  // more than half the cores actually makes it slower.\n  // Cap to a reasonable top-level limit to prevent thrash on machines with many, many cores.\n  const N = process.env.JSII_ROSETTA_MAX_WORKER_COUNT\n    ? parseInt(process.env.JSII_ROSETTA_MAX_WORKER_COUNT)\n    : Math.min(16, Math.max(1, Math.ceil(os.cpus().length / 2)));\n  const snippetArr = Array.from(snippets);\n  logging.info(`Translating ${snippetArr.length} snippets using ${N} workers`);\n\n  const pool = workerpool.pool(path.join(__dirname, 'translate_all_worker.js'), {\n    maxWorkers: N,\n  });\n\n  try {\n    const requests = batchSnippets(snippetArr, includeCompilerDiagnostics);\n\n    const responses: TranslateBatchResponse[] = await Promise.all(\n      requests.map((request) => pool.exec('translateBatch', [request])),\n    );\n\n    const diagnostics = new Array<RosettaDiagnostic>();\n    const translatedSnippets = new Array<TranslatedSnippet>();\n\n    // Combine results\n    for (const response of responses) {\n      diagnostics.push(...response.diagnostics);\n      translatedSnippets.push(...response.translatedSchemas.map(TranslatedSnippet.fromSchema));\n    }\n    return { diagnostics, translatedSnippets };\n  } finally {\n    // Not waiting on purpose\n    void pool.terminate();\n  }\n}\n\nfunction batchSnippets(\n  snippets: TypeScriptSnippet[],\n  includeCompilerDiagnostics: boolean,\n  batchSize = 10,\n): TranslateBatchRequest[] {\n  const ret = [];\n\n  for (let i = 0; i < snippets.length; i += batchSize) {\n    ret.push({\n      snippets: snippets.slice(i, i + batchSize),\n      includeCompilerDiagnostics,\n    });\n  }\n\n  return ret;\n}\n\nexport interface TranslateAllResult {\n  translatedSnippets: TranslatedSnippet[];\n  diagnostics: RosettaDiagnostic[];\n}\n"]}