{"version":3,"file":"fingerprinting.js","sourceRoot":"","sources":["../../src/jsii/fingerprinting.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from 'node:crypto';\nimport * as spec from '@jsii/spec';\n\n/**\n * Return a fingerprint for a type.\n *\n * The fingerprint will change if the API of the given type changes.\n *\n * The fingerprint is an approximation, it's not exhaustive. It will not trace\n * into types from assemblies it can't see, for example. For the purposes of Rosetta,\n * we'll assume this is Good Enoughâ„¢.\n */\nexport class TypeFingerprinter {\n  private readonly cache = new Map<string, string>();\n  private readonly assemblies = new Map<string, spec.Assembly>();\n\n  public constructor(assemblies: spec.Assembly[]) {\n    for (const assembly of assemblies) {\n      this.assemblies.set(assembly.name, assembly);\n    }\n  }\n\n  /**\n   * Return a single fingerprint that encompasses all fqns in the list\n   */\n  public fingerprintAll(fqns: string[]) {\n    const hash = crypto.createHash('sha256');\n    for (const fqn of fqns) {\n      hash.update(this.fingerprintType(fqn));\n    }\n    return hash.digest('hex');\n  }\n\n  /**\n   * Return the fingerprint for the given FQN in the assembly of this fingerprinter\n   *\n   * The fingerprint is always going to contain the FQN, even if the type doesn't exist\n   * in this assembly.\n   */\n  public fingerprintType(fqn: string) {\n    return this.doFingerprint(fqn, new Set([fqn]));\n  }\n\n  private doFingerprint(fqn: string, recursionBreaker: Set<string>) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    const existing = this.cache.get(fqn);\n    if (existing) {\n      return existing;\n    }\n\n    const hash = crypto.createHash('sha256');\n    hash.update(fqn);\n\n    const type = this.findType(fqn);\n    if (type) {\n      hash.update(type.kind);\n      switch (type.kind) {\n        case spec.TypeKind.Enum:\n          for (const member of sortedByName(type.members)) {\n            hash.update(member.name);\n          }\n          break;\n        case spec.TypeKind.Class:\n        case spec.TypeKind.Interface:\n          if (type.kind === spec.TypeKind.Class) {\n            visitType(type.base);\n            visitCallable(type.initializer);\n          }\n\n          for (const prop of sortedByName(type.properties ?? [])) {\n            hash.update(prop.name);\n            visitBools(prop.immutable, prop.static, prop.optional, prop.protected);\n            visitTypeReference(prop.type);\n          }\n          for (const method of sortedByName(type.methods ?? [])) {\n            hash.update(method.name);\n            visitCallable(method);\n            visitBools(method.returns?.optional);\n            visitTypeReference(method.returns?.type);\n          }\n          for (const implint of type.interfaces ?? []) {\n            visitType(implint);\n          }\n\n          break;\n      }\n    }\n\n    const ret = hash.digest('hex');\n    this.cache.set(fqn, ret);\n    return ret;\n\n    function visitType(fqnStr?: string) {\n      if (!fqnStr) {\n        return;\n      }\n\n      if (recursionBreaker.has(fqnStr)) {\n        hash.update('$RECURSION$');\n        return;\n      }\n\n      recursionBreaker.add(fqnStr);\n      hash.update(self.doFingerprint(fqnStr, recursionBreaker));\n      recursionBreaker.delete(fqnStr);\n    }\n\n    function visitCallable(callable?: spec.Callable) {\n      if (!callable) {\n        return;\n      }\n\n      visitBools(callable.protected);\n      for (const param of callable.parameters ?? []) {\n        visitBools(param.optional, param.variadic);\n        visitTypeReference(param.type);\n      }\n    }\n\n    function visitTypeReference(typeRef?: spec.TypeReference) {\n      if (!typeRef) {\n        return;\n      }\n\n      if (spec.isPrimitiveTypeReference(typeRef)) {\n        hash.update(typeRef.primitive);\n      }\n      if (spec.isNamedTypeReference(typeRef)) {\n        visitType(typeRef.fqn);\n      }\n      if (spec.isCollectionTypeReference(typeRef)) {\n        hash.update(typeRef.collection.kind);\n        visitTypeReference(typeRef.collection.elementtype);\n      }\n      if (spec.isUnionTypeReference(typeRef)) {\n        for (const t of typeRef.union.types) {\n          visitTypeReference(t);\n        }\n      }\n    }\n\n    function visitBools(...vs: Array<boolean | undefined>) {\n      hash.update(vs.map((v) => (v ? '1' : '0')).join(''));\n    }\n  }\n\n  private findType(fqn: string) {\n    const assemblyName = fqn.split('.')[0];\n    return this.assemblies.get(assemblyName)?.types?.[fqn];\n  }\n}\n\nfunction sortedByName<A extends { name: string }>(xs: A[]): A[] {\n  xs.sort((a, b) => a.name.localeCompare(b.name));\n  return xs;\n}\n"]}