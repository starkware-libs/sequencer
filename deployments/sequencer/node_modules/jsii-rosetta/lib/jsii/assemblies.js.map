{"version":3,"file":"assemblies.js","sourceRoot":"","sources":["../../src/jsii/assemblies.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fsPromises } from 'node:fs';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { loadAssemblyFromFile, loadAssemblyFromPath, findAssemblyFile } from '@jsii/spec';\nimport * as spec from '@jsii/spec';\nimport { fixturize } from '../fixtures';\nimport { extractTypescriptSnippetsFromMarkdown } from '../markdown/extract-snippets';\nimport {\n  TypeScriptSnippet,\n  updateParameters,\n  SnippetParameters,\n  ApiLocation,\n  parseMetadataLine,\n  CompilationDependency,\n  INITIALIZER_METHOD_NAME,\n  typeScriptSnippetFromVisibleSource,\n} from '../snippet';\nimport { resolveDependenciesFromPackageJson } from '../snippet-dependencies';\nimport { enforcesStrictMode } from '../strict';\nimport { LanguageTablet, DEFAULT_TABLET_NAME, DEFAULT_TABLET_NAME_COMPRESSED } from '../tablets/tablets';\nimport { fmap, mkDict, pathExists, sortBy } from '../util';\n\n/**\n * The JSDoc tag users can use to associate non-visible metadata with an example\n *\n * In a Markdown section, metadata goes after the code block fence, where it will\n * be attached to the example but invisible.\n *\n *    ```ts metadata=goes here\n *\n * But in doc comments, '@example' already delineates the example, and any metadata\n * in there added by the '///' tags becomes part of the visible code (there is no\n * place to put hidden information).\n *\n * We introduce the '@exampleMetadata' tag to put that additional information.\n */\nexport const EXAMPLE_METADATA_JSDOCTAG = 'exampleMetadata';\n\ninterface RosettaPackageJson extends spec.PackageJson {\n  readonly jsiiRosetta?: {\n    readonly strict?: boolean;\n    readonly exampleDependencies?: Record<string, string>;\n  };\n}\n\nexport interface LoadedAssembly {\n  readonly assembly: spec.Assembly;\n  readonly directory: string;\n  readonly packageJson?: RosettaPackageJson;\n}\n\n/**\n * Load assemblies by filename or directory\n */\nexport function loadAssemblies(\n  assemblyLocations: readonly string[],\n  validateAssemblies: boolean,\n): readonly LoadedAssembly[] {\n  return assemblyLocations.map(loadAssembly);\n\n  function loadAssembly(location: string): LoadedAssembly {\n    const stat = fs.statSync(location);\n    if (stat.isDirectory()) {\n      return loadAssembly(findAssemblyFile(location));\n    }\n\n    const directory = path.dirname(location);\n    const pjLocation = path.join(directory, 'package.json');\n\n    const assembly = loadAssemblyFromFile(location, validateAssemblies);\n    const packageJson = fs.existsSync(pjLocation) ? JSON.parse(fs.readFileSync(pjLocation, 'utf-8')) : undefined;\n\n    return { assembly, directory, packageJson };\n  }\n}\n\n/**\n * Load the default tablets for every assembly, if available\n *\n * Returns a map of { directory -> tablet }.\n */\nexport async function loadAllDefaultTablets(asms: readonly LoadedAssembly[]): Promise<Record<string, LanguageTablet>> {\n  return mkDict(\n    await Promise.all(\n      asms.map(\n        async (a) => [a.directory, await LanguageTablet.fromOptionalFile(guessTabletLocation(a.directory))] as const,\n      ),\n    ),\n  );\n}\n\n/**\n * Returns the location of the tablet file, either .jsii.tabl.json or .jsii.tabl.json.gz.\n * Assumes that a tablet exists in the directory and if not, the ensuing behavior is\n * handled by the caller of this function.\n */\nexport function guessTabletLocation(directory: string) {\n  return compressedTabletExists(directory)\n    ? path.join(directory, DEFAULT_TABLET_NAME_COMPRESSED)\n    : path.join(directory, DEFAULT_TABLET_NAME);\n}\n\nexport function compressedTabletExists(directory: string) {\n  return fs.existsSync(path.join(directory, DEFAULT_TABLET_NAME_COMPRESSED));\n}\n\nexport type AssemblySnippetSource =\n  | { type: 'markdown'; markdown: string; location: ApiLocation }\n  | { type: 'example'; source: string; metadata?: { [key: string]: string }; location: ApiLocation };\n\n/**\n * Return all markdown and example snippets from the given assembly\n */\nexport function allSnippetSources(assembly: spec.Assembly): AssemblySnippetSource[] {\n  const ret: AssemblySnippetSource[] = [];\n\n  if (assembly.readme) {\n    ret.push({\n      type: 'markdown',\n      markdown: assembly.readme.markdown,\n      location: { api: 'moduleReadme', moduleFqn: assembly.name },\n    });\n  }\n\n  for (const [submoduleFqn, submodule] of Object.entries(assembly.submodules ?? {})) {\n    if (submodule.readme) {\n      ret.push({\n        type: 'markdown',\n        markdown: submodule.readme.markdown,\n        location: { api: 'moduleReadme', moduleFqn: submoduleFqn },\n      });\n    }\n  }\n\n  if (assembly.types) {\n    for (const type of Object.values(assembly.types)) {\n      emitDocs(type.docs, { api: 'type', fqn: type.fqn });\n\n      if (spec.isEnumType(type)) {\n        for (const m of type.members) emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name });\n      }\n      if (spec.isClassType(type)) {\n        emitDocsForCallable(type.initializer, type.fqn);\n      }\n      if (spec.isClassOrInterfaceType(type)) {\n        for (const m of type.methods ?? []) emitDocsForCallable(m, type.fqn, m.name);\n        for (const m of type.properties ?? []) emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name });\n      }\n    }\n  }\n\n  return ret;\n\n  function emitDocsForCallable(callable: spec.Callable | undefined, fqn: string, memberName?: string) {\n    if (!callable) {\n      return;\n    }\n    emitDocs(callable.docs, memberName ? { api: 'member', fqn, memberName } : { api: 'initializer', fqn });\n\n    for (const parameter of callable.parameters ?? []) {\n      emitDocs(parameter.docs, {\n        api: 'parameter',\n        fqn: fqn,\n        methodName: memberName ?? INITIALIZER_METHOD_NAME,\n        parameterName: parameter.name,\n      });\n    }\n  }\n\n  function emitDocs(docs: spec.Docs | undefined, location: ApiLocation) {\n    if (!docs) {\n      return;\n    }\n\n    if (docs.remarks) {\n      ret.push({\n        type: 'markdown',\n        markdown: docs.remarks,\n        location,\n      });\n    }\n    if (docs.example) {\n      ret.push({\n        type: 'example',\n        source: docs.example,\n        metadata: fmap(docs.custom?.[EXAMPLE_METADATA_JSDOCTAG], parseMetadataLine),\n        location,\n      });\n    }\n  }\n}\n\nexport async function allTypeScriptSnippets(\n  assemblies: readonly LoadedAssembly[],\n  loose = false,\n): Promise<TypeScriptSnippet[]> {\n  const sources = assemblies\n    .flatMap((loaded) => allSnippetSources(loaded.assembly).map((source) => ({ source, loaded })))\n    .flatMap(({ source, loaded }) => {\n      switch (source.type) {\n        case 'example':\n          return [\n            {\n              snippet: updateParameters(\n                typeScriptSnippetFromVisibleSource(\n                  source.source,\n                  { api: source.location, field: { field: 'example' } },\n                  isStrict(loaded),\n                ),\n                source.metadata ?? {},\n              ),\n              loaded,\n            },\n          ];\n        case 'markdown':\n          return extractTypescriptSnippetsFromMarkdown(source.markdown, source.location, isStrict(loaded)).map(\n            (snippet) => ({ snippet, loaded }),\n          );\n      }\n    });\n\n  const fixtures = [];\n  for (let { snippet, loaded } of sources) {\n    const isInfused = snippet.parameters?.infused != null;\n\n    // Ignore fixturization errors if requested on this command, or if the snippet was infused\n    const ignoreFixtureErrors = loose || isInfused;\n\n    // Also if the snippet was infused: switch off 'strict' mode if it was set\n    if (isInfused) {\n      snippet = { ...snippet, strict: false };\n    }\n\n    snippet = await withDependencies(loaded, withProjectDirectory(loaded.directory, snippet));\n    fixtures.push(fixturize(snippet, ignoreFixtureErrors));\n  }\n\n  return fixtures;\n}\n\nexport interface TypeLookupAssembly {\n  readonly packageJson: any;\n  readonly assembly: spec.Assembly;\n  readonly directory: string;\n  readonly symbolIdMap: Record<string, string>;\n}\n\nconst MAX_ASM_CACHE = 3;\nconst ASM_CACHE: TypeLookupAssembly[] = [];\n\n/**\n * Recursively searches for a .jsii file in the directory.\n * When file is found, checks cache to see if we already\n * stored the assembly in memory. If not, we synchronously\n * load the assembly into memory.\n */\nexport function findTypeLookupAssembly(startingDirectory: string): TypeLookupAssembly | undefined {\n  const pjLocation = findPackageJsonLocation(path.resolve(startingDirectory));\n  if (!pjLocation) {\n    return undefined;\n  }\n  const directory = path.dirname(pjLocation);\n\n  const fromCache = ASM_CACHE.find((c) => c.directory === directory);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  const loaded = loadLookupAssembly(directory);\n  if (!loaded) {\n    return undefined;\n  }\n\n  while (ASM_CACHE.length >= MAX_ASM_CACHE) {\n    ASM_CACHE.pop();\n  }\n  ASM_CACHE.unshift(loaded);\n  return loaded;\n}\n\nfunction loadLookupAssembly(directory: string): TypeLookupAssembly | undefined {\n  try {\n    const packageJson = JSON.parse(fs.readFileSync(path.join(directory, 'package.json'), 'utf-8'));\n    const assembly: spec.Assembly = loadAssemblyFromPath(directory);\n    const symbolIdMap = mkDict([\n      ...Object.values(assembly.types ?? {}).map((type) => [type.symbolId ?? '', type.fqn] as const),\n      ...Object.entries(assembly.submodules ?? {}).map(([fqn, mod]) => [mod.symbolId ?? '', fqn] as const),\n    ]);\n\n    return {\n      packageJson,\n      assembly,\n      directory,\n      symbolIdMap,\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nfunction findPackageJsonLocation(currentPath: string): string | undefined {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const candidate = path.join(currentPath, 'package.json');\n    if (fs.existsSync(candidate)) {\n      return candidate;\n    }\n\n    const parentPath = path.resolve(currentPath, '..');\n    if (parentPath === currentPath) {\n      return undefined;\n    }\n    currentPath = parentPath;\n  }\n}\n\n/**\n * Find the jsii [sub]module that contains the given FQN\n *\n * @returns `undefined` if the type is a member of the assembly root.\n */\nexport function findContainingSubmodule(assembly: spec.Assembly, fqn: string): string | undefined {\n  const submoduleNames = Object.keys(assembly.submodules ?? {});\n  sortBy(submoduleNames, (s) => [-s.length]); // Longest first\n  for (const s of submoduleNames) {\n    if (fqn.startsWith(`${s}.`)) {\n      return s;\n    }\n  }\n  return undefined;\n}\n\nfunction withProjectDirectory(dir: string, snippet: TypeScriptSnippet) {\n  return updateParameters(snippet, {\n    [SnippetParameters.$PROJECT_DIRECTORY]: dir,\n  });\n}\n\n/**\n * Return a TypeScript snippet with dependencies added\n *\n * The dependencies will be taken from the package.json, and will consist of:\n *\n * - The package itself\n * - The package's dependencies and peerDependencies (but NOT devDependencies). Will\n *   symlink to the files on disk.\n * - Any additional dependencies declared in `jsiiRosetta.exampleDependencies`.\n */\nasync function withDependencies(asm: LoadedAssembly, snippet: TypeScriptSnippet): Promise<TypeScriptSnippet> {\n  const compilationDependencies: Record<string, CompilationDependency> = {};\n\n  if (await pathExists(path.join(asm.directory, 'package.json'))) {\n    compilationDependencies[asm.assembly.name] = {\n      type: 'concrete',\n      resolvedDirectory: await fsPromises.realpath(asm.directory),\n    };\n  }\n\n  Object.assign(compilationDependencies, await resolveDependenciesFromPackageJson(asm.packageJson, asm.directory));\n\n  Object.assign(\n    compilationDependencies,\n    mkDict(\n      Object.entries(asm.packageJson?.jsiiRosetta?.exampleDependencies ?? {}).map(\n        ([name, versionRange]) => [name, { type: 'symbolic', versionRange }] as const,\n      ),\n    ),\n  );\n\n  return {\n    ...snippet,\n    compilationDependencies,\n  };\n}\n\n/**\n * Whether samples in the assembly should be treated as strict\n *\n * True if the strict flag is found in the package.json (modern) or the assembly itself (legacy).\n */\nfunction isStrict(loaded: LoadedAssembly) {\n  return loaded.packageJson?.jsiiRosetta?.strict ?? enforcesStrictMode(loaded.assembly);\n}\n"]}