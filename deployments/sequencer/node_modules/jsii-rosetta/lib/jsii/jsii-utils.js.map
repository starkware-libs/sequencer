{"version":3,"file":"jsii-utils.js","sourceRoot":"","sources":["../../src/jsii/jsii-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as spec from '@jsii/spec';\nimport { symbolIdentifier } from 'jsii/common';\nimport * as ts from 'typescript';\n\nimport { findTypeLookupAssembly, TypeLookupAssembly } from './assemblies';\nimport { ObjectLiteralStruct } from './jsii-types';\nimport { AstRenderer } from '../renderer';\nimport { typeContainsUndefined } from '../typescript/types';\nimport { fmap } from '../util';\n\nexport function isNamedLikeStruct(name: string) {\n  // Start with an I and another uppercase character\n  return !/^I[A-Z]/.test(name);\n}\n\nexport function analyzeStructType(typeChecker: ts.TypeChecker, type: ts.Type): ObjectLiteralStruct | false {\n  if (\n    !type.isClassOrInterface() ||\n    !hasAllFlags(type.objectFlags, ts.ObjectFlags.Interface) ||\n    !isNamedLikeStruct(type.symbol.name)\n  ) {\n    return false;\n  }\n\n  const jsiiSym = lookupJsiiSymbol(typeChecker, type.symbol);\n  if (jsiiSym) {\n    return { kind: 'struct', type, jsiiSym };\n  }\n\n  return { kind: 'local-struct', type };\n}\n\n/**\n * Whether the given type is a protocol AND comes from jsii\n *\n * - Protocol: a TypeScript interface that is *not* a \"struct\" type.\n *   A.k.a. \"behavioral interface\".\n * - From jsii: whether the interface type is defined in and exported\n *   via a jsii assembly. There can be literal interfaces defined\n *   in an example, and they will not be mangled in the same way\n *   as a jsii interface would be.\n *\n *\n * Examples:\n *\n * ```ts\n * // isJsiiProtocolType() -> false: not a protocol\n * interface Banana {\n *   readonly arc: number;\n * }\n *\n * // isJsiiProtocolType() -> might be true: depends on whether it was defined\n * // in a jsii assembly.\n * interface IHello {\n *   sayIt(): void;\n * }\n *\n * // isJsiiProtocolType() -> false: declared to not be a protocol, even though\n * // it has the naming scheme of one\n * /**\n *  * @struct\n *  * /\n * interface IPAddress {\n *   readonly octets: number[];\n * }\n * ```\n */\nexport function isJsiiProtocolType(typeChecker: ts.TypeChecker, type: ts.Type): boolean | undefined {\n  if (!type.isClassOrInterface() || !hasAllFlags(type.objectFlags, ts.ObjectFlags.Interface)) {\n    return false;\n  }\n\n  const sym = lookupJsiiSymbol(typeChecker, type.symbol);\n  if (!sym) {\n    return false;\n  }\n\n  if (!sym.sourceAssembly) {\n    // No source assembly, so this is a 'fake-from-jsii' type\n    return !isNamedLikeStruct(type.symbol.name);\n  }\n\n  const jsiiType = resolveJsiiSymbolType(sym);\n  return spec.isInterfaceType(jsiiType) && !jsiiType.datatype;\n}\n\nexport function hasAllFlags<A extends number>(flags: A, test: A) {\n  // tslint:disable-next-line:no-bitwise\n  return test !== 0 && (flags & test) === test;\n}\n\nexport function hasAnyFlag<A extends number>(flags: A, test: A) {\n  // tslint:disable-next-line:no-bitwise\n  return test !== 0 && (flags & test) !== 0;\n}\n\nexport interface StructProperty {\n  name: string;\n  type: ts.Type | undefined;\n  questionMark: boolean;\n}\n\nexport function propertiesOfStruct(type: ts.Type, context: AstRenderer<any>): StructProperty[] {\n  return type.isClassOrInterface()\n    ? type.getProperties().map((s) => {\n        let propType;\n        let questionMark = false;\n\n        const propSymbol = type.getProperty(s.name)!;\n        const symbolDecl = propSymbol.valueDeclaration ?? propSymbol.declarations![0];\n        if (ts.isPropertyDeclaration(symbolDecl) || ts.isPropertySignature(symbolDecl)) {\n          questionMark = symbolDecl.questionToken !== undefined;\n          propType = symbolDecl.type && context.typeOfType(symbolDecl.type);\n        }\n\n        return {\n          name: s.name,\n          type: propType,\n          questionMark,\n        };\n      })\n    : [];\n}\n\nexport function structPropertyAcceptsUndefined(prop: StructProperty): boolean {\n  return prop.questionMark || (!!prop.type && typeContainsUndefined(prop.type));\n}\n\n/**\n * A TypeScript symbol resolved to its jsii type\n */\nexport interface JsiiSymbol {\n  /**\n   * FQN of the symbol\n   *\n   * Is either the FQN of a type (for a type). For a membr, the FQN looks like:\n   * 'type.fqn#memberName'.\n   */\n  readonly fqn: string;\n\n  /**\n   * What kind of symbol this is\n   */\n  readonly symbolType: 'module' | 'type' | 'member';\n\n  /**\n   * Assembly where the type was found\n   *\n   * Might be undefined if the type was FAKE from jsii (for tests)\n   */\n  readonly sourceAssembly?: TypeLookupAssembly;\n}\n\nexport function lookupJsiiSymbolFromNode(typeChecker: ts.TypeChecker, node: ts.Node): JsiiSymbol | undefined {\n  return fmap(typeChecker.getSymbolAtLocation(node), (s) => lookupJsiiSymbol(typeChecker, s));\n}\n\nexport function resolveJsiiSymbolType(jsiiSymbol: JsiiSymbol): spec.Type {\n  if (jsiiSymbol.symbolType !== 'type') {\n    throw new Error(\n      `Expected symbol to refer to a 'type', got '${jsiiSymbol.fqn}' which is a '${jsiiSymbol.symbolType}'`,\n    );\n  }\n\n  if (!jsiiSymbol.sourceAssembly) {\n    throw new Error('`resolveJsiiSymbolType: requires an actual source assembly');\n  }\n\n  const type = jsiiSymbol.sourceAssembly?.assembly.types?.[jsiiSymbol.fqn];\n  if (!type) {\n    throw new Error(\n      `resolveJsiiSymbolType: ${jsiiSymbol.fqn} not found in assembly ${jsiiSymbol.sourceAssembly.assembly.name}`,\n    );\n  }\n  return type;\n}\n\n/**\n * Returns the jsii FQN for a TypeScript (class or type) symbol\n *\n * TypeScript only knows the symbol NAME plus the FILE the symbol is defined\n * in. We need to extract two things:\n *\n * 1. The package name (extracted from the nearest `package.json`)\n * 2. The submodule name (...?? don't know how to get this yet)\n * 3. Any containing type names or namespace names.\n *\n * For tests, we also treat symbols in a file that has the string '/// fake-from-jsii'\n * as coming from jsii.\n */\nexport function lookupJsiiSymbol(typeChecker: ts.TypeChecker, sym: ts.Symbol): JsiiSymbol | undefined {\n  // Resolve alias, if it is one. This comes into play if the symbol refers to a module,\n  // we need to resolve the alias to find the ACTUAL module.\n  if (hasAnyFlag(sym.flags, ts.SymbolFlags.Alias)) {\n    sym = typeChecker.getAliasedSymbol(sym);\n  }\n\n  const decl: ts.Node | undefined = sym.declarations?.[0];\n  if (!decl) {\n    return undefined;\n  }\n\n  if (ts.isSourceFile(decl)) {\n    // This is a module.\n    const sourceAssembly = findTypeLookupAssembly(decl.fileName);\n    return fmap(\n      sourceAssembly,\n      (asm) =>\n        ({\n          fqn:\n            fmap(\n              symbolIdentifier(\n                typeChecker,\n                sym,\n                fmap(sourceAssembly, (sa) => ({ assembly: sa.assembly })),\n              ),\n              (symbolId) => sourceAssembly?.symbolIdMap[symbolId],\n            ) ?? sourceAssembly?.assembly.name,\n          sourceAssembly: asm,\n          symbolType: 'module',\n        } as JsiiSymbol),\n    );\n  }\n\n  if (!isDeclaration(decl)) {\n    return undefined;\n  }\n\n  const declaringFile = decl.getSourceFile();\n  if (/^\\/\\/\\/ fake-from-jsii/m.test(declaringFile.getFullText())) {\n    return { fqn: `fake_jsii.${sym.name}`, symbolType: 'type' };\n  }\n\n  const declSym = getSymbolFromDeclaration(decl, typeChecker);\n  if (!declSym) {\n    return undefined;\n  }\n\n  const fileName = decl.getSourceFile().fileName;\n  const sourceAssembly = findTypeLookupAssembly(fileName);\n  const symbolId = symbolIdentifier(typeChecker, declSym, { assembly: sourceAssembly?.assembly });\n  if (!symbolId) {\n    return undefined;\n  }\n\n  return fmap(/([^#]*)(#.*)?/.exec(symbolId), ([, typeSymbolId, memberFragment]) => {\n    if (memberFragment) {\n      return fmap(sourceAssembly?.symbolIdMap[typeSymbolId], (fqn) => ({\n        fqn: `${fqn}${memberFragment}`,\n        sourceAssembly,\n        symbolType: 'member',\n      }));\n    }\n\n    return fmap(sourceAssembly?.symbolIdMap[typeSymbolId], (fqn) => ({ fqn, sourceAssembly, symbolType: 'type' }));\n  });\n}\n\nfunction isDeclaration(x: ts.Node): x is ts.Declaration {\n  return (\n    ts.isClassDeclaration(x) ||\n    ts.isNamespaceExportDeclaration(x) ||\n    ts.isNamespaceExport(x) ||\n    ts.isModuleDeclaration(x) ||\n    ts.isEnumDeclaration(x) ||\n    ts.isEnumMember(x) ||\n    ts.isInterfaceDeclaration(x) ||\n    ts.isMethodDeclaration(x) ||\n    ts.isMethodSignature(x) ||\n    ts.isPropertyDeclaration(x) ||\n    ts.isPropertySignature(x)\n  );\n}\n\n/**\n * If the given type is an enum literal, resolve to the enum type\n */\nexport function resolveEnumLiteral(typeChecker: ts.TypeChecker, type: ts.Type) {\n  if (!hasAnyFlag(type.flags, ts.TypeFlags.EnumLiteral)) {\n    return type;\n  }\n\n  return typeChecker.getBaseTypeOfLiteralType(type);\n}\n\nexport function resolvedSymbolAtLocation(typeChecker: ts.TypeChecker, node: ts.Node) {\n  let symbol = typeChecker.getSymbolAtLocation(node);\n  while (symbol && hasAnyFlag(symbol.flags, ts.SymbolFlags.Alias)) {\n    symbol = typeChecker.getAliasedSymbol(symbol);\n  }\n  return symbol;\n}\n\nfunction getSymbolFromDeclaration(decl: ts.Node, typeChecker: ts.TypeChecker): ts.Symbol | undefined {\n  if (!isDeclaration(decl)) {\n    return undefined;\n  }\n\n  const name = ts.getNameOfDeclaration(decl);\n  return name ? typeChecker.getSymbolAtLocation(name) : undefined;\n}\n\nexport function parentSymbol(sym: JsiiSymbol): JsiiSymbol | undefined {\n  const parts = sym.fqn.split('.');\n  if (parts.length === 1) {\n    return undefined;\n  }\n\n  return {\n    fqn: parts.slice(0, -1).join('.'),\n    symbolType: 'module', // Might not be true, but probably good enough\n    sourceAssembly: sym.sourceAssembly,\n  };\n}\n\n/**\n * Get the last part of a dot-separated string\n */\nexport function simpleName(x: string) {\n  return x.split('.').slice(-1)[0];\n}\n\n/**\n * Get all parts except the last of a dot-separated string\n */\nexport function namespaceName(x: string) {\n  return x.split('.').slice(0, -1).join('.');\n}\n"]}