{"version":3,"file":"jsii-types.js","sourceRoot":"","sources":["../../src/jsii/jsii-types.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { hasAnyFlag, analyzeStructType, JsiiSymbol } from './jsii-utils';\nimport { inferredTypeOfExpression, BuiltInType, builtInTypeName, mapElementType } from '../typescript/types';\n\n// eslint-disable-next-line prettier/prettier\nexport type JsiiType =\n  | { kind: 'unknown' }\n  | { kind: 'error'; message: string }\n  | { kind: 'map' | 'list'; elementType: JsiiType; elementTypeSymbol: ts.Symbol | undefined }\n  | { kind: 'namedType'; name: string }\n  | { kind: 'builtIn'; builtIn: BuiltInType };\n\nexport function determineJsiiType(typeChecker: ts.TypeChecker, type: ts.Type): JsiiType {\n  // this means the snippet didn't have enough info for the TypeScript compiler to figure out the type -\n  // so, just render the fallback\n  if ((type as any).intrinsicName === 'error') {\n    return { kind: 'unknown' };\n  }\n\n  // The non-nullable version of `void` is `never`, so check first...\n  if ((type.flags & (ts.TypeFlags.Void | ts.TypeFlags.VoidLike)) !== 0) {\n    return { kind: 'builtIn', builtIn: 'void' };\n  }\n  // The non-nullable version of `unknown` is some ObjectType, so check first...\n  if ((type.flags & (ts.TypeFlags.Unknown | ts.TypeFlags.Any)) !== 0) {\n    return { kind: 'builtIn', builtIn: 'any' };\n  }\n\n  type = type.getNonNullableType();\n\n  const mapValuesType = mapElementType(type, typeChecker);\n  if (mapValuesType.result === 'map') {\n    return {\n      kind: 'map',\n      elementType: mapValuesType.elementType\n        ? determineJsiiType(typeChecker, mapValuesType.elementType)\n        : { kind: 'builtIn', builtIn: 'any' },\n      elementTypeSymbol: mapValuesType.elementType?.symbol,\n    };\n  }\n\n  if (type.symbol?.name === 'Array') {\n    const typeRef = type as ts.TypeReference;\n\n    if (typeRef.typeArguments?.length === 1) {\n      return {\n        kind: 'list',\n        elementType: determineJsiiType(typeChecker, typeRef.typeArguments[0]),\n        elementTypeSymbol: typeRef.typeArguments[0].symbol,\n      };\n    }\n\n    return {\n      kind: 'list',\n      elementType: { kind: 'builtIn', builtIn: 'any' },\n      elementTypeSymbol: undefined,\n    };\n  }\n\n  // User-defined or aliased type\n  if (type.aliasSymbol) {\n    return { kind: 'namedType', name: type.aliasSymbol.name };\n  }\n  if (type.symbol) {\n    return { kind: 'namedType', name: type.symbol.name };\n  }\n\n  const typeScriptBuiltInType = builtInTypeName(type);\n  if (typeScriptBuiltInType) {\n    return { kind: 'builtIn', builtIn: typeScriptBuiltInType };\n  }\n\n  if (type.isUnion() || type.isIntersection()) {\n    return {\n      kind: 'error',\n      message: `Type unions or intersections are not supported in examples, got: ${typeChecker.typeToString(type)}`,\n    };\n  }\n\n  return { kind: 'unknown' };\n}\n\nexport type ObjectLiteralAnalysis = ObjectLiteralStruct | { readonly kind: 'map' } | { readonly kind: 'unknown' };\n\nexport type ObjectLiteralStruct =\n  | { readonly kind: 'struct'; readonly type: ts.Type; readonly jsiiSym: JsiiSymbol }\n  | { readonly kind: 'local-struct'; readonly type: ts.Type };\n\nexport function analyzeObjectLiteral(\n  typeChecker: ts.TypeChecker,\n  node: ts.ObjectLiteralExpression,\n): ObjectLiteralAnalysis {\n  const type = inferredTypeOfExpression(typeChecker, node);\n  if (!type) {\n    return { kind: 'unknown' };\n  }\n\n  const call = findEnclosingCallExpression(node);\n  const isDeclaredCall = !!(call && typeChecker.getResolvedSignature(call)?.declaration);\n\n  if (hasAnyFlag(type.flags, ts.TypeFlags.Any)) {\n    // The type checker by itself won't tell us the difference between an `any` that\n    // was literally declared as a type in the code, vs an `any` it assumes because it\n    // can't find a function's type declaration.\n    //\n    // Search for the function's declaration and only if we can't find it,\n    // the type is actually unknown (otherwise it's a literal 'any').\n    return isDeclaredCall ? { kind: 'map' } : { kind: 'unknown' };\n  }\n\n  // If the type is a union between a struct and something else, return the first possible struct\n  const structCandidates = type.isUnion() ? type.types : [type];\n  for (const candidate of structCandidates) {\n    const structType = analyzeStructType(typeChecker, candidate);\n    if (structType) {\n      return structType;\n    }\n  }\n\n  return { kind: 'map' };\n}\n\nfunction findEnclosingCallExpression(node?: ts.Node): ts.CallLikeExpression | undefined {\n  while (node) {\n    if (ts.isCallLikeExpression(node)) {\n      return node;\n    }\n    node = node.parent;\n  }\n\n  return undefined;\n}\n"]}