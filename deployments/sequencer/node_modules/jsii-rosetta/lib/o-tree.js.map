{"version":3,"file":"o-tree.js","sourceRoot":"","sources":["../src/o-tree.ts"],"names":[],"mappings":"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","sourcesContent":["import { Spans } from './typescript/visible-spans';\n\nexport interface OTreeOptions {\n  /**\n   * Adjust indentation with the given number\n   *\n   * Indentation affects children.\n   *\n   * @default 0\n   */\n  indent?: number;\n\n  /**\n   * Separate children with the given string\n   *\n   * @default ''\n   */\n  separator?: string;\n\n  /**\n   * Whether trailing separators should be output. This imples children will be\n   * writen each on a new line.\n   *\n   * @default false\n   */\n  trailingSeparator?: boolean;\n\n  /**\n   * Suffix the token after outdenting\n   *\n   * @default ''\n   */\n  suffix?: string;\n\n  /**\n   * Whether this part of the generated syntax is okay to insert newlines and comments\n   *\n   * @default false\n   */\n  canBreakLine?: boolean;\n\n  /**\n   * If set, a unique key which will cause only one node with the given key to be rendered.\n   *\n   * The outermost key is the one that will be rendered.\n   *\n   * Used to make it easier to keep the state necessary to render comments\n   * only once in the output tree, rather than keep the state in the\n   * language rendered.\n   *\n   * @default No conditional rendering\n   */\n  renderOnce?: string;\n}\n\n/**\n * \"Output\" Tree\n *\n * Tree-like structure that holds sequences of trees and strings, which\n * can be rendered to an output sink.\n */\nexport class OTree implements OTree {\n  public static simplify(xs: Array<OTree | string | undefined>): Array<OTree | string> {\n    return xs.filter(notUndefined).filter(notEmpty);\n  }\n\n  public readonly attachComment: boolean;\n\n  private readonly prefix: Array<OTree | string>;\n  private readonly children: Array<OTree | string>;\n  private span?: Span;\n\n  public constructor(\n    prefix: Array<OTree | string | undefined>,\n    children?: Array<OTree | string | undefined>,\n    private readonly options: OTreeOptions = {},\n  ) {\n    this.prefix = OTree.simplify(prefix);\n    this.children = OTree.simplify(children ?? []);\n    this.attachComment = !!options.canBreakLine;\n  }\n\n  /**\n   * Set the span in the source file this tree node relates to\n   */\n  public setSpan(start: number, end: number) {\n    this.span = { start, end };\n  }\n\n  public write(sink: OTreeSink) {\n    if (!sink.tagOnce(this.options.renderOnce)) {\n      return;\n    }\n\n    const meVisible = sink.renderingForSpan(this.span);\n\n    for (const x of this.prefix) {\n      sink.write(x);\n    }\n\n    const popIndent = sink.requestIndentChange(meVisible ? this.options.indent ?? 0 : 0);\n    let mark = sink.mark();\n\n    for (const child of this.children ?? []) {\n      if (this.options.separator) {\n        if (this.options.trailingSeparator) {\n          sink.ensureNewLine();\n        } else if (mark.wroteNonWhitespaceSinceMark) {\n          sink.write(this.options.separator);\n        }\n      }\n      mark = sink.mark();\n\n      sink.write(child);\n\n      if (this.options.separator && this.options.trailingSeparator) {\n        sink.write(this.options.separator.trimEnd());\n      }\n    }\n\n    popIndent();\n\n    if (this.options.suffix) {\n      if (this.options.separator && this.options.trailingSeparator) {\n        sink.ensureNewLine();\n      }\n      sink.renderingForSpan(this.span);\n      sink.write(this.options.suffix);\n    }\n  }\n\n  public get isEmpty() {\n    return this.prefix.length + this.children.length === 0;\n  }\n\n  public toString() {\n    return `<INCORRECTLY STRINGIFIED ${this.prefix.toString()}>`;\n  }\n}\n\nexport const NO_SYNTAX = new OTree([]);\n\nexport class UnknownSyntax extends OTree {}\n\nexport interface SinkMark {\n  readonly wroteNonWhitespaceSinceMark: boolean;\n}\n\nexport interface OTreeSinkOptions {\n  /**\n   * @default ' '\n   */\n  indentChar?: ' ' | '\\t';\n  visibleSpans?: Spans;\n}\n\ninterface ConditionalNewLine {\n  readonly conditionalNewLine: {\n    readonly indent: number;\n  };\n}\n\n/**\n * Output sink for OTree objects\n *\n * Maintains state about what has been rendered supports suppressing code\n * fragments based on their tagged source location.\n *\n * Basically: manages the state that was too hard to manage in the\n * tree :).\n */\nexport class OTreeSink {\n  private readonly indentChar: ' ' | '\\t';\n  private readonly indentLevels: number[] = [0];\n  private readonly fragments = new Array<string | ConditionalNewLine>();\n  private readonly singletonsRendered = new Set<string>();\n  private pendingIndentChange = 0;\n  private rendering = true;\n\n  public constructor(private readonly options: OTreeSinkOptions = {}) {\n    this.indentChar = options.indentChar ?? ' ';\n  }\n\n  public tagOnce(key: string | undefined): boolean {\n    if (key === undefined) {\n      return true;\n    }\n    if (this.singletonsRendered.has(key)) {\n      return false;\n    }\n    this.singletonsRendered.add(key);\n    return true;\n  }\n\n  /**\n   * Get a mark for the current sink output location\n   *\n   * Marks can be used to query about things that have been written to output.\n   */\n  public mark(): SinkMark {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const markIndex = this.fragments.length;\n\n    return {\n      get wroteNonWhitespaceSinceMark(): boolean {\n        return self.fragments.slice(markIndex).some((s) => typeof s !== 'object' && /[^\\s]/.exec(s) != null);\n      },\n    };\n  }\n\n  public write(text: string | OTree) {\n    if (text instanceof OTree) {\n      text.write(this);\n    } else {\n      if (!this.rendering) {\n        return;\n      }\n\n      if (containsNewline(text)) {\n        this.applyPendingIndentChange();\n      }\n      this.append(text.replace(/\\n/g, `\\n${this.indentChar.repeat(this.currentIndent)}`));\n    }\n  }\n\n  /**\n   * Ensures the following tokens will be output on a new line (emits a new line\n   * and indent unless immediately preceded or followed by a newline, ignoring\n   * surrounding white space).\n   */\n  public ensureNewLine(): void {\n    this.applyPendingIndentChange();\n    this.fragments.push({ conditionalNewLine: { indent: this.currentIndent } });\n  }\n\n  public renderingForSpan(span?: Span): boolean {\n    if (span && this.options.visibleSpans) {\n      this.rendering = this.options.visibleSpans.fullyContainsSpan(span);\n    }\n    return this.rendering;\n  }\n\n  public requestIndentChange(x: number): () => void {\n    if (x === 0) {\n      return () => undefined;\n    }\n\n    this.pendingIndentChange = x;\n    const currentIndentState = this.indentLevels.length;\n\n    // Return a pop function which will reset to the current indent state,\n    // regardless of whether the indent was actually applied or not.\n    return () => {\n      this.indentLevels.splice(currentIndentState);\n      this.pendingIndentChange = 0;\n    };\n  }\n\n  public toString() {\n    // Strip trailing whitespace from every line, and empty lines from the start and end\n    return this.fragments\n      .map((item, index, fragments) => {\n        if (typeof item !== 'object') {\n          return item;\n        }\n        const ignore = '';\n\n        const leading = fragments.slice(0, index).reverse();\n        for (const fragment of leading) {\n          if (typeof fragment === 'object') {\n            // We don't emit if there was already a conditional newline just before\n            return ignore;\n          }\n          // If there's a trailing newline, then we don't emit this one\n          if (/\\n\\s*$/m.exec(fragment)) {\n            return ignore;\n          }\n          // If it contained non-whitespace characters, we need to check trailing data...\n          if (/[^\\s]/.exec(fragment)) {\n            break;\n          }\n        }\n\n        const newlineAndIndent = `\\n${this.indentChar.repeat(item.conditionalNewLine.indent)}`;\n\n        const trailing = fragments.slice(index + 1);\n        for (const fragment of trailing) {\n          if (typeof fragment === 'object') {\n            // We're the first of a sequence, so we must emit (unless we returned earlier, of course)\n            return newlineAndIndent;\n          }\n          // If there's a leading newline, then we don't emit this one\n          if (/^\\s*\\n/m.exec(fragment)) {\n            return ignore;\n          }\n          // If it contained non-whitespace characters, we emit this one\n          if (/[^\\s]/.exec(fragment)) {\n            return newlineAndIndent;\n          }\n        }\n\n        return ignore;\n      })\n      .join('')\n      .replace(/[ \\t]+$/gm, '')\n      .replace(/^\\n+/, '')\n      .replace(/\\n+$/, '');\n  }\n\n  private append(x: string) {\n    this.fragments.push(x);\n  }\n\n  private applyPendingIndentChange() {\n    if (this.pendingIndentChange !== 0) {\n      this.indentLevels.push(this.currentIndent + this.pendingIndentChange);\n      this.pendingIndentChange = 0;\n    }\n  }\n\n  private get currentIndent() {\n    return this.indentLevels[this.indentLevels.length - 1];\n  }\n}\n\nfunction notUndefined<T>(x: T | undefined): x is T {\n  return x !== undefined;\n}\n\nfunction notEmpty(x: OTree | string) {\n  return x instanceof OTree ? !x.isEmpty : x !== '';\n}\n\nexport function renderTree(tree: OTree, options?: OTreeSinkOptions): string {\n  const sink = new OTreeSink(options);\n  tree.write(sink);\n  return sink.toString();\n}\n\nfunction containsNewline(x: string) {\n  return x.includes('\\n');\n}\n\nexport interface Span {\n  readonly start: number;\n  readonly end: number;\n}\n"]}