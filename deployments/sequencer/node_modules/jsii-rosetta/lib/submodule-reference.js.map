{"version":3,"file":"submodule-reference.js","sourceRoot":"","sources":["../src/submodule-reference.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nexport type SubmoduleReferenceMap = ReadonlyMap<\n  ts.PropertyAccessExpression | ts.LeftHandSideExpression | ts.Identifier | ts.PrivateIdentifier,\n  SubmoduleReference\n>;\n\nexport class SubmoduleReference {\n  public static inSourceFile(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker): SubmoduleReferenceMap {\n    const importDeclarations = sourceFile.statements\n      .filter((stmt) => ts.isImportDeclaration(stmt))\n      .flatMap((stmt) => importedSymbolsFrom(stmt as ts.ImportDeclaration, sourceFile, typeChecker));\n\n    return SubmoduleReference.inNode(sourceFile, typeChecker, new Set(importDeclarations));\n  }\n\n  private static inNode(\n    node: ts.Node,\n    typeChecker: ts.TypeChecker,\n    importDeclarations: ReadonlySet<ts.Symbol>,\n    map = new Map<\n      ts.PropertyAccessExpression | ts.LeftHandSideExpression | ts.Identifier | ts.PrivateIdentifier,\n      SubmoduleReference\n    >(),\n  ): Map<\n    ts.PropertyAccessExpression | ts.LeftHandSideExpression | ts.Identifier | ts.PrivateIdentifier,\n    SubmoduleReference\n  > {\n    if (ts.isPropertyAccessExpression(node)) {\n      const [head, ...tail] = propertyPath(node);\n      const symbol = typeChecker.getSymbolAtLocation(head.name);\n      if (symbol && importDeclarations.has(symbol)) {\n        // This is a reference within an imported namespace, so we need to record that...\n        const firstNonNamespace = tail.findIndex((item) => !isLikelyNamespace(item.name, typeChecker));\n        if (firstNonNamespace < 0) {\n          map.set(node.expression, new SubmoduleReference(symbol, node.expression, []));\n        } else {\n          const tailEnd = tail[firstNonNamespace].expression;\n          const path = tail.slice(0, firstNonNamespace).map((item) => item.name);\n          map.set(tailEnd, new SubmoduleReference(symbol, tailEnd, path));\n        }\n      }\n\n      return map;\n    }\n\n    // Faster than ||-ing a bung of if statements to avoid traversing uninteresting nodes...\n    switch (node.kind) {\n      case ts.SyntaxKind.ImportDeclaration:\n      case ts.SyntaxKind.ExportDeclaration:\n        break;\n      default:\n        for (const child of node.getChildren()) {\n          map = SubmoduleReference.inNode(child, typeChecker, importDeclarations, map);\n        }\n    }\n\n    return map;\n  }\n\n  private constructor(\n    public readonly root: ts.Symbol,\n    public readonly submoduleChain: ts.LeftHandSideExpression | ts.Identifier | ts.PrivateIdentifier,\n    public readonly path: readonly ts.Node[],\n  ) {}\n\n  public get lastNode(): ts.Node {\n    if (this.path.length === 0) {\n      const node = this.root.valueDeclaration ?? this.root.declarations![0];\n      return ts.isNamespaceImport(node) || ts.isImportSpecifier(node) ? node.name : node;\n    }\n    return this.path[this.path.length - 1];\n  }\n\n  public toString(): string {\n    return `${this.constructor.name}<root=${this.root.name}, path=${JSON.stringify(\n      this.path.map((item) => item.getText(item.getSourceFile())),\n    )}>`;\n  }\n}\n\n/**\n * Determines what symbols are imported by the given TypeScript import\n * delcaration, in the context of the specified file, using the provided type\n * checker.\n *\n * @param decl        an import declaration.\n * @param sourceFile  the source file that contains the import declaration.\n * @param typeChecker a TypeChecker instance valid for the provided source file.\n *\n * @returns the (possibly empty) list of symbols imported by this declaration.\n */\nfunction importedSymbolsFrom(\n  decl: ts.ImportDeclaration,\n  sourceFile: ts.SourceFile,\n  typeChecker: ts.TypeChecker,\n): ts.Symbol[] {\n  const { importClause } = decl;\n\n  if (importClause == null) {\n    // This is a \"for side effects\" import, which isn't relevant for our business here...\n    return [];\n  }\n\n  const { name, namedBindings } = importClause;\n  const imports = new Array<ts.Symbol>();\n\n  if (name != null) {\n    const symbol = typeChecker.getSymbolAtLocation(name);\n    if (symbol == null) {\n      throw new Error(`No symbol was defined for node ${name.getText(sourceFile)}`);\n    }\n    imports.push(symbol);\n  }\n  if (namedBindings != null) {\n    if (ts.isNamespaceImport(namedBindings)) {\n      const { name: bindingName } = namedBindings;\n      const symbol = typeChecker.getSymbolAtLocation(bindingName);\n      if (symbol == null) {\n        throw new Error(`No symbol was defined for node ${bindingName.getText(sourceFile)}`);\n      }\n      imports.push(symbol);\n    } else {\n      for (const specifier of namedBindings.elements) {\n        const { name: specifierName } = specifier;\n        const symbol = typeChecker.getSymbolAtLocation(specifierName);\n        if (symbol == null) {\n          throw new Error(`No symbol was defined for node ${specifierName.getText(sourceFile)}`);\n        }\n        imports.push(symbol);\n      }\n    }\n  }\n\n  return imports;\n}\n\ninterface PathEntry {\n  readonly name: ts.Identifier | ts.PrivateIdentifier | ts.LeftHandSideExpression;\n  readonly expression: ts.LeftHandSideExpression;\n}\n\nfunction propertyPath(node: ts.PropertyAccessExpression): readonly PathEntry[] {\n  const { expression, name } = node;\n  if (!ts.isPropertyAccessExpression(expression)) {\n    return [\n      { name: expression, expression },\n      { name, expression },\n    ];\n  }\n  return [...propertyPath(expression), { name, expression }];\n}\n\n/**\n * A heuristic to determine whether the provided node likely refers to some\n * namespace.\n *\n * @param node        the node to be checked.\n * @param typeChecker a type checker that can obtain symbols for this node.\n *\n * @returns true if the node likely refers to a namespace name.\n */\nfunction isLikelyNamespace(node: ts.Node, typeChecker: ts.TypeChecker): boolean {\n  if (!ts.isIdentifier(node)) {\n    return false;\n  }\n\n  // If the identifier was bound to a symbol, we can inspect the declarations of\n  // it to validate they are all module or namespace declarations.\n  const symbol = typeChecker.getSymbolAtLocation(node);\n  if (symbol != null) {\n    return (\n      symbol.declarations!.length > 0 &&\n      symbol.declarations!.every(\n        (decl) => ts.isModuleDeclaration(decl) || ts.isNamespaceExport(decl) || ts.isNamespaceImport(decl),\n      )\n    );\n  }\n\n  // We understand this is likely a namespace if the name does not start with\n  // upper-case letter.\n  return !startsWithUpperCase(node.text);\n}\n\nfunction startsWithUpperCase(text: string): boolean {\n  return text.length > 0 && text[0] === text[0].toUpperCase();\n}\n"]}