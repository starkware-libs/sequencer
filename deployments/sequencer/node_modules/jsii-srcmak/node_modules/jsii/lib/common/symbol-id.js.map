{"version":3,"file":"symbol-id.js","sourceRoot":"","sources":["../../src/common/symbol-id.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { Assembly } from '@jsii/spec';\nimport * as ts from 'typescript';\n\nimport { findUp } from './find-utils';\n\n/**\n * Additional options that may be provided to the symbolIdentifier.\n */\ninterface SymbolIdOptions {\n  /**\n   * The assembly that the symbol is found in.\n   * This is used to provide the correct root directory\n   * as specified in the assembly metadata. In turn,\n   * the root directory is used to ensure that the\n   * symbolId comes from source code and not compiled code.\n   */\n  readonly assembly?: Assembly;\n}\n\n/**\n * Return a symbol identifier for the given symbol\n *\n * The symbol identifier identifies a TypeScript symbol in a source file inside\n * a package. We can use this to map between jsii entries in the manifest, and\n * entities in the TypeScript source code.\n *\n * Going via symbol id is the only way to identify symbols in submodules. Otherwise,\n * all the TypeScript compiler sees is:\n *\n * ```\n * /my/package/lib/source/directory/dist.js <containing> MyClass\n * ```\n *\n * And there's no way to figure out what submodule name\n * `lib/source/directory/dist` is exported as.\n *\n * The format of a symbol id is:\n *\n * ```\n * relative/source/file:Name.space.Class[#member]\n * ```\n *\n * We used to build this identifier ourselves. Turns out there was a built-in\n * way to get pretty much the same, by calling `typeChecker.getFullyQualifiedName()`.\n * Whoops ^_^ (this historical accident is why the format is similar to but\n * different from what the TS checker returns).\n */\nexport function symbolIdentifier(\n  typeChecker: ts.TypeChecker,\n  sym: ts.Symbol | undefined,\n  options: SymbolIdOptions = {},\n): string | undefined {\n  if (!sym) {\n    return undefined;\n  }\n\n  // If this symbol happens to be an alias, resolve it first\n  // eslint-disable-next-line no-bitwise\n  while ((sym.flags & ts.SymbolFlags.Alias) !== 0) {\n    sym = typeChecker.getAliasedSymbol(sym);\n  }\n\n  const isMember =\n    // eslint-disable-next-line no-bitwise\n    (sym.flags &\n      // eslint-disable-next-line no-bitwise\n      (ts.SymbolFlags.Method |\n        // eslint-disable-next-line no-bitwise\n        ts.SymbolFlags.Property |\n        ts.SymbolFlags.EnumMember)) !==\n    0;\n\n  const tsName = typeChecker.getFullyQualifiedName(sym);\n\n  // TypeScript fqn looks like \"/path/to/file\"[.name.in.file]\n  const groups = /^\"([^\"]+)\"(?:\\.(.*))?$/.exec(tsName);\n  if (!groups) {\n    return undefined;\n  }\n\n  const [, fileName, inFileName] = groups; // inFileName may be absent\n\n  const relFile = Helper.for(typeChecker).assemblyRelativeSourceFile(fileName, options?.assembly);\n  if (!relFile) {\n    return undefined;\n  }\n\n  // If this is a member symbol, replace the final '.' with a '#'\n  const typeSymbol = isMember ? (inFileName ?? '').replace(/\\.([^.]+)$/, '#$1') : inFileName ?? '';\n\n  return `${relFile}:${typeSymbol}`;\n}\n\nclass Helper {\n  public static for(typeChecker: ts.TypeChecker) {\n    const cached = this.INSTANCES.get(typeChecker);\n    if (cached != null) {\n      return cached;\n    }\n    const helper = new Helper();\n    this.INSTANCES.set(typeChecker, helper);\n    return helper;\n  }\n\n  private static readonly INSTANCES = new WeakMap<ts.TypeChecker, Helper>();\n\n  private readonly packageInfo = new Map<string, PackageInfo | undefined>();\n\n  private constructor() {}\n\n  public assemblyRelativeSourceFile(sourceFileName: string, asm?: Assembly) {\n    const packageInfo = this.findPackageInfo(path.dirname(sourceFileName));\n    if (!packageInfo) {\n      return undefined;\n    }\n\n    let sourcePath = removePrefix(packageInfo.outdir ?? '', path.relative(packageInfo.packageJsonDir, sourceFileName));\n\n    // Modify the namespace if we send in the assembly.\n    if (asm) {\n      const tscRootDir = packageInfo.tscRootDir ?? asm.metadata?.tscRootDir;\n      const tscOutDir = packageInfo.tscOutDir;\n      sourcePath = normalizePath(sourcePath, tscRootDir, tscOutDir);\n    }\n\n    return sourcePath.replace(/(\\.d)?\\.ts$/, '');\n\n    function removePrefix(prefix: string, filePath: string) {\n      const prefixParts = prefix.split(/[/\\\\]/g);\n      const pathParts = filePath.split(/[/\\\\]/g);\n      let i = 0;\n      while (prefixParts[i] === pathParts[i]) {\n        i++;\n      }\n      return pathParts.slice(i).join('/');\n    }\n  }\n\n  private findPackageInfo(from: string): PackageInfo | undefined {\n    if (this.packageInfo.has(from)) {\n      return this.packageInfo.get(from);\n    }\n\n    const packageJsonDir = findUp(from, (dir) => fs.existsSync(path.join(dir, 'package.json')));\n\n    if (!packageJsonDir) {\n      this.packageInfo.set(from, undefined);\n      return undefined;\n    }\n\n    if (this.packageInfo.has(packageJsonDir)) {\n      return this.packageInfo.get(packageJsonDir);\n    }\n\n    const { jsii } = JSON.parse(fs.readFileSync(path.join(packageJsonDir, 'package.json'), 'utf-8'));\n\n    const result = {\n      packageJsonDir,\n      outdir: jsii?.outdir,\n      tscRootDir: jsii?.tsc?.rootDir,\n      tscOutDir: jsii?.tsc?.outDir,\n    };\n    this.packageInfo.set(from, result);\n    this.packageInfo.set(packageJsonDir, result);\n    return result;\n  }\n}\n\ninterface PackageInfo {\n  readonly packageJsonDir: string;\n  readonly outdir: string | undefined;\n  readonly tscRootDir: string | undefined;\n  readonly tscOutDir: string | undefined;\n}\n\n/**\n * Ensures that the sourcePath is pointing to the source code\n * and not compiled code. This can happen if the root directory\n * and/or out directory is set for the project. We check to see\n * if the out directory is present in the sourcePath, and if so,\n * we replace it with the root directory.\n */\nexport function normalizePath(sourcePath: string, rootDir?: string, outDir?: string): string {\n  if (rootDir === undefined || outDir === undefined) {\n    return sourcePath;\n  }\n\n  outDir = removeEndSlash(path.normalize(outDir));\n  const outDirLength = outDir.split(path.sep).length;\n  rootDir = removeEndSlash(path.normalize(rootDir));\n\n  let paths = path.normalize(sourcePath).split(path.sep);\n  const pathDir = paths.slice(0, outDirLength).join(path.sep);\n\n  if (outDir === pathDir || outDir === '.') {\n    // outDir === '.' is a special case where we do not want\n    // to remove any paths from the list.\n    if (outDir !== '.') {\n      paths = paths.slice(outDirLength);\n    }\n    sourcePath = rootDir === '.' ? paths.join('/') : `${rootDir}/${paths.join('/')}`;\n  }\n  return unixize(sourcePath);\n\n  function removeEndSlash(filePath: string) {\n    return filePath.endsWith(path.sep) ? filePath.slice(0, filePath.length - 1) : filePath;\n  }\n}\n\n/**\n * Turn backslashes in a path into forward slashes\n */\nfunction unixize(p: string) {\n  return p.replace(/\\\\/g, '/');\n}\n"]}