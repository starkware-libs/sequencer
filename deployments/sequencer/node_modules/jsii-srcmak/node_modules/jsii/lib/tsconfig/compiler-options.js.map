{"version":3,"file":"compiler-options.js","sourceRoot":"","sources":["../../src/tsconfig/compiler-options.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport * as Case from '../case';\n\nexport const BASE_COMPILER_OPTIONS: ts.CompilerOptions = {\n  alwaysStrict: true,\n  declaration: true,\n  experimentalDecorators: true,\n  incremental: true,\n  lib: ['lib.es2020.d.ts'],\n  module: ts.ModuleKind.CommonJS,\n  noEmitOnError: true,\n  noFallthroughCasesInSwitch: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noUnusedLocals: true,\n  noUnusedParameters: true,\n  resolveJsonModule: true,\n  skipLibCheck: true,\n  strict: true,\n  strictNullChecks: true,\n  strictPropertyInitialization: true,\n  stripInternal: false,\n  target: ts.ScriptTarget.ES2020,\n};\n\n/**\n * Helper function to convert a TS enum into a list of allowed values,\n * converting everything to camel case.\n * This is used for example for the watch options\n */\nexport function enumAsCamel(enumData: Record<string, string | number>): string[] {\n  return Object.keys(enumData)\n    .filter((v) => isNaN(Number(v)))\n    .map(Case.camel);\n}\n\n/**\n * Helper function to convert a TS enum into a list of allowed values,\n * converting everything to lower case.\n * This is used for example for the \"target\" compiler option\n */\nexport function enumAsLower(enumData: Record<string, string | number>): string[] {\n  return Object.keys(enumData)\n    .filter((v) => isNaN(Number(v)) && v !== 'None')\n    .map((v) => v.toLowerCase());\n}\n\n/**\n * Helper function to convert a TS enum into a list of allowed values,\n * converting everything to kebab case.\n * This is used for example for the \"jsx\" compiler option\n */\nexport function enumAsKebab(enumData: Record<string, string | number>): string[] {\n  return Object.keys(enumData)\n    .filter((v) => isNaN(Number(v)) && v !== 'None')\n    .map(Case.kebab);\n}\n\n/**\n * The compilerOptions in the programmatic API are slightly differently than the format used in tsconfig.json\n * This helper performs the necessary conversion from the programmatic API format the one used in tsconfig.json\n *\n * @param opt compilerOptions in programmatic API format\n * @returns compilerOptions ready to be written on disk\n */\nexport function convertForJson(opt: ts.CompilerOptions): ts.CompilerOptions {\n  return {\n    ...opt,\n\n    // Drop the \"lib.\" prefix and \".d.ts\" suffix before writing up the tsconfig.json file\n    ...valueHelper('lib', opt.lib, convertLibForJson),\n\n    // Re-write the module, targets & jsx to be the JSON format instead of Programmatic API\n    ...enumHelper('importsNotUsedAsValues', opt.importsNotUsedAsValues, ts.ImportsNotUsedAsValues),\n    ...enumHelper('jsx', opt.jsx, ts.JsxEmit, Case.kebab),\n    ...enumHelper('module', opt.module, ts.ModuleKind),\n    ...enumHelper('moduleResolution', opt.moduleResolution, ts.ModuleResolutionKind),\n    ...enumHelper('moduleDetection', opt.moduleDetection, ts.ModuleDetectionKind),\n    ...enumHelper('target', opt.target, ts.ScriptTarget),\n\n    // rewrite newline to be the JSON format instead of Programmatic API\n    ...valueHelper('newLine', opt.newLine, convertNewLineForJson),\n  };\n}\n\nfunction valueHelper<T, U>(\n  name: string,\n  value: T | undefined,\n  converter: (value: T) => U,\n): {\n  [name: string]: U;\n} {\n  if (!value) {\n    return {};\n  }\n  return { [name]: converter(value) };\n}\n\nfunction enumHelper<T>(\n  name: string,\n  value: any,\n  enumObj: T,\n  converter?: (value: string) => string,\n): {\n  [name: string]: string;\n} {\n  if (!value) {\n    return {};\n  }\n  return { [name]: convertEnumToJson(value, enumObj, converter) };\n}\n\n/**\n * Convert an internal enum value to what a user would write in tsconfig.json\n * Possibly using a converter function to adjust casing.\n * @param value The internal enum value\n * @param enumObj The enum object to convert from\n * @param converter The converter function, defaults to lowercase\n * @returns The humanized version of the enum value\n */\nexport function convertEnumToJson<T>(\n  value: keyof T,\n  enumObj: T,\n  converter: (value: string) => string = (v) => v.toLowerCase(),\n): string {\n  return converter(enumObj[value] as any);\n}\n\n/**\n * Convert the internal lib strings to what a user would write in tsconfig.json\n * @param input The input libs array\n * @returns The humanized version lib array\n */\nexport function convertLibForJson(input: string[]): string[] {\n  return input.map((lib) => lib.slice(4, lib.length - 5));\n}\n\n/**\n * This is annoying - the values expected in the tsconfig.json file are not\n * the same as the enum constant names, or their values. So we need this\n * function to map the \"compiler API version\" to the \"tsconfig.json version\"\n *\n * @param newLine the compiler form of the new line configuration\n *\n * @return the equivalent value to put in tsconfig.json\n */\nexport function convertNewLineForJson(newLine: ts.NewLineKind): string {\n  switch (newLine) {\n    case ts.NewLineKind.CarriageReturnLineFeed:\n      return 'crlf';\n    case ts.NewLineKind.LineFeed:\n      return 'lf';\n  }\n}\n"]}