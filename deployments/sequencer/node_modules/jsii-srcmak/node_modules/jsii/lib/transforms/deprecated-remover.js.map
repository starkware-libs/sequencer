{"version":3,"file":"deprecated-remover.js","sourceRoot":"","sources":["../../src/transforms/deprecated-remover.ts"],"names":[],"mappings":"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","sourcesContent":["import { basename, dirname, relative } from 'node:path';\nimport {\n  Assembly,\n  ClassType,\n  EnumMember,\n  Initializer,\n  InterfaceType,\n  isClassOrInterfaceType,\n  isClassType,\n  isCollectionTypeReference,\n  isEnumType,\n  isMethod,\n  isNamedTypeReference,\n  isPrimitiveTypeReference,\n  Method,\n  Parameter,\n  Property,\n  Stability,\n  TypeReference,\n} from '@jsii/spec';\nimport * as ts from 'typescript';\n\nimport { JsiiDiagnostic } from '../jsii-diagnostic';\nimport * as bindings from '../node-bindings';\nimport { JsiiError } from '../utils';\n\nexport class DeprecatedRemover {\n  private readonly transformations = new Array<Transformation>();\n  private readonly nodesToRemove = new Set<ts.Node>();\n\n  public constructor(\n    private readonly typeChecker: ts.TypeChecker,\n    private readonly allowlistedDeprecations: Set<string> | undefined,\n  ) {}\n\n  /**\n   * Obtains the configuration for the TypeScript transform(s) that will remove\n   * `@deprecated` members from the generated declarations (`.d.ts`) files. It\n   * will leverage information accumulated during `#removeFrom(Assembly)` in\n   * order to apply corrections to inheritance chains, ensuring a valid output\n   * is produced.\n   */\n  public get customTransformers(): ts.CustomTransformers {\n    return {\n      afterDeclarations: [\n        (context) => {\n          const transformer = new DeprecationRemovalTransformer(\n            this.typeChecker,\n            context,\n            this.transformations,\n            this.nodesToRemove,\n          );\n          return transformer.transform.bind(transformer);\n        },\n      ],\n    };\n  }\n\n  /**\n   * Removes all `@deprecated` API elements from the provided assembly, and\n   * records the operations needed in order to fix the inheritance chains that\n   * mix `@deprecated` and non-`@deprecated` types.\n   *\n   * @param assembly the assembly to be modified.\n   *\n   * @returns diagnostic messages produced when validating no remaining API\n   *          makes use of a `@deprecated` type that was removed.\n   */\n  public removeFrom(assembly: Assembly): readonly JsiiDiagnostic[] {\n    if (assembly.types == null) {\n      return [];\n    }\n\n    const strippedFqns = new Set<string>();\n    const replaceWithClass = new Map<string, string>();\n    const replaceWithInterfaces = new Map<string, readonly string[]>();\n\n    // Find all types that will be stripped out\n    for (const [fqn, typeInfo] of Object.entries(assembly.types)) {\n      if (typeInfo.docs?.stability === Stability.Deprecated) {\n        if (!this.shouldFqnBeStripped(fqn)) {\n          continue;\n        }\n        strippedFqns.add(fqn);\n\n        if (isClassType(typeInfo) && typeInfo.base != null) {\n          replaceWithClass.set(fqn, typeInfo.base);\n        }\n        if (isClassOrInterfaceType(typeInfo) && typeInfo.interfaces != null) {\n          replaceWithInterfaces.set(fqn, typeInfo.interfaces);\n        }\n\n        this.nodesToRemove.add(bindings.getRelatedNode(typeInfo)!);\n      }\n    }\n\n    for (const [fqn, typeInfo] of Object.entries(assembly.types)) {\n      // Ignore `@deprecated` types\n      if (strippedFqns.has(fqn)) {\n        continue;\n      }\n\n      // Enums cannot have references to `@deprecated` types, but can have deprecated members\n      if (isEnumType(typeInfo)) {\n        const enumNode = bindings.getEnumRelatedNode(typeInfo)!;\n        const members: EnumMember[] = [];\n        for (const mem of typeInfo.members) {\n          if (mem.docs?.stability === Stability.Deprecated && this.shouldFqnBeStripped(`${fqn}#${mem.name}`)) {\n            const matchingMemberNode = enumNode.members.find((enumMem) => enumMem.name.getText() === mem.name);\n            if (matchingMemberNode) {\n              this.nodesToRemove.add(matchingMemberNode);\n            }\n          } else {\n            members.push(mem);\n          }\n        }\n        typeInfo.members = members;\n        continue;\n      }\n\n      // For classes, we erase `@deprecated` base classes, replacing as needed\n      const additionalInterfaces = new Set<string>();\n      if (isClassType(typeInfo) && typeInfo.base != null && strippedFqns.has(typeInfo.base)) {\n        while (typeInfo.base != null && strippedFqns.has(typeInfo.base)) {\n          const oldBase = assembly.types[typeInfo.base] as ClassType;\n          if (oldBase.interfaces) for (const addFqn of oldBase.interfaces) additionalInterfaces.add(addFqn);\n          typeInfo.base = replaceWithClass.get(typeInfo.base);\n        }\n        this.transformations.push(\n          typeInfo.base != null\n            ? Transformation.replaceBaseClass(\n                this.typeChecker,\n                bindings.getClassRelatedNode(typeInfo)!,\n                typeInfo.base in assembly.types\n                  ? bindings.getClassRelatedNode(assembly.types[typeInfo.base] as ClassType) ?? typeInfo.base\n                  : typeInfo.base,\n              )\n            : Transformation.removeBaseClass(this.typeChecker, bindings.getClassRelatedNode(typeInfo)!),\n        );\n      }\n\n      // Be defensive in case we add other kinds in the future\n      if (!isClassOrInterfaceType(typeInfo)) {\n        throw new Error(`Unhandled type encountered! ${JSON.stringify(typeInfo, null, 2)}`);\n      }\n\n      // Strip all `@deprecated` interfaces from the inheritance tree, replacing as needed\n      if (typeInfo.interfaces?.some((addFqn) => strippedFqns.has(addFqn)) || additionalInterfaces.size > 0) {\n        const originalSet = new Set(typeInfo.interfaces ?? []);\n        const newSet = new Set<string>();\n\n        const candidates = Array.from(new Set([...originalSet, ...additionalInterfaces]));\n        while (candidates.length > 0) {\n          const candidateFqn = candidates.pop()!;\n          if (!strippedFqns.has(candidateFqn)) {\n            newSet.add(candidateFqn);\n            if (!originalSet.has(candidateFqn)) {\n              this.transformations.push(\n                Transformation.addInterface(\n                  this.typeChecker,\n                  bindings.getClassOrInterfaceRelatedNode(typeInfo)!,\n                  candidateFqn in assembly.types\n                    ? bindings.getInterfaceRelatedNode(assembly.types[candidateFqn] as InterfaceType) ?? candidateFqn\n                    : candidateFqn,\n                ),\n              );\n            }\n            continue;\n          }\n          if (originalSet.has(candidateFqn)) {\n            this.transformations.push(\n              Transformation.removeInterface(\n                this.typeChecker,\n                bindings.getClassOrInterfaceRelatedNode(typeInfo)!,\n                bindings.getInterfaceRelatedNode(assembly.types[candidateFqn] as InterfaceType)!,\n              ),\n            );\n          }\n          const replacement = replaceWithInterfaces.get(candidateFqn);\n          if (replacement != null) {\n            candidates.push(...replacement);\n          }\n        }\n\n        typeInfo.interfaces = newSet.size > 0 ? Array.from(newSet).sort() : undefined;\n      }\n\n      // Drop all `@deprecated` members, and remove \"overrides\" from stripped types\n      const methods: Method[] = [];\n      const properties: Property[] = [];\n      if (typeInfo.methods) {\n        for (const meth of typeInfo.methods) {\n          if (meth.docs?.stability === Stability.Deprecated && this.shouldFqnBeStripped(`${fqn}#${meth.name}`)) {\n            this.nodesToRemove.add(bindings.getMethodRelatedNode(meth)!);\n          } else {\n            methods.push(\n              meth.overrides != null && strippedFqns.has(meth.overrides) ? { ...meth, overrides: undefined } : meth,\n            );\n          }\n        }\n      }\n      typeInfo.methods = typeInfo.methods ? methods : undefined;\n      if (typeInfo.properties) {\n        for (const prop of typeInfo.properties) {\n          if (prop.docs?.stability === Stability.Deprecated && this.shouldFqnBeStripped(`${fqn}#${prop.name}`)) {\n            this.nodesToRemove.add(bindings.getParameterRelatedNode(prop)!);\n          } else {\n            properties.push(\n              prop.overrides != null && strippedFqns.has(prop.overrides) ? { ...prop, overrides: undefined } : prop,\n            );\n          }\n        }\n      }\n      typeInfo.properties = typeInfo.properties ? properties : undefined;\n    }\n\n    const diagnostics = this.findLeftoverUseOfDeprecatedAPIs(assembly, strippedFqns);\n\n    // Remove all `@deprecated` types, after we did everything, so we could\n    // still access the related nodes from the assembly object.\n    for (const fqn of strippedFqns) {\n      if (this.shouldFqnBeStripped(fqn)) {\n        delete assembly.types[fqn];\n      }\n    }\n\n    return diagnostics;\n  }\n\n  private findLeftoverUseOfDeprecatedAPIs(assembly: Assembly, strippedFqns: Set<string>): readonly JsiiDiagnostic[] {\n    if (assembly.types == null) {\n      return [];\n    }\n\n    const result = new Array<JsiiDiagnostic>();\n\n    for (const type of Object.values(assembly.types)) {\n      if (isEnumType(type) || strippedFqns.has(type.fqn)) {\n        continue;\n      }\n      if (isClassType(type) && type.initializer) {\n        result.push(...this.verifyCallable(assembly, strippedFqns, type.initializer));\n      }\n      if (type.methods) {\n        for (const method of type.methods) result.push(...this.verifyCallable(assembly, strippedFqns, method));\n      }\n      if (type.properties) {\n        for (const property of type.properties) result.push(...this.verifyProperty(assembly, strippedFqns, property));\n      }\n    }\n\n    return result;\n  }\n\n  private verifyCallable(\n    assembly: Assembly,\n    strippedFqns: ReadonlySet<string>,\n    method: Method | Initializer,\n  ): readonly JsiiDiagnostic[] {\n    const diagnostics = new Array<JsiiDiagnostic>();\n    const deprecatedReturnFqn =\n      isMethod(method) && method.returns && this.tryFindReference(method.returns.type, strippedFqns);\n    if (deprecatedReturnFqn) {\n      diagnostics.push(this.makeDiagnostic(deprecatedReturnFqn, 'Method', method, assembly));\n    }\n\n    if (method.parameters) {\n      for (const parameter of method.parameters) {\n        const deprecatedTypeFqn = this.tryFindReference(parameter.type, strippedFqns);\n        if (deprecatedTypeFqn) {\n          diagnostics.push(this.makeDiagnostic(deprecatedTypeFqn, 'Parameter', parameter, assembly));\n        }\n      }\n    }\n    return diagnostics;\n  }\n\n  private verifyProperty(\n    assembly: Assembly,\n    strippedFqns: ReadonlySet<string>,\n    property: Property,\n  ): readonly JsiiDiagnostic[] {\n    const deprecatedTypeFqn = this.tryFindReference(property.type, strippedFqns);\n    if (deprecatedTypeFqn) {\n      return [this.makeDiagnostic(deprecatedTypeFqn, 'Property', property, assembly)];\n    }\n    return [];\n  }\n\n  /**\n   * Determines whether a `TypeReference` contains an FQN within a given set.\n   *\n   * @param ref  the tested `TypeReference`.\n   * @param fqns the set of FQNs that are being searched for.\n   *\n   * @returns the first FQN that was identified.\n   */\n  private tryFindReference(ref: TypeReference, fqns: ReadonlySet<string>): string | undefined {\n    if (isNamedTypeReference(ref)) {\n      return fqns.has(ref.fqn) ? ref.fqn : undefined;\n    }\n    if (isPrimitiveTypeReference(ref)) {\n      return undefined;\n    }\n    if (isCollectionTypeReference(ref)) {\n      return this.tryFindReference(ref.collection.elementtype, fqns);\n    }\n    return ref.union.types.map((type) => this.tryFindReference(type, fqns)).find((typeRef) => typeRef != null);\n  }\n\n  private shouldFqnBeStripped(fqn: string) {\n    return this.allowlistedDeprecations?.has(fqn) ?? true;\n  }\n\n  private makeDiagnostic(\n    fqn: string,\n    messagePrefix: 'Method',\n    context: Method | Initializer,\n    assembly: Assembly,\n  ): JsiiDiagnostic;\n  private makeDiagnostic(\n    fqn: string,\n    messagePrefix: 'Parameter',\n    context: Parameter,\n    assembly: Assembly,\n  ): JsiiDiagnostic;\n  private makeDiagnostic(fqn: string, messagePrefix: 'Property', context: Property, assembly: Assembly): JsiiDiagnostic;\n  private makeDiagnostic(\n    fqn: string,\n    messagePrefix: 'Method' | 'Property' | 'Parameter',\n    context: Method | Initializer | Parameter | Property,\n    assembly: Assembly,\n  ): JsiiDiagnostic {\n    const node = bindings.getRelatedNode<\n      | ts.AccessorDeclaration\n      | ts.MethodDeclaration\n      | ts.MethodSignature\n      | ts.ParameterDeclaration\n      | ts.PropertyDeclaration\n      | ts.PropertySignature\n    >(context);\n    const diagnostic = JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create(\n      node?.type ?? node!,\n      `${messagePrefix} has @deprecated type ${fqn}, and it is erased by --strip-deprecated.`,\n    );\n\n    const typeInfo = assembly.types?.[fqn];\n    const typeNode = typeInfo && bindings.getTypeRelatedNode(typeInfo);\n    if (typeNode == null) {\n      return diagnostic;\n    }\n    return diagnostic.addRelatedInformation(\n      ts.getNameOfDeclaration(typeNode) ?? typeNode,\n      'The @deprecated type is declared here',\n    );\n  }\n}\n\nclass Transformation {\n  public static addInterface(\n    typeChecker: ts.TypeChecker,\n    node: ts.ClassDeclaration | ts.InterfaceDeclaration,\n    iface: ts.InterfaceDeclaration | string,\n  ) {\n    return new Transformation(typeChecker, node, (declaration) => {\n      if (!ts.isClassDeclaration(declaration) && !ts.isInterfaceDeclaration(declaration)) {\n        throw new JsiiError(\n          `Expected a ClassDeclaration or InterfaceDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`,\n        );\n      }\n\n      const { typeExpression: newInterface, syntheticImport } = Transformation.typeReference(\n        iface,\n        declaration,\n        typeChecker,\n      );\n      if (ts.isClassDeclaration(declaration)) {\n        return {\n          node: ts.factory.updateClassDeclaration(\n            declaration,\n            declaration.modifiers,\n            declaration.name,\n            declaration.typeParameters,\n            addInterfaceTo(ts.SyntaxKind.ImplementsKeyword, declaration.heritageClauses),\n            declaration.members,\n          ),\n          syntheticImport,\n        };\n      }\n      return {\n        node: ts.factory.updateInterfaceDeclaration(\n          declaration,\n          declaration.modifiers,\n          declaration.name,\n          declaration.typeParameters,\n          addInterfaceTo(ts.SyntaxKind.ExtendsKeyword, declaration.heritageClauses),\n          declaration.members,\n        ),\n        syntheticImport,\n      };\n\n      function addInterfaceTo(\n        token: ts.HeritageClause['token'],\n        clauses: readonly ts.HeritageClause[] = [],\n      ): ts.HeritageClause[] {\n        const existingClause = clauses.find((clause) => clause.token === token);\n        if (existingClause == null) {\n          return [...clauses, ts.factory.createHeritageClause(token, [newInterface])];\n        }\n        return [\n          ...clauses.filter((clause) => clause !== existingClause),\n          ts.factory.updateHeritageClause(existingClause, [...existingClause.types, newInterface]),\n        ];\n      }\n    });\n  }\n\n  public static replaceBaseClass(\n    typeChecker: ts.TypeChecker,\n    node: ts.ClassDeclaration,\n    baseClass: ts.ClassDeclaration | string,\n  ) {\n    return new Transformation(typeChecker, node, (declaration) => {\n      if (!ts.isClassDeclaration(declaration)) {\n        throw new JsiiError(`Expected a ClassDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);\n      }\n      const { typeExpression: newBaseClass, syntheticImport } = Transformation.typeReference(\n        baseClass,\n        declaration,\n        typeChecker,\n      );\n      const existingClause = declaration.heritageClauses?.find(\n        (clause) => clause.token === ts.SyntaxKind.ExtendsKeyword,\n      );\n      return {\n        node: ts.factory.updateClassDeclaration(\n          declaration,\n          declaration.modifiers,\n          declaration.name,\n          declaration.typeParameters,\n          [\n            ...(declaration.heritageClauses ?? []).filter((clause) => clause !== existingClause),\n            existingClause\n              ? ts.factory.updateHeritageClause(existingClause, [newBaseClass])\n              : ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [newBaseClass]),\n          ],\n          declaration.members,\n        ),\n        syntheticImports: syntheticImport && [syntheticImport],\n      };\n    });\n  }\n\n  public static removeBaseClass(typeChecker: ts.TypeChecker, node: ts.ClassDeclaration) {\n    return new Transformation(typeChecker, node, (declaration) => {\n      if (!ts.isClassDeclaration(declaration)) {\n        throw new JsiiError(`Expected a ClassDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);\n      }\n      return {\n        node: ts.factory.updateClassDeclaration(\n          declaration,\n          declaration.modifiers,\n          declaration.name,\n          declaration.typeParameters,\n          declaration.heritageClauses?.filter((clause) => clause.token !== ts.SyntaxKind.ExtendsKeyword),\n          declaration.members,\n        ),\n      };\n    });\n  }\n\n  public static removeInterface(\n    typeChecker: ts.TypeChecker,\n    node: ts.ClassDeclaration | ts.InterfaceDeclaration,\n    iface: ts.InterfaceDeclaration,\n  ) {\n    const ifaceName = Transformation.fullyQualifiedName(typeChecker, iface)!;\n\n    return new Transformation(typeChecker, node, (declaration) => {\n      if (ts.isClassDeclaration(declaration)) {\n        return {\n          node: ts.factory.updateClassDeclaration(\n            declaration,\n            declaration.modifiers,\n            declaration.name,\n            declaration.typeParameters,\n            removeInterfaceHeritage(declaration.heritageClauses),\n            declaration.members,\n          ),\n        };\n      } else if (ts.isInterfaceDeclaration(declaration)) {\n        return {\n          node: ts.factory.updateInterfaceDeclaration(\n            declaration,\n            declaration.modifiers,\n            declaration.name,\n            declaration.typeParameters,\n            removeInterfaceHeritage(declaration.heritageClauses),\n            declaration.members,\n          ),\n        };\n      }\n      throw new JsiiError(\n        `Expected a ClassDeclaration or InterfaceDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`,\n      );\n    });\n\n    function removeInterfaceHeritage(\n      clauses: readonly ts.HeritageClause[] | undefined,\n    ): ts.HeritageClause[] | undefined {\n      if (clauses == null) {\n        return clauses;\n      }\n      return clauses\n        .map((clause) => {\n          const types = clause.types.filter(\n            (type) => Transformation.fullyQualifiedName(typeChecker, type.expression) !== ifaceName,\n          );\n          if (types.length === clause.types.length) {\n            // Means the interface was only transitively present...\n            return clause;\n          }\n          if (types.length === 0) {\n            return undefined;\n          }\n          return ts.factory.updateHeritageClause(clause, types);\n        })\n        .filter((clause) => clause != null) as ts.HeritageClause[];\n    }\n  }\n\n  private static fullyQualifiedName(typeChecker: ts.TypeChecker, node: ts.Node): string | undefined {\n    const symbol = typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(node as ts.Declaration) ?? node);\n    // This symbol ☝️ does not contain enough information in some cases - when\n    // an imported type is part of a heritage clause - to produce the fqn.\n    // Round tripping this to its type and back to a symbol seems to fix this.\n    const type = symbol && typeChecker.getDeclaredTypeOfSymbol(symbol);\n    return type?.symbol && typeChecker.getFullyQualifiedName(type.symbol);\n  }\n\n  private static typeReference(\n    type: ts.ClassDeclaration | ts.InterfaceDeclaration | string,\n    context: ts.ClassDeclaration | ts.InterfaceDeclaration,\n    typeChecker: ts.TypeChecker,\n  ): {\n    typeExpression: ts.ExpressionWithTypeArguments;\n    syntheticImport?: ts.ImportDeclaration;\n  } {\n    context = ts.getOriginalNode(context) as any;\n\n    const [, contextSource] = /^\"([^\"]+)\"\\..*$/.exec(\n      typeChecker.getFullyQualifiedName(typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(context)!)!),\n    )!;\n\n    let expression: ts.Expression;\n    let syntheticImport: ts.ImportDeclaration | undefined;\n\n    if (typeof type === 'string') {\n      const [root, ...tail] = type.split('.');\n      const syntheticImportName = ts.factory.createUniqueName(root);\n      syntheticImport = ts.factory.createImportDeclaration(\n        undefined /* decorators */,\n        ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(syntheticImportName)),\n        ts.factory.createStringLiteral(root),\n      );\n      expression = tail.reduce(\n        (curr, elt) => ts.factory.createPropertyAccessExpression(curr, elt),\n        syntheticImportName as ts.Expression,\n      );\n    } else {\n      const [, typeSource, qualifiedName] = /^\"([^\"]+)\"\\.(.*)$/.exec(\n        typeChecker.getFullyQualifiedName(typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(type)!)!),\n      )!;\n\n      if (typeSource === contextSource) {\n        const [root, ...tail] = qualifiedName.split('.');\n        expression = tail.reduce(\n          (curr, elt) => ts.factory.createPropertyAccessExpression(curr, elt),\n          ts.factory.createIdentifier(root) as ts.Expression,\n        );\n      } else {\n        const syntheticImportName = ts.factory.createUniqueName(basename(typeSource));\n        syntheticImport = ts.factory.createImportDeclaration(\n          undefined /* modifiers */,\n          ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(syntheticImportName)),\n          ts.factory.createStringLiteral(`./${relative(dirname(contextSource), typeSource)}`),\n          undefined,\n        );\n        expression = qualifiedName\n          .split('.')\n          .reduce(\n            (curr, elt) => ts.factory.createPropertyAccessExpression(curr, elt),\n            syntheticImportName as ts.Expression,\n          );\n      }\n    }\n\n    return {\n      typeExpression: ts.factory.createExpressionWithTypeArguments(expression, undefined),\n      syntheticImport,\n    };\n  }\n\n  private readonly nodeName: string;\n\n  private constructor(\n    private readonly typeChecker: ts.TypeChecker,\n    node: ts.Declaration,\n    public readonly apply: (\n      this: Transformation,\n      node: ts.Node,\n    ) => { node: ts.Node; syntheticImport?: ts.ImportDeclaration },\n  ) {\n    this.nodeName = Transformation.fullyQualifiedName(typeChecker, node)!;\n  }\n\n  public targets(node: ts.Declaration) {\n    return this.nodeName === Transformation.fullyQualifiedName(this.typeChecker, node);\n  }\n}\n\nclass DeprecationRemovalTransformer {\n  /**\n   * A list of SyntaxKinds for which it is not necessary to evaluate children,\n   * since they are never of interest to this transform. This opens up a wee\n   * optimization, which is particularly useful when trying to troubleshoot the\n   * transform in a debugger (saves a TON of time stepping into useless nodes\n   * then).\n   */\n  private static readonly IGNORE_CHILDREN: ReadonlySet<ts.SyntaxKind> = new Set([\n    ts.SyntaxKind.Constructor,\n    ts.SyntaxKind.FunctionDeclaration,\n    ts.SyntaxKind.GetAccessor,\n    ts.SyntaxKind.MethodDeclaration,\n    ts.SyntaxKind.MethodSignature,\n    ts.SyntaxKind.PropertySignature,\n    ts.SyntaxKind.PropertyDeclaration,\n    ts.SyntaxKind.SetAccessor,\n    ts.SyntaxKind.VariableDeclaration,\n  ]);\n\n  private syntheticImports = new Array<ts.ImportDeclaration>();\n\n  public constructor(\n    private readonly typeChecker: ts.TypeChecker,\n    private readonly context: ts.TransformationContext,\n    private readonly transformations: readonly Transformation[],\n    private readonly nodesToRemove: Set<ts.Node>,\n  ) {}\n\n  public transform<T extends ts.Node>(node: T): T {\n    let result = this.visitEachChild(node);\n\n    // If there are any synthetic imports, add them to the source file\n    if (ts.isSourceFile(result) && this.syntheticImports.length > 0) {\n      result = this.context.factory.updateSourceFile(\n        result,\n        [...this.syntheticImports, ...result.statements],\n        result.isDeclarationFile,\n        result.referencedFiles,\n        result.typeReferenceDirectives,\n        result.hasNoDefaultLib,\n        result.libReferenceDirectives,\n      ) as any;\n      this.syntheticImports = new Array<ts.ImportDeclaration>();\n    }\n\n    return result;\n  }\n\n  private visitEachChild<T extends ts.Node>(node: T): T {\n    return ts.visitEachChild(node, this.visitor.bind(this), this.context);\n  }\n\n  private visitor<T extends ts.Node>(node: T): ts.VisitResult<T> {\n    if (this.isDeprecated(node)) {\n      // Removing deprecated members by substituting \"nothing\" to them\n      return [];\n    }\n\n    if (ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node)) {\n      for (const transformation of this.transformations) {\n        // 👇 as any because the assignment below confuses type checker\n        if (transformation.targets(node as any)) {\n          const { node: transformedNode, syntheticImport } = transformation.apply(node);\n          node = transformedNode as any;\n          if (syntheticImport) {\n            this.syntheticImports.push(syntheticImport);\n          }\n        }\n      }\n    }\n\n    // Remove named imports of `@deprecated` members from the source...\n    if (\n      ts.isImportDeclaration(node) &&\n      node.importClause &&\n      node.importClause.namedBindings &&\n      ts.isNamedImports(node.importClause.namedBindings)\n    ) {\n      const filteredElements = node.importClause.namedBindings.elements.filter((element) => {\n        // This symbol is local (it's declaration points back to the named import)\n        const symbol = this.typeChecker.getSymbolAtLocation(element.name);\n        const exportedSymbol =\n          // This \"resolves\" the imported type, so we can get to it's declaration(s)\n          symbol && this.typeChecker.getDeclaredTypeOfSymbol(symbol)?.symbol;\n        return !exportedSymbol?.declarations?.some((decl) => this.isDeprecated(decl));\n      });\n      if (filteredElements.length !== node.importClause.namedBindings.elements.length) {\n        return this.context.factory.updateImportDeclaration(\n          node,\n          node.modifiers,\n          node.importClause.name != null || filteredElements.length > 0\n            ? this.context.factory.updateImportClause(\n                node.importClause,\n                node.importClause.isTypeOnly,\n                node.importClause.name,\n                this.context.factory.updateNamedImports(node.importClause.namedBindings, filteredElements),\n              )\n            : undefined,\n          node.moduleSpecifier,\n          node.assertClause,\n        ) as any;\n      }\n\n      return node;\n    }\n\n    // Replace \"export ... from ...\" places that no longer export anything\n    // with an \"import from ...\", so side effects are preserved.\n    if (ts.isExportDeclaration(node) && node.moduleSpecifier) {\n      const symbol = this.typeChecker.getSymbolAtLocation(node.moduleSpecifier);\n      const moduleExports =\n        symbol &&\n        this.typeChecker\n          .getExportsOfModule(symbol)\n          ?.filter((sym) => !sym.declarations?.some((decl) => this.isDeprecated(decl)));\n      if ((node.exportClause == null || ts.isNamespaceExport(node.exportClause)) && moduleExports?.length === 0) {\n        return this.context.factory.createImportDeclaration(\n          undefined /* modifiers */,\n          undefined /* importClause */,\n          node.moduleSpecifier,\n        ) as any;\n      }\n\n      if (node.exportClause != null && moduleExports) {\n        const namedExports = node.exportClause as ts.NamedExports;\n        const exportedNames = new Set(moduleExports.map((sym) => sym.name));\n        const filteredElements = namedExports.elements?.filter((elt) => exportedNames.has(elt.name.text));\n        if (filteredElements?.length !== namedExports.elements?.length) {\n          return this.context.factory.updateExportDeclaration(\n            node,\n            node.modifiers,\n            node.isTypeOnly,\n            this.context.factory.updateNamedExports(namedExports, filteredElements),\n            node.moduleSpecifier,\n            node.assertClause,\n          ) as any;\n        }\n      }\n    }\n\n    return DeprecationRemovalTransformer.IGNORE_CHILDREN.has(node.kind) ? node : this.visitEachChild(node);\n  }\n\n  private isDeprecated(node: ts.Node): boolean {\n    const original = ts.getOriginalNode(node);\n    return (\n      this.nodesToRemove.has(original) && ts.getJSDocTags(original).some((tag) => tag.tagName.text === 'deprecated')\n    );\n  }\n}\n"]}