{"version":3,"file":"directives.js","sourceRoot":"","sources":["../src/directives.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { JsiiDiagnostic } from './jsii-diagnostic';\n\n/**\n * TSDoc-style directives that can be attached to a symbol.\n */\nexport class Directives {\n  /**\n   * Obtains the `Directives` for a given TypeScript AST node.\n   *\n   * @param node         the node for which directives are requested.\n   * @param onDiagnostic a callback invoked whenever a diagnostic message is\n   *                     emitted when parsing directives.\n   */\n  public static of(node: ts.Node, onDiagnostic: (diag: JsiiDiagnostic) => void): Directives {\n    const found = Directives.#CACHE.get(node);\n    if (found != null) {\n      return found;\n    }\n\n    const directives = new Directives(node, onDiagnostic);\n    Directives.#CACHE.set(node, directives);\n    return directives;\n  }\n\n  static readonly #CACHE = new WeakMap<ts.Node, Directives>();\n\n  /** Whether the node has the `@internal` JSDoc tag. */\n  public readonly tsInternal?: ts.JSDocTag;\n  /** Whether the node has the `@jsii ignore` directive set. */\n  public readonly ignore?: ts.JSDocComment | ts.JSDocTag;\n  /** Whether the node has the `@jsii struct` directive set. */\n  public readonly struct?: ts.JSDocComment | ts.JSDocTag;\n\n  private constructor(node: ts.Node, onDiagnostic: (diag: JsiiDiagnostic) => void) {\n    for (const tag of ts.getJSDocTags(node)) {\n      switch (tag.tagName.text) {\n        case 'internal':\n          this.tsInternal ??= tag;\n          break;\n        case 'jsii':\n          const comments = getComments(tag);\n          if (comments.length === 0) {\n            onDiagnostic(JsiiDiagnostic.JSII_2000_MISSING_DIRECTIVE_ARGUMENT.create(tag));\n            continue;\n          }\n          for (const { text, jsdocNode } of comments) {\n            switch (text) {\n              case 'ignore':\n                this.ignore ??= jsdocNode;\n                break;\n              default:\n                onDiagnostic(JsiiDiagnostic.JSII_2999_UNKNOWN_DIRECTIVE.create(jsdocNode, text));\n                break;\n            }\n          }\n          break;\n        default: // Ignore\n      }\n    }\n  }\n}\n\nfunction getComments(tag: ts.JSDocTag): Comment[] {\n  if (tag.comment == null) {\n    return [];\n  }\n\n  if (typeof tag.comment === 'string') {\n    const text = tag.comment.trim();\n    return text\n      ? text.split(/[\\n,]/).flatMap((line) => {\n          line = line.trim();\n          return line ? [{ text: line, jsdocNode: tag }] : [];\n        })\n      : [];\n  }\n\n  // Possible per the type signature in the compiler, however not sure in which conditions.\n  return tag.comment.flatMap((jsdocNode): Comment[] => {\n    let text: string;\n    switch (jsdocNode.kind) {\n      case ts.SyntaxKind.JSDocText:\n        text = jsdocNode.text;\n        break;\n      case ts.SyntaxKind.JSDocLink:\n      case ts.SyntaxKind.JSDocLinkCode:\n      case ts.SyntaxKind.JSDocLinkPlain:\n        text = jsdocNode.name\n          ? `${jsdocNode.name.getText(jsdocNode.name.getSourceFile())}: ${jsdocNode.text}`\n          : jsdocNode.text;\n        break;\n    }\n    text = text.trim();\n    return text ? [{ text, jsdocNode }] : [];\n  });\n}\n\ninterface Comment {\n  readonly text: string;\n  readonly jsdocNode: ts.JSDocComment | ts.JSDocTag;\n}\n"]}