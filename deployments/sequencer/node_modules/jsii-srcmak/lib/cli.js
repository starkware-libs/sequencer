"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs = __importStar(require("yargs"));
const srcmak_1 = require("./srcmak");
async function main() {
    const args = yargs
        .usage('$0 SRCDIR [OPTIONS]')
        .option('entrypoint', { desc: 'typescript entrypoint (relative to SRCDIR)', default: 'index.ts' })
        .option('dep', { desc: 'node module directories to include in compilation', type: 'array', string: true })
        .option('jsii-path', { desc: 'write .jsii output to this path', type: 'string' })
        .option('python-outdir', { desc: 'python output directory (requires --python-module-name)', type: 'string' })
        .option('python-module-name', { desc: 'python module name', type: 'string' })
        .option('java-outdir', { desc: 'java output directory (requires --java-package)', type: 'string' })
        .option('java-package', { desc: 'the java package (namespace) to use for all generated types', type: 'string' })
        .option('csharp-outdir', { desc: 'C# output directory (requires --csharp-namespace)', type: 'string' })
        .option('csharp-namespace', { desc: 'the C# namespace to use for all generated types', type: 'string' })
        .option('golang-outdir', { desc: 'golang output directory (requires --golang-module)', type: 'string' })
        .option('golang-module', { desc: 'the golang module to use for all generated types', type: 'string' })
        .option('golang-package', { desc: 'the golang package name to use for all generated types', type: 'string' })
        .showHelpOnFail(true)
        .help();
    const argv = args.parseSync();
    if (argv._.length !== 1) {
        args.showHelp();
        console.error();
        console.error('Invalid number of arguments. expecting a single positional argument.');
        process.exit(1);
    }
    const srcdir = argv._[0];
    await (0, srcmak_1.srcmak)(srcdir, {
        entrypoint: argv.entrypoint,
        ...parseDepOption(),
        ...parseJsiiOptions(),
        ...parsePythonOptions(),
        ...parseJavaOptions(),
        ...parseCSharpOptions(),
        ...parseGoLangOptions(),
    });
    function parseJsiiOptions() {
        const jsiiPath = argv['jsii-path'];
        if (!jsiiPath) {
            return undefined;
        }
        return {
            jsii: {
                path: jsiiPath,
            },
        };
    }
    function parsePythonOptions() {
        const outdir = argv['python-outdir'];
        const moduleName = argv['python-module-name'];
        if (!outdir && !moduleName) {
            return undefined;
        }
        if (!outdir) {
            throw new Error('--python-outdir is required if --python-module-name is specified');
        }
        if (!moduleName) {
            throw new Error('--python-module-name is required if --python-outdir is specified');
        }
        return {
            python: {
                outdir: outdir,
                moduleName: moduleName,
            },
        };
    }
    function parseJavaOptions() {
        const outdir = argv['java-outdir'];
        const packageName = argv['java-package'];
        if (!outdir && !packageName) {
            return undefined;
        }
        if (!outdir) {
            throw new Error('--java-outdir is required');
        }
        if (!packageName) {
            throw new Error('--java-package is required');
        }
        return {
            java: {
                outdir: outdir,
                package: packageName,
            },
        };
    }
    function parseCSharpOptions() {
        const outdir = argv['csharp-outdir'];
        const namespace = argv['csharp-namespace'];
        if (!outdir && !namespace) {
            return undefined;
        }
        if (!outdir) {
            throw new Error('--csharp-outdir is required');
        }
        if (!namespace) {
            throw new Error('--csharp-namespace is required');
        }
        return {
            csharp: {
                outdir: outdir,
                namespace: namespace,
            },
        };
    }
    function parseGoLangOptions() {
        const outdir = argv['golang-outdir'];
        const module = argv['golang-module'];
        const packageName = argv['golang-package'];
        if (!outdir && !module) {
            return undefined;
        }
        if (!outdir) {
            throw new Error('--golang-outdir is required');
        }
        if (!module) {
            throw new Error('--golang-module is required');
        }
        if (!packageName) {
            throw new Error('--golang-package is required');
        }
        return {
            golang: {
                outdir: outdir,
                moduleName: module,
                packageName: packageName,
            },
        };
    }
    function parseDepOption() {
        var _a;
        if (((_a = argv.dep) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            return undefined;
        }
        return {
            deps: argv.dep,
        };
    }
}
main().catch((e) => {
    console.error(e.stack);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NsaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQStCO0FBQy9CLHFDQUFrQztBQUVsQyxLQUFLLFVBQVUsSUFBSTtJQUNqQixNQUFNLElBQUksR0FBRyxLQUFLO1NBQ2YsS0FBSyxDQUFDLHFCQUFxQixDQUFDO1NBQzVCLE1BQU0sQ0FBQyxZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsNENBQTRDLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDO1NBQ2pHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsbURBQW1ELEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDekcsTUFBTSxDQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksRUFBRSxpQ0FBaUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7U0FDaEYsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSx5REFBeUQsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7U0FDNUcsTUFBTSxDQUFDLG9CQUFvQixFQUFFLEVBQUUsSUFBSSxFQUFFLG9CQUFvQixFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUM1RSxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLGlEQUFpRCxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUNsRyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLDZEQUE2RCxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUMvRyxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLG1EQUFtRCxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUN0RyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxJ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QztRQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFBQyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7UUFBQyxDQUFDO1FBQ3RFLE9BQU87WUFDTCxNQUFNLEVBQUU7Z0JBQ04sTUFBTSxFQUFFLE1BQU07Z0JBQ2QsVUFBVSxFQUFFLE1BQU07Z0JBQ2xCLFdBQVcsRUFBRSxXQUFXO2FBQ3pCO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxTQUFTLGNBQWM7O1FBQ3JCLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxHQUFHLDBDQUFFLE1BQU0sTUFBSyxDQUFDLEVBQUUsQ0FBQztZQUFDLE9BQU8sU0FBUyxDQUFDO1FBQUMsQ0FBQztRQUNqRCxPQUFPO1lBQ0wsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHO1NBQ2YsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDO0FBRUQsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBUSxFQUFFLEVBQUU7SUFDeEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHlhcmdzIGZyb20gJ3lhcmdzJztcbmltcG9ydCB7IHNyY21hayB9IGZyb20gJy4vc3JjbWFrJztcblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgY29uc3QgYXJncyA9IHlhcmdzXG4gICAgLnVzYWdlKCckMCBTUkNESVIgW09QVElPTlNdJylcbiAgICAub3B0aW9uKCdlbnRyeXBvaW50JywgeyBkZXNjOiAndHlwZXNjcmlwdCBlbnRyeXBvaW50IChyZWxhdGl2ZSB0byBTUkNESVIpJywgZGVmYXVsdDogJ2luZGV4LnRzJyB9KVxuICAgIC5vcHRpb24oJ2RlcCcsIHsgZGVzYzogJ25vZGUgbW9kdWxlIGRpcmVjdG9yaWVzIHRvIGluY2x1ZGUgaW4gY29tcGlsYXRpb24nLCB0eXBlOiAnYXJyYXknLCBzdHJpbmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdqc2lpLXBhdGgnLCB7IGRlc2M6ICd3cml0ZSAuanNpaSBvdXRwdXQgdG8gdGhpcyBwYXRoJywgdHlwZTogJ3N0cmluZycgfSlcbiAgICAub3B0aW9uKCdweXRob24tb3V0ZGlyJywgeyBkZXNjOiAncHl0aG9uIG91dHB1dCBkaXJlY3RvcnkgKHJlcXVpcmVzIC0tcHl0aG9uLW1vZHVsZS1uYW1lKScsIHR5cGU6ICdzdHJpbmcnIH0pXG4gICAgLm9wdGlvbigncHl0aG9uLW1vZHVsZS1uYW1lJywgeyBkZXNjOiAncHl0aG9uIG1vZHVsZSBuYW1lJywgdHlwZTogJ3N0cmluZycgfSlcbiAgICAub3B0aW9uKCdqYXZhLW91dGRpcicsIHsgZGVzYzogJ2phdmEgb3V0cHV0IGRpcmVjdG9yeSAocmVxdWlyZXMgLS1qYXZhLXBhY2thZ2UpJywgdHlwZTogJ3N0cmluZycgfSlcbiAgICAub3B0aW9uKCdqYXZhLXBhY2thZ2UnLCB7IGRlc2M6ICd0aGUgamF2YSBwYWNrYWdlIChuYW1lc3BhY2UpIHRvIHVzZSBmb3IgYWxsIGdlbmVyYXRlZCB0eXBlcycsIHR5cGU6ICdzdHJpbmcnIH0pXG4gICAgLm9wdGlvbignY3NoYXJwLW91dGRpcicsIHsgZGVzYzogJ0MjIG91dHB1dCBkaXJlY3RvcnkgKHJlcXVpcmVzIC0tY3NoYXJwLW5hbWVzcGFjZSknLCB0eXBlOiAnc3RyaW5nJyB9KVxuICAgIC5vcHRpb24oJ2NzaGFycC1uYW1lc3BhY2UnLCB7IGRlc2M6ICd0aGUgQyMgbmFtZXNwYWNlIHRvIHVzZSBmb3IgYWxsIGdlbmVyYXRlZCB0eXBlcycsIHR5cGU6ICdzdHJpbmcnIH0pXG4gICAgLm9wdGlvbignZ29sYW5nLW91dGRpcicsIHsgZGVzYzogJ2dvbGFuZyBvdXRwdXQgZGlyZWN0b3J5IChyZXF1aXJlcyAtLWdvbGFuZy1tb2R1bGUpJywgdHlwZTogJ3N0cmluZycgfSlcbiAgICAub3B0aW9uKCdnb2xhbmctbW9kdWxlJywgeyBkZXNjOiAndGhlIGdvbGFuZyBtb2R1bGUgdG8gdXNlIGZvciBhbGwgZ2VuZXJhdGVkIHR5cGVzJywgdHlwZTogJ3N0cmluZycgfSlcbiAgICAub3B0aW9uKCdnb2xhbmctcGFja2FnZScsIHsgZGVzYzogJ3RoZSBnb2xhbmcgcGFja2FnZSBuYW1lIHRvIHVzZSBmb3IgYWxsIGdlbmVyYXRlZCB0eXBlcycsIHR5cGU6ICdzdHJpbmcnIH0pXG4gICAgLnNob3dIZWxwT25GYWlsKHRydWUpXG4gICAgLmhlbHAoKTtcblxuICBjb25zdCBhcmd2ID0gYXJncy5wYXJzZVN5bmMoKTtcblxuICBpZiAoYXJndi5fLmxlbmd0aCAhPT0gMSkge1xuICAgIGFyZ3Muc2hvd0hlbHAoKTtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLiBleHBlY3RpbmcgYSBzaW5nbGUgcG9zaXRpb25hbCBhcmd1bWVudC4nKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBjb25zdCBzcmNkaXIgPSBhcmd2Ll9bMF0gYXMgc3RyaW5nO1xuICBhd2FpdCBzcmNtYWsoc3JjZGlyLCB7XG4gICAgZW50cnlwb2ludDogYXJndi5lbnRyeXBvaW50LFxuICAgIC4uLnBhcnNlRGVwT3B0aW9uKCksXG4gICAgLi4ucGFyc2VKc2lpT3B0aW9ucygpLFxuICAgIC4uLnBhcnNlUHl0aG9uT3B0aW9ucygpLFxuICAgIC4uLnBhcnNlSmF2YU9wdGlvbnMoKSxcbiAgICAuLi5wYXJzZUNTaGFycE9wdGlvbnMoKSxcbiAgICAuLi5wYXJzZUdvTGFuZ09wdGlvbnMoKSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VKc2lpT3B0aW9ucygpIHtcbiAgICBjb25zdCBqc2lpUGF0aCA9IGFyZ3ZbJ2pzaWktcGF0aCddO1xuICAgIGlmICghanNpaVBhdGgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiB7XG4gICAgICBqc2lpOiB7XG4gICAgICAgIHBhdGg6IGpzaWlQYXRoLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQeXRob25PcHRpb25zKCkge1xuICAgIGNvbnN0IG91dGRpciA9IGFyZ3ZbJ3B5dGhvbi1vdXRkaXInXTtcbiAgICBjb25zdCBtb2R1bGVOYW1lID0gYXJndlsncHl0aG9uLW1vZHVsZS1uYW1lJ107XG4gICAgaWYgKCFvdXRkaXIgJiYgIW1vZHVsZU5hbWUpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIGlmICghb3V0ZGlyKSB7IHRocm93IG5ldyBFcnJvcignLS1weXRob24tb3V0ZGlyIGlzIHJlcXVpcmVkIGlmIC0tcHl0aG9uLW1vZHVsZS1uYW1lIGlzIHNwZWNpZmllZCcpOyB9XG4gICAgaWYgKCFtb2R1bGVOYW1lKSB7IHRocm93IG5ldyBFcnJvcignLS1weXRob24tbW9kdWxlLW5hbWUgaXMgcmVxdWlyZWQgaWYgLS1weXRob24tb3V0ZGlyIGlzIHNwZWNpZmllZCcpOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHB5dGhvbjoge1xuICAgICAgICBvdXRkaXI6IG91dGRpcixcbiAgICAgICAgbW9kdWxlTmFtZTogbW9kdWxlTmFtZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSmF2YU9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3V0ZGlyID0gYXJndlsnamF2YS1vdXRkaXInXTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IGFyZ3ZbJ2phdmEtcGFja2FnZSddO1xuICAgIGlmICghb3V0ZGlyICYmICFwYWNrYWdlTmFtZSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgaWYgKCFvdXRkaXIpIHsgdGhyb3cgbmV3IEVycm9yKCctLWphdmEtb3V0ZGlyIGlzIHJlcXVpcmVkJyk7IH1cbiAgICBpZiAoIXBhY2thZ2VOYW1lKSB7IHRocm93IG5ldyBFcnJvcignLS1qYXZhLXBhY2thZ2UgaXMgcmVxdWlyZWQnKTsgfVxuICAgIHJldHVybiB7XG4gICAgICBqYXZhOiB7XG4gICAgICAgIG91dGRpcjogb3V0ZGlyLFxuICAgICAgICBwYWNrYWdlOiBwYWNrYWdlTmFtZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ1NoYXJwT3B0aW9ucygpIHtcbiAgICBjb25zdCBvdXRkaXIgPSBhcmd2Wydjc2hhcnAtb3V0ZGlyJ107XG4gICAgY29uc3QgbmFtZXNwYWNlID0gYXJndlsnY3NoYXJwLW5hbWVzcGFjZSddO1xuICAgIGlmICghb3V0ZGlyICYmICFuYW1lc3BhY2UpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIGlmICghb3V0ZGlyKSB7IHRocm93IG5ldyBFcnJvcignLS1jc2hhcnAtb3V0ZGlyIGlzIHJlcXVpcmVkJyk7IH1cbiAgICBpZiAoIW5hbWVzcGFjZSkgeyB0aHJvdyBuZXcgRXJyb3IoJy0tY3NoYXJwLW5hbWVzcGFjZSBpcyByZXF1aXJlZCcpOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNzaGFycDoge1xuICAgICAgICBvdXRkaXI6IG91dGRpcixcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdvTGFuZ09wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3V0ZGlyID0gYXJndlsnZ29sYW5nLW91dGRpciddO1xuICAgIGNvbnN0IG1vZHVsZSA9IGFyZ3ZbJ2dvbGFuZy1tb2R1bGUnXTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IGFyZ3ZbJ2dvbGFuZy1wYWNrYWdlJ107XG4gICAgaWYgKCFvdXRkaXIgJiYgIW1vZHVsZSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgaWYgKCFvdXRkaXIpIHsgdGhyb3cgbmV3IEVycm9yKCctLWdvbGFuZy1vdXRkaXIgaXMgcmVxdWlyZWQnKTsgfVxuICAgIGlmICghbW9kdWxlKSB7IHRocm93IG5ldyBFcnJvcignLS1nb2xhbmctbW9kdWxlIGlzIHJlcXVpcmVkJyk7IH1cbiAgICBpZiAoIXBhY2thZ2VOYW1lKSB7IHRocm93IG5ldyBFcnJvcignLS1nb2xhbmctcGFja2FnZSBpcyByZXF1aXJlZCcpOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGdvbGFuZzoge1xuICAgICAgICBvdXRkaXI6IG91dGRpcixcbiAgICAgICAgbW9kdWxlTmFtZTogbW9kdWxlLFxuICAgICAgICBwYWNrYWdlTmFtZTogcGFja2FnZU5hbWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURlcE9wdGlvbigpIHtcbiAgICBpZiAoYXJndi5kZXA/Lmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHM6IGFyZ3YuZGVwLFxuICAgIH07XG4gIH1cbn1cblxubWFpbigpLmNhdGNoKChlOiBFcnJvcikgPT4ge1xuICBjb25zb2xlLmVycm9yKGUuc3RhY2spO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59KTtcblxuIl19