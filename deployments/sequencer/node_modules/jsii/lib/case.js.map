{"version":3,"file":"case.js","sourceRoot":"","sources":["../src/case.ts"],"names":[],"mappings":";;;AAAA,6BAA6B;AAE7B,MAAM,SAAS,GACb,CAAC,IAA8B,EAA8B,EAAE,CAC/D,CAAC,IAAY,EAAE,EAAE,CACf,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAEf,QAAA,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9B,QAAA,QAAQ,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpC,QAAA,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAChC,QAAA,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9B,QAAA,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAE3C,MAAM,KAAK;IACF,MAAM,CAAC,KAAK,CAAC,IAAY,EAAE,IAA8B;QAC9D,qDAAqD;QACrD,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACtC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YAClB,wBAAwB;YACxB,KAAK,GAAG,IAAI,GAAG,EAAkB,CAAC;YAClC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QACnC,CAAC;QAED,0DAA0D;QAC1D,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;YACnB,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,yBAAyB;QACzB,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACxB,OAAO,MAAM,CAAC;IAChB,CAAC;IAKD,gBAAuB,CAAC;;AAHxB,uFAAuF;AAC/D,YAAM,GAAG,IAAI,OAAO,EAAiC,CAAC;AAKhF,MAAM,QAAQ;IACL,MAAM,CAAC,GAAG,CAAC,IAAS;QACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC;QAC5C,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,MAAM,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC9B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;QAC1C,OAAO,MAAM,CAAC;IAChB,CAAC;IAKD,gBAAuB,CAAC;;AAHxB,iGAAiG;AACzE,cAAK,GAAG,IAAI,GAAG,EAA0B,CAAC","sourcesContent":["import * as Case from 'case';\n\nconst withCache =\n  (func: (text: string) => string): ((text: string) => string) =>\n  (text: string) =>\n    Cache.fetch(text, func);\n\nexport const camel = withCache(Case.camel);\nexport const constant = withCache(Case.constant);\nexport const pascal = withCache(Case.pascal);\nexport const snake = withCache(Case.snake);\nexport const kebab = withCache(Case.kebab);\n\nclass Cache {\n  public static fetch(text: string, func: (text: string) => string): string {\n    // Check whether we have a cache for this function...\n    const cacheKey = CacheKey.for(func);\n    let cache = this.CACHES.get(cacheKey);\n    if (cache == null) {\n      // If not, create one...\n      cache = new Map<string, string>();\n      this.CACHES.set(cacheKey, cache);\n    }\n\n    // Check if the current cache has a value for this text...\n    const cached = cache.get(text);\n    if (cached != null) {\n      return cached;\n    }\n\n    // If not, compute one...\n    const result = func(text);\n    cache.set(text, result);\n    return result;\n  }\n\n  // Cache is indexed on a weak CacheKey so the cache can be purged under memory pressure\n  private static readonly CACHES = new WeakMap<CacheKey, Map<string, string>>();\n\n  private constructor() {}\n}\n\nclass CacheKey {\n  public static for(data: any) {\n    const entry = this.STORE.get(data)?.deref();\n    if (entry != null) {\n      return entry;\n    }\n    const newKey = new CacheKey();\n    this.STORE.set(data, new WeakRef(newKey));\n    return newKey;\n  }\n\n  // Storing cache keys as weak references to allow garbage collection if there is memory pressure.\n  private static readonly STORE = new Map<any, WeakRef<CacheKey>>();\n\n  private constructor() {}\n}\n"]}