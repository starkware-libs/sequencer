{"version":3,"file":"validator.js","sourceRoot":"","sources":["../src/validator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'node:assert';\nimport * as spec from '@jsii/spec';\nimport * as deepEqual from 'fast-deep-equal';\nimport * as ts from 'typescript';\nimport * as Case from './case';\nimport { Emitter } from './emitter';\nimport { JsiiDiagnostic } from './jsii-diagnostic';\nimport { getRelatedNode } from './node-bindings';\nimport * as bindings from './node-bindings';\nimport { ProjectInfo } from './project-info';\n\nexport class Validator implements Emitter {\n  public static VALIDATIONS: ValidationFunction[] = _defaultValidations();\n\n  public constructor(public readonly projectInfo: ProjectInfo, public readonly assembly: spec.Assembly) {}\n\n  public emit(): ts.EmitResult {\n    const diagnostics = new Array<ts.Diagnostic>();\n\n    for (const validation of Validator.VALIDATIONS) {\n      validation(this, this.assembly, diagnostics.push.bind(diagnostics));\n    }\n\n    return {\n      diagnostics: diagnostics,\n      emitSkipped: diagnostics.some((diag) => diag.category === ts.DiagnosticCategory.Error),\n    };\n  }\n}\n\nexport type DiagnosticEmitter = (diag: JsiiDiagnostic) => void;\nexport type ValidationFunction = (validator: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) => void;\n\nfunction _defaultValidations(): ValidationFunction[] {\n  return [\n    _enumMembersMustUserUpperSnakeCase,\n    _memberNamesMustUseCamelCase,\n    _staticConstantNamesMustUseUpperSnakeCase,\n    _memberNamesMustNotLookLikeJavaGettersOrSetters,\n    _allTypeReferencesAreValid,\n    _inehritanceDoesNotChangeContracts,\n    _staticMembersAndNestedTypesMustNotSharePascalCaseName,\n    _abstractClassesMustImplementAllProperties,\n  ];\n\n  function _enumMembersMustUserUpperSnakeCase(_: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const type of _allTypes(assembly)) {\n      if (!spec.isEnumType(type)) {\n        continue;\n      }\n\n      for (const member of type.members) {\n        if (member.name && !isConstantCase(member.name)) {\n          diagnostic(JsiiDiagnostic.JSII_8001_ALL_CAPS_ENUM_MEMBERS.createDetached(member.name, type.fqn));\n        }\n      }\n    }\n  }\n\n  function _memberNamesMustUseCamelCase(_: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (member.static && (member as spec.Property).const) {\n        continue;\n      }\n      if (member.name && member.name !== Case.camel(member.name)) {\n        diagnostic(JsiiDiagnostic.JSII_8002_CAMEL_CASED_MEMBERS.createDetached(member.name, type.fqn));\n      }\n    }\n  }\n\n  function _staticConstantNamesMustUseUpperSnakeCase(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (!member.static || !(member as spec.Property).const) {\n        continue;\n      }\n      if (\n        member.name &&\n        !isConstantCase(member.name) &&\n        member.name !== Case.pascal(member.name) &&\n        member.name !== Case.camel(member.name)\n      ) {\n        diagnostic(JsiiDiagnostic.JSII_8003_STATIC_CONST_CASING.createDetached(member.name, type.name));\n      }\n    }\n  }\n\n  function _memberNamesMustNotLookLikeJavaGettersOrSetters(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (!member.name) {\n        continue;\n      }\n      const snakeName = Case.snake(member.name);\n      if (snakeName.startsWith('get_') && _isEmpty((member as spec.Method).parameters)) {\n        diagnostic(JsiiDiagnostic.JSII_5000_JAVA_GETTERS.createDetached(member.name, type.name));\n      } else if (snakeName.startsWith('set_') && ((member as spec.Method).parameters ?? []).length === 1) {\n        diagnostic(JsiiDiagnostic.JSII_5001_JAVA_SETTERS.createDetached(member.name, type.name));\n      }\n    }\n  }\n\n  function _allTypeReferencesAreValid(validator: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const typeRef of _allTypeReferences(assembly)) {\n      const [assm] = typeRef.fqn.split('.');\n      if (assembly.name === assm) {\n        if (!(typeRef.fqn in (assembly.types ?? {}))) {\n          diagnostic(\n            JsiiDiagnostic.JSII_3000_EXPORTED_API_USES_HIDDEN_TYPE.create(\n              typeRef.node!, // Pretend there is always a value\n              typeRef.fqn,\n            ),\n          );\n        }\n        continue;\n      }\n      const foreignAssm = validator.projectInfo.dependencyClosure.find((dep) => dep.name === assm);\n      if (!foreignAssm) {\n        diagnostic(JsiiDiagnostic.JSII_9000_UNKNOWN_MODULE.createDetached(assm));\n        continue;\n      }\n      if (!(typeRef.fqn in (foreignAssm.types ?? {}))) {\n        diagnostic(JsiiDiagnostic.JSII_9001_TYPE_NOT_FOUND.createDetached(typeRef));\n      }\n    }\n  }\n\n  function _inehritanceDoesNotChangeContracts(\n    validator: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const type of _allTypes(assembly)) {\n      if (spec.isClassType(type)) {\n        for (const method of type.methods ?? []) {\n          _validateMethodOverride(method, type);\n        }\n        for (const property of type.properties ?? []) {\n          _validatePropertyOverride(property, type);\n        }\n      }\n      if (spec.isClassOrInterfaceType(type) && (type.interfaces?.length ?? 0) > 0) {\n        for (const method of _allImplementations(type, (t) => t.methods)) {\n          _validateMethodImplementation(method, type);\n        }\n        for (const property of _allImplementations(type, (t) => t.properties)) {\n          _validatePropertyImplementation(property, type);\n        }\n      }\n    }\n\n    /**\n     * Lists all \"implementations\" from the given type, using the provided\n     * implementation getter. Note that abstract members may be part of the\n     * result (in particular, if `type` is an interface type, or if it's an\n     * abstract class with unimplemented members) -- I just couldn't come up\n     * with a name that actually describes this.\n     *\n     * @param type   the type which implemented members are needed.\n     * @param getter the getter to obtain methods or properties from the type.\n     *\n     * @returns a list of members (possibly empty, always defined)\n     */\n    function _allImplementations<T extends spec.Property | spec.Method>(\n      type: spec.ClassType | spec.InterfaceType,\n      getter: (type: spec.ClassType | spec.InterfaceType) => T[] | undefined,\n    ): T[] {\n      const result = new Array<T>();\n      const known = new Set<string>();\n\n      for (const member of getter(type) ?? []) {\n        result.push(member);\n        known.add(member.name);\n      }\n\n      if (spec.isClassType(type) && type.base) {\n        // We have a parent class, collect their concrete members, too (recursively)...\n        const base = _dereference(type.base, assembly, validator);\n        assert(base != null && spec.isClassType(base));\n        for (const member of _allImplementations(base, getter)) {\n          if (known.has(member.name)) {\n            continue;\n          }\n          // The member is copied, so that its `overrides` property won't be\n          // altered, since this member is \"borrowed\" from a parent type. We\n          // only check it, but should not record `overrides` relationships to\n          // it as those could be invalid per the parent type (i.e: the parent\n          // member may not be able to implement an interface, if that type does\n          // not actually declare implementing that).\n          const memberCopy = { ...member };\n          // Forward the related node if there's one, so diagnostics are bound.\n          const node = bindings.getRelatedNode(member);\n          if (node != null) {\n            bindings.setRelatedNode(memberCopy, node);\n          }\n\n          result.push(memberCopy);\n          known.add(member.name);\n        }\n      }\n\n      return result;\n    }\n\n    function _validateMethodOverride(method: spec.Method, type: spec.ClassType): boolean {\n      if (!type.base) {\n        return false;\n      }\n      const baseType = _dereference(type.base, assembly, validator) as spec.ClassType;\n      if (!baseType) {\n        return false;\n      }\n      const overridden = (baseType.methods ?? []).find((m) => m.name === method.name);\n      if (!overridden) {\n        return _validateMethodOverride(method, baseType);\n      }\n      _assertSignaturesMatch(overridden, method, `${type.fqn}#${method.name}`, `overriding ${baseType.fqn}`);\n      method.overrides = baseType.fqn;\n      return true;\n    }\n\n    function _validatePropertyOverride(property: spec.Property, type: spec.ClassType): boolean {\n      if (!type.base) {\n        return false;\n      }\n      const baseType = _dereference(type.base, assembly, validator) as spec.ClassType;\n      if (!baseType) {\n        return false;\n      }\n      const overridden = (baseType.properties ?? []).find((p) => p.name === property.name);\n      if (!overridden) {\n        return _validatePropertyOverride(property, baseType);\n      }\n      _assertPropertiesMatch(overridden, property, `${type.fqn}#${property.name}`, `overriding ${baseType.fqn}`);\n      property.overrides = baseType.fqn;\n      return true;\n    }\n\n    function _validateMethodImplementation(method: spec.Method, type: spec.ClassType | spec.InterfaceType): boolean {\n      if (!type.interfaces) {\n        // Abstract classes may not directly implement all members, need to check their supertypes...\n        if (spec.isClassType(type) && type.base && type.abstract) {\n          return _validateMethodImplementation(method, _dereference(type.base, assembly, validator) as spec.ClassType);\n        }\n        return false;\n      }\n      for (const iface of type.interfaces) {\n        const ifaceType = _dereference(iface, assembly, validator) as spec.InterfaceType;\n        const implemented = (ifaceType.methods ?? []).find((m) => m.name === method.name);\n        if (implemented) {\n          _assertSignaturesMatch(implemented, method, `${type.fqn}#${method.name}`, `implementing ${ifaceType.fqn}`);\n          // We won't replace a previous overrides declaration from a method override, as those have\n          // higher precedence than an initial implementation.\n          method.overrides = method.overrides ?? iface;\n          return true;\n        }\n        if (_validateMethodImplementation(method, ifaceType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function _validatePropertyImplementation(\n      property: spec.Property,\n      type: spec.ClassType | spec.InterfaceType,\n    ): boolean {\n      if (!type.interfaces) {\n        // Abstract classes may not directly implement all members, need to check their supertypes...\n        if (spec.isClassType(type) && type.base && type.abstract) {\n          return _validatePropertyImplementation(\n            property,\n            _dereference(type.base, assembly, validator) as spec.ClassType,\n          );\n        }\n        return false;\n      }\n      for (const iface of type.interfaces) {\n        const ifaceType = _dereference(iface, assembly, validator) as spec.InterfaceType;\n        const implemented = (ifaceType.properties ?? []).find((p) => p.name === property.name);\n        if (implemented) {\n          _assertPropertiesMatch(\n            implemented,\n            property,\n            `${type.fqn}#${property.name}`,\n            `implementing ${ifaceType.fqn}`,\n          );\n          // We won't replace a previous overrides declaration from a property override, as those\n          // have higher precedence than an initial implementation.\n          property.overrides = property.overrides ?? ifaceType.fqn;\n          return true;\n        }\n        if (_validatePropertyImplementation(property, ifaceType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function _assertSignaturesMatch(expected: spec.Method, actual: spec.Method, label: string, action: string) {\n      if (!!expected.protected !== !!actual.protected) {\n        const expVisibility = expected.protected ? 'protected' : 'public';\n        const actVisibility = actual.protected ? 'protected' : 'public';\n        diagnostic(\n          JsiiDiagnostic.JSII_5002_OVERRIDE_CHANGES_VISIBILITY.createDetached(\n            label,\n            action,\n            actVisibility,\n            expVisibility,\n          ),\n        );\n      }\n      if (!deepEqual(actual.returns, expected.returns)) {\n        const expType = spec.describeTypeReference(expected.returns?.type);\n        const actType = spec.describeTypeReference(actual.returns?.type);\n        diagnostic(\n          JsiiDiagnostic.JSII_5003_OVERRIDE_CHANGES_RETURN_TYPE.createDetached(label, action, actType, expType),\n        );\n      }\n      const expectedParams = expected.parameters ?? [];\n      const actualParams = actual.parameters ?? [];\n      if (expectedParams.length !== actualParams.length) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5005_OVERRIDE_CHANGES_PARAM_COUNT.createDetached(\n            label,\n            action,\n            actualParams.length,\n            expectedParams.length,\n          ),\n        );\n        return;\n      }\n      for (let i = 0; i < expectedParams.length; i++) {\n        const expParam = expectedParams[i];\n        const actParam = actualParams[i];\n        if (!deepEqual(expParam.type, actParam.type)) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5006_OVERRIDE_CHANGES_PARAM_TYPE.createDetached(label, action, actParam, expParam),\n          );\n        }\n        // Not-ing those to force the values to a strictly boolean context (they're optional, undefined means false)\n        if (expParam.variadic !== actParam.variadic) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5007_OVERRIDE_CHANGES_VARIADIC.createDetached(\n              label,\n              action,\n              actParam.variadic,\n              expParam.variadic,\n            ),\n          );\n        }\n        if (expParam.optional !== actParam.optional) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5008_OVERRIDE_CHANGES_PARAM_OPTIONAL.createDetached(label, action, actParam, expParam),\n          );\n        }\n      }\n    }\n\n    function _assertPropertiesMatch(expected: spec.Property, actual: spec.Property, label: string, action: string) {\n      const actualNode = bindings.getPropertyRelatedNode(actual);\n      const expectedNode = bindings.getPropertyRelatedNode(expected);\n      if (!!expected.protected !== !!actual.protected) {\n        const expVisibility = expected.protected ? 'protected' : 'public';\n        const actVisibility = actual.protected ? 'protected' : 'public';\n        diagnostic(\n          JsiiDiagnostic.JSII_5002_OVERRIDE_CHANGES_VISIBILITY.create(\n            actualNode?.modifiers?.find(\n              (mod) => mod.kind === ts.SyntaxKind.PublicKeyword || mod.kind === ts.SyntaxKind.ProtectedKeyword,\n            ) ?? declarationName(actualNode),\n            label,\n            action,\n            actVisibility,\n            expVisibility,\n          ).maybeAddRelatedInformation(\n            expectedNode?.modifiers?.find(\n              (mod) => mod.kind === ts.SyntaxKind.PublicKeyword || mod.kind === ts.SyntaxKind.ProtectedKeyword,\n            ) ?? declarationName(expectedNode),\n            'The implemented declaration is here.',\n          ),\n        );\n      }\n      if (!deepEqual(expected.type, actual.type)) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5004_OVERRIDE_CHANGES_PROP_TYPE.create(\n            actualNode?.type ?? declarationName(actualNode),\n            label,\n            action,\n            actual.type,\n            expected.type,\n          ).maybeAddRelatedInformation(\n            expectedNode?.type ?? declarationName(expectedNode),\n            'The implemented declaration is here.',\n          ),\n        );\n      }\n      if (expected.immutable !== actual.immutable) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5010_OVERRIDE_CHANGES_MUTABILITY.create(\n            actualNode?.modifiers?.find((mod) => mod.kind === ts.SyntaxKind.ReadonlyKeyword) ??\n              declarationName(actualNode),\n            label,\n            action,\n            actual.immutable,\n            expected.immutable,\n          ).maybeAddRelatedInformation(\n            expectedNode?.modifiers?.find((mod) => mod.kind === ts.SyntaxKind.ReadonlyKeyword) ??\n              declarationName(expectedNode),\n            'The implemented declaration is here.',\n          ),\n        );\n      }\n      if (expected.optional !== actual.optional) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5009_OVERRIDE_CHANGES_PROP_OPTIONAL.create(\n            actualNode?.questionToken ?? actualNode?.type ?? declarationName(actualNode),\n            label,\n            action,\n            actual.optional,\n            expected.optional,\n          ).maybeAddRelatedInformation(\n            expectedNode?.questionToken ?? expectedNode?.type ?? declarationName(expectedNode),\n            'The implemented declaration is here.',\n          ),\n        );\n      }\n    }\n  }\n\n  /**\n   * Abstract classes that implement an interface should have a declaration for every member.\n   *\n   * For non-optional members, TypeScript already enforces this. This leaves the user the\n   * ability to forget optional properties (`readonly prop?: string`).\n   *\n   * At least our codegen for this case fails in C#, and I'm not convinced it does the right\n   * thing in Java either. So we will disallow this, and require users to declare these\n   * fields on the class. It can always be `public abstract readonly prop?: string` if they\n   * don't want to give an implementation yet.\n   */\n  function _abstractClassesMustImplementAllProperties(\n    validator: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const type of _allTypes(assembly)) {\n      if (!spec.isClassType(type) || !type.abstract) {\n        continue;\n      }\n\n      const classProps = collectClassProps(type, new Set());\n\n      for (const implFqn of type.interfaces ?? []) {\n        checkInterfacePropsImplemented(implFqn, type, classProps);\n      }\n    }\n\n    /**\n     * Return all property names declared on this class and its base classes\n     */\n    function collectClassProps(type: spec.ClassType, into: Set<string>): Set<string> {\n      for (const prop of type.properties ?? []) {\n        into.add(prop.name);\n      }\n\n      if (type.base) {\n        const base = _dereference(type.base, assembly, validator);\n        if (spec.isClassType(base)) {\n          collectClassProps(base, into);\n        }\n      }\n\n      return into;\n    }\n\n    function checkInterfacePropsImplemented(interfaceFqn: string, cls: spec.ClassType, propNames: Set<string>) {\n      const intf = _dereference(interfaceFqn, assembly, validator);\n      if (!spec.isInterfaceType(intf)) {\n        return;\n      }\n\n      // We only have to check for optional properties, because anything required\n      // would have been caught by the TypeScript compiler already.\n      for (const prop of intf.properties ?? []) {\n        if (!prop.optional) {\n          continue;\n        }\n\n        if (!propNames.has(prop.name)) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5021_ABSTRACT_CLASS_MISSING_PROP_IMPL.create(\n              bindings.getClassOrInterfaceRelatedNode(cls),\n              intf,\n              cls,\n              prop.name,\n            ).maybeAddRelatedInformation(bindings.getPropertyRelatedNode(prop), 'The implemented declaration is here.'),\n          );\n        }\n      }\n\n      for (const extFqn of intf.interfaces ?? []) {\n        checkInterfacePropsImplemented(extFqn, cls, propNames);\n      }\n    }\n  }\n\n  function _staticMembersAndNestedTypesMustNotSharePascalCaseName(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const nestedType of Object.values(assembly.types ?? {})) {\n      if (nestedType.namespace == null) {\n        continue;\n      }\n      const nestingType = assembly.types![`${assembly.name}.${nestedType.namespace}`];\n      if (nestingType == null) {\n        continue;\n      }\n      const nestedTypeName = Case.pascal(nestedType.name);\n      for (const { name, member } of staticMembers(nestingType)) {\n        if (name === nestedTypeName) {\n          let diag = JsiiDiagnostic.JSII_5020_STATIC_MEMBER_CONFLICTS_WITH_NESTED_TYPE.create(\n            getRelatedNode(member)!,\n            nestingType,\n            member,\n            nestedType,\n          );\n          const nestedTypeNode = getRelatedNode(nestedType);\n          if (nestedTypeNode != null) {\n            diag = diag.addRelatedInformation(nestedTypeNode, 'This is the conflicting nested type declaration');\n          }\n          diagnostic(diag);\n        }\n      }\n    }\n\n    function staticMembers(type: spec.Type) {\n      if (spec.isClassOrInterfaceType(type)) {\n        return [\n          ...(type.methods?.filter((method) => method.static) ?? []),\n          ...(type.properties?.filter((prop) => prop.static) ?? []),\n        ].map((member) => ({ name: Case.pascal(member.name), member }));\n      }\n      return type.members.map((member) => ({ name: member.name, member }));\n    }\n  }\n}\n\nfunction _allTypes(assm: spec.Assembly): spec.Type[] {\n  return Object.values(assm.types ?? {});\n}\n\nfunction _allMethods(assm: spec.Assembly): Array<{ member: spec.Method; type: spec.Type }> {\n  const methods = new Array<{ member: spec.Method; type: spec.Type }>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (!type.methods) {\n      continue;\n    }\n    for (const method of type.methods) methods.push({ member: method, type });\n  }\n  return methods;\n}\n\nfunction _allProperties(assm: spec.Assembly): Array<{ member: spec.Property; type: spec.Type }> {\n  const properties = new Array<{ member: spec.Property; type: spec.Type }>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (!type.properties) {\n      continue;\n    }\n    for (const property of type.properties) properties.push({ member: property, type });\n  }\n  return properties;\n}\n\nfunction _allMembers(assm: spec.Assembly): Array<{ member: spec.Property | spec.Method; type: spec.Type }> {\n  return [..._allMethods(assm), ..._allProperties(assm)];\n}\n\ninterface AnnotatedTypeReference extends spec.NamedTypeReference {\n  readonly node: ts.Node | undefined;\n}\n\nfunction _allTypeReferences(assm: spec.Assembly): readonly AnnotatedTypeReference[] {\n  const typeReferences = new Array<AnnotatedTypeReference>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (spec.isClassType(type)) {\n      const node = bindings.getClassRelatedNode(type);\n      if (type.base) {\n        typeReferences.push({\n          fqn: type.base,\n          node: node?.heritageClauses?.find((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword)?.types[0],\n        });\n      }\n      if (type.initializer?.parameters) {\n        for (const param of type.initializer.parameters) {\n          _collectTypeReferences(param.type, bindings.getParameterRelatedNode(param)?.type);\n        }\n      }\n    }\n    if (type.interfaces) {\n      const node = bindings.getClassOrInterfaceRelatedNode(type);\n      for (const iface of type.interfaces) {\n        typeReferences.push({\n          fqn: iface,\n          node: node?.heritageClauses?.find(\n            (hc) =>\n              hc.token ===\n              (spec.isInterfaceType(type) ? ts.SyntaxKind.ImplementsKeyword : ts.SyntaxKind.ExtendsKeyword),\n          ),\n        });\n      }\n    }\n  }\n  for (const { member: prop } of _allProperties(assm)) {\n    _collectTypeReferences(prop.type, bindings.getPropertyRelatedNode(prop)?.type);\n  }\n  for (const { member: meth } of _allMethods(assm)) {\n    if (meth.returns) {\n      _collectTypeReferences(meth.returns.type, bindings.getMethodRelatedNode(meth)?.type);\n    }\n    for (const param of meth.parameters ?? []) {\n      _collectTypeReferences(param.type, bindings.getParameterRelatedNode(param)?.type);\n    }\n  }\n  return typeReferences;\n\n  function _collectTypeReferences(type: spec.TypeReference, node: ts.Node | undefined): void {\n    if (spec.isNamedTypeReference(type)) {\n      typeReferences.push({ ...type, node });\n    } else if (spec.isCollectionTypeReference(type)) {\n      _collectTypeReferences(type.collection.elementtype, node);\n    } else if (spec.isUnionTypeReference(type)) {\n      for (const t of type.union.types) _collectTypeReferences(t, node);\n    }\n  }\n}\n\nfunction _dereference(\n  typeRef: string | spec.NamedTypeReference,\n  assembly: spec.Assembly,\n  validator: Validator,\n): spec.Type | undefined {\n  if (typeof typeRef !== 'string') {\n    typeRef = typeRef.fqn;\n  }\n  const [assm] = typeRef.split('.');\n  if (assembly.name === assm) {\n    return assembly.types?.[typeRef];\n  }\n  const foreignAssm = validator.projectInfo.dependencyClosure.find((dep) => dep.name === assm);\n  return foreignAssm?.types?.[typeRef];\n}\n\nfunction _isEmpty(array: undefined | any[]): array is undefined {\n  return array == null || array.length === 0;\n}\n\n/**\n * Return whether an identifier only consists of upperchase characters, digits and underscores\n *\n * We have our own check here (isConstantCase) which is more lenient than what\n * `case.constant()` prescribes. We also want to allow combinations of letters\n * and digits without underscores: `C5A`, which `case` would force to `C5_A`.\n * The hint we print will still use `case.constant()` but that is fine.\n */\nfunction isConstantCase(x: string) {\n  return !/[^A-Z0-9_]/.exec(x);\n}\n\n/**\n * Obtains the name of the given declaration, if it has one, or returns the declaration itself.\n * This function is meant to be used as a convenience to obtain the `ts.Node` to bind a\n * `JsiiDianostic` instance on.\n *\n * It may return `undefined` but is typed as `ts.Node` so that it is easier to use with\n * `JsiiDiagnostic` factories.\n *\n * @param decl the declaration which name is needed.\n *\n * @returns the name of the declaration if it has one, or the declaration itself. Might return\n *          `undefined` if the provided declaration is undefined.\n */\nfunction declarationName(decl: ts.Declaration | ts.Expression | undefined): ts.Node {\n  if (decl == null) {\n    // Pretend we returned a node - this is used to create diagnostics, worst case it'll be unbound.\n    return decl as any;\n  }\n  return ts.getNameOfDeclaration(decl) ?? decl;\n}\n"]}