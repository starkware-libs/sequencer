"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeReviver = void 0;
/**
 * JSON/YAML reviver that:
 *
 * - Throws when an illegal key is detected.
 * - Replaces illegal values with a special marker.
 */
class SafeReviver {
    constructor(props) {
        this.allowlistedKeys = props?.allowlistedKeys ?? [];
        this.sanitizers = props?.sanitizers ?? [];
    }
    sanitizeValue(path, value) {
        for (const sanitizer of this.sanitizers) {
            const { applied, sanitized } = sanitizer(path, value);
            if (applied) {
                return sanitized;
            }
        }
        return value;
    }
    /**
     * Sanitizes a JSON object in-place.
     */
    sanitize(obj) {
        if (obj == null)
            return;
        this._sanitizeObj([], obj);
    }
    _sanitizeObj(path, partialObj) {
        for (const [key, value] of Object.entries(partialObj)) {
            if (typeof (key) !== 'string') {
                throw new Error(`Expected key (${key}) to be of type 'string', but got '${typeof (key)}'`);
            }
            if (!this.allowlistedKeys.includes(key) && !SafeReviver.LEGAL_CHARS.test(key)) {
                // keys cannot be stripped so we have to throw - thats ok, we don't want to parse such docs at all
                throw new Error(`Key '${key}' contains non standard characters (Must match regex '${SafeReviver.LEGAL_CHARS}')`);
            }
            const childPath = path.concat([key]);
            if (typeof (value) === 'string') {
                partialObj[key] = this.sanitizeValue(childPath, value);
            }
            else if (typeof (value) === 'object' && value !== null) {
                this._sanitizeObj(childPath, value); // recursive call
            }
        }
    }
}
exports.SafeReviver = SafeReviver;
// . | used in resource fqn which servers as a key (e.g io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup)
// / | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// - | used in annotation keys (e.g x-kubernetes-group-version-kind)
// # | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// , | used in values that represent a list (e.g merge,retainKeys)
// + | used in values representing MIME types (e.g application/json-patch+json)
// : | used in e.g. Prometheus events (e.g run:completed)
// * | used in e.g. AWS policies (e.g s3:ObjectCreated:*)
SafeReviver.LEGAL_CHARS = /^(\w|\.|\/|-|#|,)*$/;
SafeReviver.LEGAL_CHARS_IN_ENUM = /^( |\w|\.|\/|-|#|,|\+|:|\*|!|=|~)*$/;
// the string we use as the stripped value
SafeReviver.STRIPPED_VALUE = '__stripped_by_cdk8s__';
// remove characters from descriptions that might terminate the comment
SafeReviver.DESCRIPTION_SANITIZER = (path, value) => {
    if (path.length > 0 && path[path.length - 1] === 'description') {
        return { applied: true, sanitized: value.replace(/\*\//g, '_/') };
    }
    else {
        return { applied: false };
    }
};
// strip most illegal values
// the reason we don't throw is because sometimes these type of values exist in
// the original text for good reason, like for example a `jsonPath` key in a CRD manifest, and we don't
// want to fail the entire thing.
SafeReviver.LEGAL_CHAR_SANITIZER = (path, value) => {
    // case 1: we are in an array of enums
    if (path.length > 2 && path[path.length - 2] === 'enum' && /^\d+$/.test(path[path.length - 1])) {
        if (!SafeReviver.LEGAL_CHARS_IN_ENUM.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
        // case 2: default
    }
    else {
        if (!SafeReviver.LEGAL_CHARS.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV2aXZlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXZpdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQWNBOzs7OztHQUtHO0FBQ0gsTUFBYSxXQUFXO0lBc0R0QixZQUFZLEtBQXdCO1FBQ2xDLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxFQUFFLGVBQWUsSUFBSSxFQUFFLENBQUM7UUFDcEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLEVBQUUsVUFBVSxJQUFJLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRU0sYUFBYSxDQUFDLElBQWMsRUFBRSxLQUFhO1FBQ2hELEtBQUssTUFBTSxTQUFTLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN2QyxNQUFNLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDdEQsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTyxTQUFTLENBQUM7YUFDbEI7U0FDRjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUSxDQUFDLEdBQVE7UUFDdEIsSUFBSSxHQUFHLElBQUksSUFBSTtZQUFFLE9BQU87UUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVPLFlBQVksQ0FBQyxJQUFjLEVBQUUsVUFBZTtRQUNsRCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNyRCxJQUFJLE9BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLEVBQUU7Z0JBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsc0NBQXNDLE9BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDM0Y7WUFFRCxJQUFJLENBQUMs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XG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgdGhlIHBhdGggdG8gaXQgd2l0aGluIHRoZSBwYXJlbnQgb2JqZWN0LFxuICogYW5kIGVpdGhlciB0cmFuc2Zvcm1zIGl0IG9yIGxlYXZlcyBpdCBhbG9uZS5cbiAqL1xuZXhwb3J0IHR5cGUgU2FuaXRpemVyID0gKHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogc3RyaW5nKSA9PiB7IGFwcGxpZWQ6IGJvb2xlYW47IHNhbml0aXplZD86IHN0cmluZyB9O1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yICdTYWZlUmV2aXZlcicuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2FmZVJldml2ZXJQcm9wcyB7XG4gIHJlYWRvbmx5IGFsbG93bGlzdGVkS2V5cz86IHN0cmluZ1tdO1xuICByZWFkb25seSBzYW5pdGl6ZXJzPzogQXJyYXk8U2FuaXRpemVyPjtcbn1cblxuLyoqXG4gKiBKU09OL1lBTUwgcmV2aXZlciB0aGF0OlxuICpcbiAqIC0gVGhyb3dzIHdoZW4gYW4gaWxsZWdhbCBrZXkgaXMgZGV0ZWN0ZWQuXG4gKiAtIFJlcGxhY2VzIGlsbGVnYWwgdmFsdWVzIHdpdGggYSBzcGVjaWFsIG1hcmtlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhZmVSZXZpdmVyIHtcblxuICAvLyAuIHwgdXNlZCBpbiByZXNvdXJjZSBmcW4gd2hpY2ggc2VydmVycyBhcyBhIGtleSAoZS5nIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5BUElHcm91cClcbiAgLy8gLyB8IHVzZWQgaW4gJHJlZiB0byBwb2ludCB0byBhIGRlZmluaXRpb24gKGUuZyAjL2RlZmluaXRpb25zL2lvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5Hcm91cFZlcnNpb25Gb3JEaXNjb3ZlcnkpXG4gIC8vIC0gfCB1c2VkIGluIGFubm90YXRpb24ga2V5cyAoZS5nIHgta3ViZXJuZXRlcy1ncm91cC12ZXJzaW9uLWtpbmQpXG4gIC8vICMgfCB1c2VkIGluICRyZWYgdG8gcG9pbnQgdG8gYSBkZWZpbml0aW9uIChlLmcgIy9kZWZpbml0aW9ucy9pby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuR3JvdXBWZXJzaW9uRm9yRGlzY292ZXJ5KVxuICAvLyAsIHwgdXNlZCBpbiB2YWx1ZXMgdGhhdCByZXByZXNlbnQgYSBsaXN0IChlLmcgbWVyZ2UscmV0YWluS2V5cylcbiAgLy8gKyB8IHVzZWQgaW4gdmFsdWVzIHJlcHJlc2VudGluZyBNSU1FIHR5cGVzIChlLmcgYXBwbGljYXRpb24vanNvbi1wYXRjaCtqc29uKVxuICAvLyA6IHwgdXNlZCBpbiBlLmcuIFByb21ldGhldXMgZXZlbnRzIChlLmcgcnVuOmNvbXBsZXRlZClcbiAgLy8gKiB8IHVzZWQgaW4gZS5nLiBBV1MgcG9saWNpZXMgKGUuZyBzMzpPYmplY3RDcmVhdGVkOiopXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVHQUxfQ0hBUlMgPSAvXihcXHd8XFwufFxcL3wtfCN8LCkqJC87XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVHQUxfQ0hBUlNfSU5fRU5VTSA9IC9eKCB8XFx3fFxcLnxcXC98LXwjfCx8XFwrfDp8XFwqfCF8PXx+KSokLztcblxuICAvLyB0aGUgc3RyaW5nIHdlIHVzZSBhcyB0aGUgc3RyaXBwZWQgdmFsdWVcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTVFJJUFBFRF9WQUxVRSA9ICdfX3N0cmlwcGVkX2J5X2NkazhzX18nO1xuXG4gIC8vIHJlbW92ZSBjaGFyYWN0ZXJzIGZyb20gZGVzY3JpcHRpb25zIHRoYXQgbWlnaHQgdGVybWluYXRlIHRoZSBjb21tZW50XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVTQ1JJUFRJT05fU0FOSVRJWkVSOiBTYW5pdGl6ZXIgPSAocGF0aDogc3RyaW5nW10sIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ2Rlc2NyaXB0aW9uJykge1xuICAgICAgcmV0dXJuIHsgYXBwbGllZDogdHJ1ZSwgc2FuaXRpemVkOiB2YWx1ZS5yZXBsYWNlKC9cXCpcXC8vZywgJ18vJykgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgYXBwbGllZDogZmFsc2UgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gc3RyaXAgbW9zdCBpbGxlZ2FsIHZhbHVlc1xuICAvLyB0aGUgcmVhc29uIHdlIGRvbid0IHRocm93IGlzIGJlY2F1c2Ugc29tZXRpbWVzIHRoZXNlIHR5cGUgb2YgdmFsdWVzIGV4aXN0IGluXG4gIC8vIHRoZSBvcmlnaW5hbCB0ZXh0IGZvciBnb29kIHJlYXNvbiwgbGlrZSBmb3IgZXhhbXBsZSBhIGBqc29uUGF0aGAga2V5IGluIGEgQ1JEIG1hbmlmZXN0LCBhbmQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmYWlsIHRoZSBlbnRpcmUgdGhpbmcuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVHQUxfQ0hBUl9TQU5JVElaRVI6IFNhbml0aXplciA9IChwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgIC8vIGNhc2UgMTogd2UgYXJlIGluIGFuIGFycmF5IG9mIGVudW1zXG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMiAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMl0gPT09ICdlbnVtJyAmJiAvXlxcZCskLy50ZXN0KHBhdGhbcGF0aC5sZW5ndGggLSAxXSkpIHtcblxuICAgICAgaWYgKCFTYWZlUmV2aXZlci5MRUdBTF9DSEFSU19JTl9FTlVNLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGFwcGxpZWQ6IHRydWUsIHNhbml0aXplZDogU2FmZVJldml2ZXIuU1RSSVBQRURfVkFMVUUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGFwcGxpZWQ6IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICAvLyBjYXNlIDI6IGRlZmF1bHRcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoIVNhZmVSZXZpdmVyLkxFR0FMX0NIQVJTLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGFwcGxpZWQ6IHRydWUsIHNhbml0aXplZDogU2FmZVJldml2ZXIuU1RSSVBQRURfVkFMVUUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGFwcGxpZWQ6IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZWFkb25seSBhbGxvd2xpc3RlZEtleXM6IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IHNhbml0aXplcnM6IEFycmF5PFNhbml0aXplcj47XG5cbiAgY29uc3RydWN0b3IocHJvcHM/OiBTYWZlUmV2aXZlclByb3BzKSB7XG4gICAgdGhpcy5hbGxvd2xpc3RlZEtleXMgPSBwcm9wcz8uYWxsb3dsaXN0ZWRLZXlzID8/IFtdO1xuICAgIHRoaXMuc2FuaXRpemVycyA9IHByb3BzPy5zYW5pdGl6ZXJzID8/IFtdO1xuICB9XG5cbiAgcHVibGljIHNhbml0aXplVmFsdWUocGF0aDogc3RyaW5nW10sIHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3Qgc2FuaXRpemVyIG9mIHRoaXMuc2FuaXRpemVycykge1xuICAgICAgY29uc3QgeyBhcHBsaWVkLCBzYW5pdGl6ZWQgfSA9IHNhbml0aXplcihwYXRoLCB2YWx1ZSk7XG4gICAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICByZXR1cm4gc2FuaXRpemVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZXMgYSBKU09OIG9iamVjdCBpbi1wbGFjZS5cbiAgICovXG4gIHB1YmxpYyBzYW5pdGl6ZShvYmo6IGFueSkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgIHRoaXMuX3Nhbml0aXplT2JqKFtdLCBvYmopO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2FuaXRpemVPYmoocGF0aDogc3RyaW5nW10sIHBhcnRpYWxPYmo6IGFueSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnRpYWxPYmopKSB7XG4gICAgICBpZiAodHlwZW9mKGtleSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQga2V5ICgke2tleX0pIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGJ1dCBnb3QgJyR7dHlwZW9mKGtleSl9J2ApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYWxsb3dsaXN0ZWRLZXlzLmluY2x1ZGVzKGtleSkgJiYgIVNhZmVSZXZpdmVyLkxFR0FMX0NIQVJTLnRlc3Qoa2V5KSkge1xuICAgICAgICAvLyBrZXlzIGNhbm5vdCBiZSBzdHJpcHBlZCBzbyB3ZSBoYXZlIHRvIHRocm93IC0gdGhhdHMgb2ssIHdlIGRvbid0IHdhbnQgdG8gcGFyc2Ugc3VjaCBkb2NzIGF0IGFsbFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAnJHtrZXl9JyBjb250YWlucyBub24gc3RhbmRhcmQgY2hhcmFjdGVycyAoTXVzdCBtYXRjaCByZWdleCAnJHtTYWZlUmV2aXZlci5MRUdBTF9DSEFSU30nKWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChba2V5XSk7XG5cbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0aWFsT2JqW2tleV0gPSB0aGlzLnNhbml0aXplVmFsdWUoY2hpbGRQYXRoLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3Nhbml0aXplT2JqKGNoaWxkUGF0aCwgdmFsdWUpOyAvLyByZWN1cnNpdmUgY2FsbFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19