import { PluginManager } from './_manager';
import { ValidationConfig } from '../config';
import { SynthesizedApp } from '../util';
/**
 * Context available to plugins during validation.
 */
export declare class ValidationContext {
    /**
     * The list of manifests to validate.
     */
    readonly manifests: readonly string[];
    /**
     * The NodeJS package name of the plugin running the validation.
     */
    readonly pkg: string;
    /**
     * The version of the NodeJS package that runs the validation.
     */
    readonly version: string;
    /**
     * Construct metadata of resources in the application.
     */
    readonly metadata: {
        readonly [key: string]: ResourceConstructMetadata;
    };
    /**
     * Whether or not the synth command was executed with --stdout.
     */
    readonly stdout?: boolean | undefined;
    /**
     * Report emitted by the validation.
     *
     * Plugins should interact with this object to generate the report.
     */
    readonly report: ValidationReport;
    /**
     * Logger for the validation.
     *
     * Plugins should interact with this object to log messages during validation.
     */
    readonly logger: ValidationLogger;
    constructor(
    /**
     * The list of manifests to validate.
     */
    manifests: readonly string[], 
    /**
     * The NodeJS package name of the plugin running the validation.
     */
    pkg: string, 
    /**
     * The version of the NodeJS package that runs the validation.
     */
    version: string, 
    /**
     * Construct metadata of resources in the application.
     */
    metadata?: {
        readonly [key: string]: ResourceConstructMetadata;
    }, 
    /**
     * Whether or not the synth command was executed with --stdout.
     */
    stdout?: boolean | undefined);
    parseManifest(manifestPath: string): any[];
}
/**
 * Logger available to plugins during validation. Use this instead of `console.log`.
 */
export declare class ValidationLogger {
    /**
     * Log a message.
     */
    log(message: string): void;
}
/**
 * Contract between cdk8s and third-parties looking to implement validation plugins.
 */
export interface Validation {
    /**
     * Run the validation logic.
     *
     * - Use `context.manifests` to retrieve the list of manifests to validate.
     * - Use `context.report` to access and build the resulting report.
     *
     * Make sure to call `context.report.pass()` or `context.report.fail()` before returning, otherwise the validation is considered incomplete.
     */
    validate(context: ValidationContext): Promise<void>;
}
/**
 * Resource violating a specific rule.
 */
export interface ValidationViolatingResource {
    /**
     * The resource name.
     */
    readonly resourceName: string;
    /**
     * The locations in its config that pose the violations.
     */
    readonly locations: readonly string[];
    /**
     * The manifest this resource is defined in.
     */
    readonly manifestPath: string;
}
/**
 * Construct violating a specific rule.
 */
export interface ValidationViolatingConstruct extends ValidationViolatingResource {
    /**
     * The construct path as defined in the application.
     */
    readonly constructPath?: string;
}
/**
 * Violation produced by the validation plugin.
 */
export interface ValidationViolation {
    /**
     * The name of the rule.
     */
    readonly ruleName: string;
    /**
     * The recommendation to resolve the violation.
     */
    readonly recommendation: string;
    /**
     * How to fix the recommendation.
     */
    readonly fix: string;
    /**
     * The resources violating this rule.
     */
    readonly violatingResources: readonly ValidationViolatingResource[];
}
/**
 * Validation produced by the validation plugin, in construct terms.
 */
export interface ValidationViolationConstructAware extends Omit<ValidationViolation, 'violatingResources'> {
    /**
     * The constructs violating this rule.
     */
    readonly violatingConstructs: readonly ValidationViolatingConstruct[];
}
export type ValidationReportStatus = 'success' | 'failure';
/**
 * Summary of the report.
 */
export interface ValidationReportSummary {
    readonly status: ValidationReportStatus;
    readonly plugin: string;
    readonly version: string;
    readonly metadata?: {
        readonly [key: string]: string;
    };
}
/**
 * JSON representation of the report.
 */
export interface ValidationReportJson {
    /**
     * Report title.
     */
    readonly title: string;
    /**
     * List of violations in the rerpot.
     */
    readonly violations: readonly ValidationViolationConstructAware[];
    /**
     * Report summary.
     */
    readonly summary: ValidationReportSummary;
}
/**
 * The report emitted by the plugin after evaluation.
 */
export declare class ValidationReport {
    private readonly pkg;
    private readonly version;
    private readonly metadata;
    private readonly stdout;
    private readonly violations;
    private _summary?;
    constructor(pkg: string, version: string, metadata: {
        readonly [key: string]: ResourceConstructMetadata;
    }, stdout: boolean);
    /**
     * Add a violation to the report.
     */
    addViolation(violation: ValidationViolation): void;
    /**
     * Submit the report with a status and additional metadata.
     */
    submit(status: ValidationReportStatus, metadata?: {
        readonly [key: string]: string;
    }): void;
    /**
     * Whether or not the report was successfull.
     */
    get success(): boolean;
    /**
     * Transform the report to a well formatted table string.
     */
    toString(): string;
    /**
     * Transform the report into a JSON object.
     */
    toJson(): ValidationReportJson;
}
/**
 * Utiliy class for loading validation plugins.
 */
export declare class ValidationPlugin {
    /**
     * Load the validation plugin and create the necessary context for its execution.
     */
    static load(validation: ValidationConfig, app: SynthesizedApp, stdout: boolean, pluginManager: PluginManager): {
        plugin: Validation;
        context: ValidationContext;
    };
    private static loadConstructMetadata;
}
/**
 * Construct related metadata on resources.
 */
interface ResourceConstructMetadata {
    /**
     * The path of the construct in the application.
     */
    readonly path: string;
}
export {};
