"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginManager = void 0;
const child = __importStar(require("child_process"));
const path = __importStar(require("path"));
const url = __importStar(require("url"));
const fs = __importStar(require("fs-extra"));
const semver = __importStar(require("semver"));
const MODULE_NOT_FOUND_ERROR_CODE = 'MODULE_NOT_FOUND'; // TODO is there a known constant we can use here?
/**
 * A `PluginManager` is responsible for loading (and installing) plugins.
 */
class PluginManager {
    constructor(dir) {
        this.dir = dir;
    }
    load(options) {
        const pkg = this.loadPackage(options.pkg, options.version, options.installEnv ?? {});
        const clazz = pkg.module[options.class];
        if (!clazz) {
            throw new Error(`Unable to locate class '${options.class}' in package '${options.pkg}@${options.version}'. Are you sure you exported it?`);
        }
        return { instance: new clazz(options.properties ?? {}), class: options.class, package: pkg };
    }
    loadPackage(pkg, version, installEnv) {
        if (isRange(version)) {
            // we forbid version ranges because it might give the false impression we will be installing
            // the latest version (which we will not because it would mean contacting NPM on every synth)
            throw new Error(`Unsupported version spec for package ${pkg}: ${version}. Cannot be a range.`);
        }
        const proto = url.parse(pkg).protocol;
        if (proto) {
            // urls are not supported because they don't provide a name with which we can 'require' the module.
            // if needed, we can make the loader smarter and enable this, but not for now.
            throw new Error(`Unsupported package reference: ${pkg}. Can either be an NPM package name, or a local path to a directory`);
        }
        const local = path.isAbsolute(pkg)
            // assume relative paths start with '.' because otherise they
            // are easily confused with npm package names.
            || pkg.startsWith(`.${path.sep}`);
        // local plugins are loaded directly, npm packages are loaded
        // from the plugins directory.
        const modulePath = local ? path.resolve(process.cwd(), pkg) : this.pluginDir(pkg, version);
        const pluginName = local ? modulePath : pkg;
        try {
            return this.require(modulePath, version, pluginName);
        }
        catch (e) {
            if (![MODULE_NOT_FOUND_ERROR_CODE].includes(e.code)) {
                // some unexpected error
                throw e;
            }
            if (local) {
                // if a local plugin is missing, nothing we can do about it
                throw e;
            }
            // otherwise, we install from npm and re-require.
            this.installPackage(pkg, version, installEnv);
            return this.require(modulePath, version, pluginName);
        }
    }
    installPackage(pkg, version, env) {
        const pluginDir = path.join(this.dir, pkg, version);
        fs.mkdirpSync(pluginDir);
        const command = [
            'npm',
            'install', `${pkg}@${version}`,
            '--no-save',
            '--prefix', pluginDir,
        ].join(' ');
        const finalEnv = { ...process.env };
        for (const [key, value] of Object.entries(env)) {
            finalEnv[key] = typeof value === 'string' ? key : JSON.stringify(value);
        }
        console.log(`Installing validation plugin: ${pkg}@${version} (this may take a while the first time around)`);
        child.execSync(command, { stdio: ['ignore', 'pipe', 'pipe'], env: finalEnv });
    }
    require(spec, version, pluginName) {
        const modulePath = require.resolve(spec);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const module = require(modulePath);
        return { version, pkg: pluginName ?? spec, path: modulePath, module };
    }
    pluginDir(pkg, version) {
        return path.join(this.dir, pkg, version, 'node_modules', pkg);
    }
}
exports.PluginManager = PluginManager;
/**
 * Checks if a given version represents a range, or a pinned version.
 * For example:
 *
 *   - '1.x expands to '>=1.0.0 <2.0.0-0'
 *   - `~1.2' expands to '>=1.2.0 <1.3.0-0'
 *   - '1.2.3' expands to '1.2.3'
 */
function isRange(version) {
    return new semver.Range(version).range !== version;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX21hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGx1Z2lucy9fbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFEQUF1QztBQUN2QywyQ0FBNkI7QUFDN0IseUNBQTJCO0FBQzNCLDZDQUErQjtBQUMvQiwrQ0FBaUM7QUFFakMsTUFBTSwyQkFBMkIsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDLGtEQUFrRDtBQW1GMUc7O0dBRUc7QUFDSCxNQUFhLGFBQWE7SUFFeEIsWUFBNkIsR0FBVztRQUFYLFFBQUcsR0FBSCxHQUFHLENBQVE7SUFBRyxDQUFDO0lBRXJDLElBQUksQ0FBQyxPQUFpQztRQUUzQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXJGLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixPQUFPLENBQUMsS0FBSyxpQkFBaUIsT0FBTyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQzVJO1FBRUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUMvRixDQUFDO0lBRU8sV0FBVyxDQUFDLEdBQVcsRUFBRSxPQUFlLEVBQUUsVUFBa0M7UUFFbEYsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDcEIsNEZBQTRGO1lBQzVGLDZGQUE2RjtZQUM3RixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxHQUFHLEtBQUssT0FBTyxzQkFBc0IsQ0FBQyxDQUFDO1NBQ2hHO1FBRUQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFFdEMsSUFBSSxLQUFLLEVBQUU7WUFDVCxtR0FBbUc7WUFDbkcsOEVBQThFO1lBQzlFLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLEdBQUcscUVBQXFFLENBQUMsQ0FBQztTQUM3SDtRQUVELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDO1lBQ2hDLDZEQUE2RDtZQUM3RCw4Q0FBOEM7ZUFDM0MsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBRXBDLDZEQUE2RDtRQUM3RCw4QkFBOEI7UUFDOUIsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDM0YsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUU1QyxJQUFJO1lBQ0YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDdEQ7UUFBQyxPQUFPLENBQU0sRUFBRTtZQUVmLElBQUksQ0FBQyxDQUFDLDJCQUEyQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDbkQsd0JBQXdCO2dCQUN4QixNQUFNLENBQUMsQ0FBQzthQUNUO1lBRUQsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsMkRBQTJEO2dCQUMzRCxNQUFNLENBQUMsQ0FBQzthQUNUO1lBRUQsaURBQWlEO1lBQ2pELElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztZQUM5QyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztTQUN0RDtJQUVILENBQUM7SUFFTyxjQUFjLENBQUMsR0FBVyxFQUFFLE9BQWUsRUFBRSxHQUEyQjtRQUU5RSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BELEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFekIsTUFBTSxPQUFPLEdBQUc7WUFDZCxLQUFLO1lBQ0wsU0FBUyxFQUFFLEdBQUcsR0FBRyxJQUFJLE9BQU8sRUFBRTtZQUM5QixXQUFXO1lBQ1gsVUFBVSxFQUFFLFNBQVM7U0FDdEIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFWixNQUFNLFFBQVEsR0FBRyxFQUFFLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BDLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN6RTtRQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsaUNBQWlDLEdBQUcsSUFBSSxPQUFPLGdEQUFnRCxDQUFDLENBQUM7UUFDN0csS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ2hGLENBQUM7SUFFTyxPQUFPLENBQUMsSUFBWSxFQUFFLE9BQWUsRUFBRSxVQUFrQjtRQUUvRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpDLGlFQUFpRTtRQUNqRSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFbkMsT0FBTyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxJQUFJLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQ3hFLENBQUM7SUFFTyxTQUFTLENBQUMsR0FBVyxFQUFFLE9BQWU7UUFDNUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEUsQ0FBQztDQUVGO0FBakdELHNDQWlHQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLE9BQU8sQ0FBQyxPQUFlO0lBQzlCLE9BQU8sSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmNvbnN0IE1PRFVMRV9OT1RfRk9VTkRfRVJST1JfQ09ERSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgLy8gVE9ETyBpcyB0aGVyZSBhIGtub3duIGNvbnN0YW50IHdlIGNhbiB1c2UgaGVyZT9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIGxvYWRlZCBwbHVnaW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luIHtcblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIG9mIHRoZSBwbHVnaW4gY2xhc3MuXG4gICAqL1xuICByZWFkb25seSBpbnN0YW5jZTogdW5rbm93bjtcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBjbGFzcyBuYW1lLlxuICAgKi9cbiAgcmVhZG9ubHkgY2xhc3M6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBwYWNrYWdlLlxuICAgKi9cbiAgcmVhZG9ubHkgcGFja2FnZTogUGFja2FnZTtcblxufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgcGx1Z2luIHBhY2thZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFja2FnZSB7XG5cbiAgLyoqXG4gICAqIFRoZSBwbHVnaW4gbW9kdWxlLlxuICAgKi9cbiAgcmVhZG9ubHkgbW9kdWxlOiBSZXR1cm5UeXBlPE5vZGVSZXF1aXJlPjtcblxuICAvKipcbiAgICAqIFRoZSBucG0gcGFja2FnZSBvZiB0aGUgcGx1Z2luLlxuICAgICovXG4gIHJlYWRvbmx5IHBrZzogc3RyaW5nO1xuXG4gIC8qKlxuICAgICogVGhlIHZlcnNpb24gb2YgdGhlIHBsdWdpbi5cbiAgICAqL1xuICByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAgKiBUaGUgcGF0aCBvZiB0aGUgcGx1Z2luIG9uIHRoZSBsb2NhbCBzeXN0ZW0gKGFmdGVyIGl0cyBpbnN0YWxsZWQpLlxuICAgICovXG4gIHJlYWRvbmx5IHBhdGg6IHN0cmluZztcblxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGxvYWRpbmcgYSBwbHVnaW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luTWFuYWdlckxvYWRPcHRpb25zIHtcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBwYWNrYWdlIG5hbWUuXG4gICAqL1xuICByZWFkb25seSBwa2c6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBwYWNrYWdlIHZlcnNpb24uXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwbHVnaW4gcGFja2FnZSBjbGFzcy5cbiAgICovXG4gIHJlYWRvbmx5IGNsYXNzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEluc3RhbGxhdGlvbiBlbnZpcm9ubWVudCAocGFzc2VkIG9uIHRvIG5wbSBpbnN0YWxsKVxuICAgKi9cbiAgcmVhZG9ubHkgaW5zdGFsbEVudj86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBpbnN0YW50aWF0aW9uIHByb3BlcnRpZXMuXG4gICAqL1xuICByZWFkb25seSBwcm9wZXJ0aWVzPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcblxufVxuXG4vKipcbiAqIEEgYFBsdWdpbk1hbmFnZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIChhbmQgaW5zdGFsbGluZykgcGx1Z2lucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGlyOiBzdHJpbmcpIHt9XG5cbiAgcHVibGljIGxvYWQob3B0aW9uczogUGx1Z2luTWFuYWdlckxvYWRPcHRpb25zKTogUGx1Z2luIHtcblxuICAgIGNvbnN0IHBrZyA9IHRoaXMubG9hZFBhY2thZ2Uob3B0aW9ucy5wa2csIG9wdGlvbnMudmVyc2lvbiwgb3B0aW9ucy5pbnN0YWxsRW52ID8/IHt9KTtcblxuICAgIGNvbnN0IGNsYXp6ID0gcGtnLm1vZHVsZVtvcHRpb25zLmNsYXNzXTtcbiAgICBpZiAoIWNsYXp6KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2NhdGUgY2xhc3MgJyR7b3B0aW9ucy5jbGFzc30nIGluIHBhY2thZ2UgJyR7b3B0aW9ucy5wa2d9QCR7b3B0aW9ucy52ZXJzaW9ufScuIEFyZSB5b3Ugc3VyZSB5b3UgZXhwb3J0ZWQgaXQ/YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaW5zdGFuY2U6IG5ldyBjbGF6eihvcHRpb25zLnByb3BlcnRpZXMgPz8ge30pLCBjbGFzczogb3B0aW9ucy5jbGFzcywgcGFja2FnZTogcGtnIH07XG4gIH1cblxuICBwcml2YXRlIGxvYWRQYWNrYWdlKHBrZzogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIGluc3RhbGxFbnY6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBQYWNrYWdlIHtcblxuICAgIGlmIChpc1JhbmdlKHZlcnNpb24pKSB7XG4gICAgICAvLyB3ZSBmb3JiaWQgdmVyc2lvbiByYW5nZXMgYmVjYXVzZSBpdCBtaWdodCBnaXZlIHRoZSBmYWxzZSBpbXByZXNzaW9uIHdlIHdpbGwgYmUgaW5zdGFsbGluZ1xuICAgICAgLy8gdGhlIGxhdGVzdCB2ZXJzaW9uICh3aGljaCB3ZSB3aWxsIG5vdCBiZWNhdXNlIGl0IHdvdWxkIG1lYW4gY29udGFjdGluZyBOUE0gb24gZXZlcnkgc3ludGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHZlcnNpb24gc3BlYyBmb3IgcGFja2FnZSAke3BrZ306ICR7dmVyc2lvbn0uIENhbm5vdCBiZSBhIHJhbmdlLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3RvID0gdXJsLnBhcnNlKHBrZykucHJvdG9jb2w7XG5cbiAgICBpZiAocHJvdG8pIHtcbiAgICAgIC8vIHVybHMgYXJlIG5vdCBzdXBwb3J0ZWQgYmVjYXVzZSB0aGV5IGRvbid0IHByb3ZpZGUgYSBuYW1lIHdpdGggd2hpY2ggd2UgY2FuICdyZXF1aXJlJyB0aGUgbW9kdWxlLlxuICAgICAgLy8gaWYgbmVlZGVkLCB3ZSBjYW4gbWFrZSB0aGUgbG9hZGVyIHNtYXJ0ZXIgYW5kIGVuYWJsZSB0aGlzLCBidXQgbm90IGZvciBub3cuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhY2thZ2UgcmVmZXJlbmNlOiAke3BrZ30uIENhbiBlaXRoZXIgYmUgYW4gTlBNIHBhY2thZ2UgbmFtZSwgb3IgYSBsb2NhbCBwYXRoIHRvIGEgZGlyZWN0b3J5YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWwgPSBwYXRoLmlzQWJzb2x1dGUocGtnKVxuICAgICAgLy8gYXNzdW1lIHJlbGF0aXZlIHBhdGhzIHN0YXJ0IHdpdGggJy4nIGJlY2F1c2Ugb3RoZXJpc2UgdGhleVxuICAgICAgLy8gYXJlIGVhc2lseSBjb25mdXNlZCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVzLlxuICAgICAgfHwgcGtnLnN0YXJ0c1dpdGgoYC4ke3BhdGguc2VwfWApO1xuXG4gICAgLy8gbG9jYWwgcGx1Z2lucyBhcmUgbG9hZGVkIGRpcmVjdGx5LCBucG0gcGFja2FnZXMgYXJlIGxvYWRlZFxuICAgIC8vIGZyb20gdGhlIHBsdWdpbnMgZGlyZWN0b3J5LlxuICAgIGNvbnN0IG1vZHVsZVBhdGggPSBsb2NhbCA/IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBwa2cpIDogdGhpcy5wbHVnaW5EaXIocGtnLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwbHVnaW5OYW1lID0gbG9jYWwgPyBtb2R1bGVQYXRoIDogcGtnO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmUobW9kdWxlUGF0aCwgdmVyc2lvbiwgcGx1Z2luTmFtZSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG5cbiAgICAgIGlmICghW01PRFVMRV9OT1RfRk9VTkRfRVJST1JfQ09ERV0uaW5jbHVkZXMoZS5jb2RlKSkge1xuICAgICAgICAvLyBzb21lIHVuZXhwZWN0ZWQgZXJyb3JcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgIC8vIGlmIGEgbG9jYWwgcGx1Z2luIGlzIG1pc3NpbmcsIG5vdGhpbmcgd2UgY2FuIGRvIGFib3V0IGl0XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2UgaW5zdGFsbCBmcm9tIG5wbSBhbmQgcmUtcmVxdWlyZS5cbiAgICAgIHRoaXMuaW5zdGFsbFBhY2thZ2UocGtnLCB2ZXJzaW9uLCBpbnN0YWxsRW52KTtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmUobW9kdWxlUGF0aCwgdmVyc2lvbiwgcGx1Z2luTmFtZSk7XG4gICAgfVxuXG4gIH1cblxuICBwcml2YXRlIGluc3RhbGxQYWNrYWdlKHBrZzogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIGVudjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuXG4gICAgY29uc3QgcGx1Z2luRGlyID0gcGF0aC5qb2luKHRoaXMuZGlyLCBwa2csIHZlcnNpb24pO1xuICAgIGZzLm1rZGlycFN5bmMocGx1Z2luRGlyKTtcblxuICAgIGNvbnN0IGNvbW1hbmQgPSBbXG4gICAgICAnbnBtJyxcbiAgICAgICdpbnN0YWxsJywgYCR7cGtnfUAke3ZlcnNpb259YCxcbiAgICAgICctLW5vLXNhdmUnLFxuICAgICAgJy0tcHJlZml4JywgcGx1Z2luRGlyLFxuICAgIF0uam9pbignICcpO1xuXG4gICAgY29uc3QgZmluYWxFbnYgPSB7IC4uLnByb2Nlc3MuZW52IH07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZW52KSkge1xuICAgICAgZmluYWxFbnZba2V5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBrZXkgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBJbnN0YWxsaW5nIHZhbGlkYXRpb24gcGx1Z2luOiAke3BrZ31AJHt2ZXJzaW9ufSAodGhpcyBtYXkgdGFrZSBhIHdoaWxlIHRoZSBmaXJzdCB0aW1lIGFyb3VuZClgKTtcbiAgICBjaGlsZC5leGVjU3luYyhjb21tYW5kLCB7IHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSwgZW52OiBmaW5hbEVudiB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVxdWlyZShzcGVjOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgcGx1Z2luTmFtZTogc3RyaW5nKTogUGFja2FnZSB7XG5cbiAgICBjb25zdCBtb2R1bGVQYXRoID0gcmVxdWlyZS5yZXNvbHZlKHNwZWMpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjb25zdCBtb2R1bGUgPSByZXF1aXJlKG1vZHVsZVBhdGgpO1xuXG4gICAgcmV0dXJuIHsgdmVyc2lvbiwgcGtnOiBwbHVnaW5OYW1lID8/IHNwZWMsIHBhdGg6IG1vZHVsZVBhdGgsIG1vZHVsZSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwbHVnaW5EaXIocGtnOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5kaXIsIHBrZywgdmVyc2lvbiwgJ25vZGVfbW9kdWxlcycsIHBrZyk7XG4gIH1cblxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIHZlcnNpb24gcmVwcmVzZW50cyBhIHJhbmdlLCBvciBhIHBpbm5lZCB2ZXJzaW9uLlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICAtICcxLnggZXhwYW5kcyB0byAnPj0xLjAuMCA8Mi4wLjAtMCdcbiAqICAgLSBgfjEuMicgZXhwYW5kcyB0byAnPj0xLjIuMCA8MS4zLjAtMCdcbiAqICAgLSAnMS4yLjMnIGV4cGFuZHMgdG8gJzEuMi4zJ1xuICovXG5mdW5jdGlvbiBpc1JhbmdlKHZlcnNpb246IHN0cmluZykge1xuICByZXR1cm4gbmV3IHNlbXZlci5SYW5nZSh2ZXJzaW9uKS5yYW5nZSAhPT0gdmVyc2lvbjtcbn0iXX0=