"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ALL_TYPESYSTEM_ENFORCED_FEATURES = exports.ALL_FEATURES = exports.TypeKind = exports.CANONICAL_ANY = exports.PrimitiveType = exports.CollectionKind = exports.Stability = exports.SchemaVersion = exports.SPEC_FILE_NAME_COMPRESSED = exports.SPEC_FILE_NAME = void 0;
exports.isNamedTypeReference = isNamedTypeReference;
exports.isPrimitiveTypeReference = isPrimitiveTypeReference;
exports.isCollectionTypeReference = isCollectionTypeReference;
exports.isUnionTypeReference = isUnionTypeReference;
exports.isIntersectionTypeReference = isIntersectionTypeReference;
exports.isMethod = isMethod;
exports.isClassType = isClassType;
exports.isInterfaceType = isInterfaceType;
exports.isEnumType = isEnumType;
exports.isClassOrInterfaceType = isClassOrInterfaceType;
exports.describeTypeReference = describeTypeReference;
exports.isDeprecated = isDeprecated;
/**
 * Expected file name for jsii assembly or instructions to compressed assembly.
 */
exports.SPEC_FILE_NAME = '.jsii';
/**
 * Expected file name for compressed assemblies.
 */
exports.SPEC_FILE_NAME_COMPRESSED = `${exports.SPEC_FILE_NAME}.gz`;
/**
 * Versions of the JSII Assembly Specification.
 */
var SchemaVersion;
(function (SchemaVersion) {
    SchemaVersion["LATEST"] = "jsii/0.10.0";
})(SchemaVersion || (exports.SchemaVersion = SchemaVersion = {}));
/**
 * API Stability levels. These are modeled after the `node` stability index.
 *
 * @see https://nodejs.org/api/documentation.html#documentation_stability_index.
 */
var Stability;
(function (Stability) {
    /**
     * The API may emit warnings. Backward compatibility is not guaranteed.
     *
     * More information about the deprecation can usually be found in the
     * `deprecated` field.
     */
    Stability["Deprecated"] = "deprecated";
    /**
     * This API is still under active development and subject to non-backward
     * compatible changes or removal in any future version. Use of the API is
     * not recommended in production environments. Experimental APIs are not
     * subject to the Semantic Versioning model.
     */
    Stability["Experimental"] = "experimental";
    /**
     * This API is subject to the Semantic Versioning model and may not change
     * in breaking ways in a subsequent minor or patch version.
     */
    Stability["Stable"] = "stable";
    /**
     * This API is an representation of an API managed elsewhere and follows
     * the other API's versioning model.
     */
    Stability["External"] = "external";
})(Stability || (exports.Stability = Stability = {}));
/**
 * Kinds of collections.
 */
var CollectionKind;
(function (CollectionKind) {
    /**
     * An array, or a list of some element type.
     */
    CollectionKind["Array"] = "array";
    /**
     * A map of a string to some element type.
     */
    CollectionKind["Map"] = "map";
})(CollectionKind || (exports.CollectionKind = CollectionKind = {}));
/**
 * Kinds of primitive types.
 */
var PrimitiveType;
(function (PrimitiveType) {
    /**
     * A JSON date (represented as it's ISO-8601 string form).
     */
    PrimitiveType["Date"] = "date";
    /**
     * A plain string.
     */
    PrimitiveType["String"] = "string";
    /**
     * A number (integer or float).
     */
    PrimitiveType["Number"] = "number";
    /**
     * A boolean value.
     */
    PrimitiveType["Boolean"] = "boolean";
    /**
     * A JSON object
     */
    PrimitiveType["Json"] = "json";
    /**
     * Value with "any" or "unknown" type (aka Object). Values typed `any` may
     * be `null` or `undefined`.
     */
    PrimitiveType["Any"] = "any";
})(PrimitiveType || (exports.PrimitiveType = PrimitiveType = {}));
/**
 * The standard representation of the `any` type (includes optionality marker).
 */
exports.CANONICAL_ANY = {
    primitive: PrimitiveType.Any,
};
function isNamedTypeReference(ref) {
    return !!ref?.fqn;
}
function isPrimitiveTypeReference(ref) {
    return !!ref?.primitive;
}
function isCollectionTypeReference(ref) {
    return !!ref?.collection;
}
function isUnionTypeReference(ref) {
    return !!ref?.union;
}
function isIntersectionTypeReference(ref) {
    return !!ref?.intersection;
}
/**
 * Determines whether a Callable is a Method or not.
 *
 * @param callable the callable to be checked.
 */
function isMethod(callable) {
    return !!callable.name;
}
/**
 * Kinds of types.
 */
var TypeKind;
(function (TypeKind) {
    TypeKind["Class"] = "class";
    TypeKind["Enum"] = "enum";
    TypeKind["Interface"] = "interface";
})(TypeKind || (exports.TypeKind = TypeKind = {}));
function isClassType(type) {
    return type?.kind === TypeKind.Class;
}
function isInterfaceType(type) {
    return type?.kind === TypeKind.Interface;
}
function isEnumType(type) {
    return type?.kind === TypeKind.Enum;
}
/**
 * Return whether this type is a class or interface type
 */
function isClassOrInterfaceType(type) {
    return isClassType(type) || isInterfaceType(type);
}
/**
 * Return a string representation of the given type reference.
 */
function describeTypeReference(type) {
    if (type === undefined) {
        return 'void';
    }
    if (isNamedTypeReference(type)) {
        return type.fqn;
    }
    if (isPrimitiveTypeReference(type)) {
        return type.primitive;
    }
    if (isCollectionTypeReference(type)) {
        return `${type.collection.kind}<${describeTypeReference(type.collection.elementtype)}>`;
    }
    if (isUnionTypeReference(type)) {
        const unionType = type.union.types.map(describeTypeReference).join(' | ');
        return unionType;
    }
    throw new Error('Unrecognized type reference');
}
/**
 * For every feature, is it enforced by the type system?
 *
 * Effectively: if a jsii tools links against the most recent version of the
 * spec, is the TypeScript type system going to ensure that they must have
 * support for a given new feature, through exhaustiveness checking?
 *
 * (This map also forces completeness, so we are guaranteed to have a string
 * value for every possible `JsiiFeature` type branch).
 */
const IS_FEATURE_TYPESYSTEM_ENFORCED = {
    'intersection-types': true,
};
/**
 * A list of all jsii extension features
 */
exports.ALL_FEATURES = Object.keys(IS_FEATURE_TYPESYSTEM_ENFORCED);
/**
 * A list of all jsii extension features
 */
exports.ALL_TYPESYSTEM_ENFORCED_FEATURES = Object.entries(IS_FEATURE_TYPESYSTEM_ENFORCED)
    .filter(([_, v]) => v)
    .map(([k, _]) => k);
/**
 * Determines whether an entity is deprecated.
 *
 * @param entity the entity to be checked.
 *
 * @returns true if the entity is marked as deprecated.
 */
function isDeprecated(entity) {
    return entity?.docs?.stability === Stability.Deprecated;
}
//# sourceMappingURL=assembly.js.map