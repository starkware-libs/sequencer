{
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.add_mod": {
    "description": "Max number of add mod builtin usage in a block.",
    "privacy": "Public",
    "value": 156250
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.bitwise": {
    "description": "Max number of bitwise builtin usage in a block.",
    "privacy": "Public",
    "value": 39062
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.ec_op": {
    "description": "Max number of EC operation builtin usage in a block.",
    "privacy": "Public",
    "value": 2441
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.ecdsa": {
    "description": "Max number of ECDSA builtin usage in a block.",
    "privacy": "Public",
    "value": 1220
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.keccak": {
    "description": "Max number of keccak builtin usage in a block.",
    "privacy": "Public",
    "value": 1220
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.mul_mod": {
    "description": "Max number of mul mod builtin usage in a block.",
    "privacy": "Public",
    "value": 156250
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.pedersen": {
    "description": "Max number of pedersen builtin usage in a block.",
    "privacy": "Public",
    "value": 78125
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.poseidon": {
    "description": "Max number of poseidon builtin usage in a block.",
    "privacy": "Public",
    "value": 78125
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.range_check": {
    "description": "Max number of range check builtin usage in a block.",
    "privacy": "Public",
    "value": 156250
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.builtin_count.range_check96": {
    "description": "Max number of range check 96 builtin usage in a block.",
    "privacy": "Public",
    "value": 156250
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.gas": {
    "description": "An upper bound on the total gas used in a block.",
    "privacy": "Public",
    "value": 2500000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.message_segment_length": {
    "description": "An upper bound on the message segment length in a block.",
    "privacy": "Public",
    "value": 3700
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_events": {
    "description": "An upper bound on the total number of events generated in a block.",
    "privacy": "Public",
    "value": 5000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_steps": {
    "description": "An upper bound on the total number of steps in a block.",
    "privacy": "Public",
    "value": 2500000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.state_diff_size": {
    "description": "An upper bound on the total state diff size in a block.",
    "privacy": "Public",
    "value": 4000
  },
  "batcher_config.block_builder_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "privacy": "Public",
    "value": "0x0"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "privacy": "Public",
    "value": "0x0"
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.chunk_size": {
    "description": "The size of the transaction chunk executed in parallel.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.enabled": {
    "description": "Enables concurrency of transaction execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.n_workers": {
    "description": "Number of parallel transaction execution workers.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.sequencer_address": {
    "description": "The address of the sequencer.",
    "privacy": "Public",
    "value": "0x0"
  },
  "batcher_config.block_builder_config.tx_chunk_size": {
    "description": "The size of the transaction chunk.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.block_builder_config.use_kzg_da": {
    "description": "Indicates whether the kzg mechanism is used for data availability.",
    "privacy": "Public",
    "value": true
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "privacy": "Public",
    "value": 10000000
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "privacy": "Public",
    "value": 50
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "privacy": "Public",
    "value": 1000000
  },
  "batcher_config.global_contract_cache_size": {
    "description": "Cache size for the global_class_hash_to_class. Initialized with this size on creation.",
    "privacy": "Public",
    "value": 400
  },
  "batcher_config.outstream_content_buffer_size": {
    "description": "Maximum items to add to the outstream buffer before blocking further filling of the stream.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.storage.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.storage.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": true
  },
  "batcher_config.storage.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "batcher_config.storage.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "batcher_config.storage.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "."
  },
  "batcher_config.storage.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "batcher_config.storage.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "batcher_config.storage.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "StateOnly"
  },
  "chain_id": {
    "description": "The chain to follow.",
    "privacy": "TemporaryValue",
    "value": "SN_MAIN"
  },
  "compiler_config.max_bytecode_size": {
    "description": "Limitation of contract bytecode size.",
    "privacy": "Public",
    "value": 81920
  },
  "components.batcher.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": false
  },
  "components.batcher.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.batcher.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.batcher.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.batcher.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.batcher.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.batcher.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.batcher.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.batcher.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.batcher.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.consensus_manager.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": false
  },
  "components.consensus_manager.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.consensus_manager.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.consensus_manager.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.consensus_manager.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.consensus_manager.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.consensus_manager.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.consensus_manager.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.consensus_manager.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.consensus_manager.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.gateway.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": false
  },
  "components.gateway.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.gateway.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.gateway.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.gateway.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.gateway.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.gateway.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.gateway.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.gateway.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.gateway.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.http_server.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": true
  },
  "components.http_server.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.http_server.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.http_server.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.http_server.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.http_server.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.http_server.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.http_server.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.http_server.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.http_server.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": false
  },
  "components.mempool.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.mempool.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool_p2p.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": false
  },
  "components.mempool_p2p.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.mempool_p2p.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool_p2p.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool_p2p.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool_p2p.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool_p2p.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool_p2p.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool_p2p.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool_p2p.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.monitoring_endpoint.execution_mode.LocalExecution.enable_remote_connection": {
    "description": "Specifies whether the component, when running locally, allows remote connections.",
    "privacy": "Public",
    "value": true
  },
  "components.monitoring_endpoint.local_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.monitoring_endpoint.local_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.monitoring_endpoint.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.monitoring_endpoint.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.monitoring_endpoint.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.monitoring_endpoint.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.monitoring_endpoint.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.monitoring_endpoint.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.monitoring_endpoint.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "consensus_manager_config.consensus_config.consensus_delay": {
    "description": "Delay (seconds) before starting consensus to give time for network peering.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_config.network_topic": {
    "description": "The network topic of the consensus.",
    "privacy": "Public",
    "value": "consensus"
  },
  "consensus_manager_config.consensus_config.num_validators": {
    "description": "The number of validators in the consensus.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.consensus_config.start_height": {
    "description": "The height to start the consensus from.",
    "privacy": "Public",
    "value": 0
  },
  "consensus_manager_config.consensus_config.timeouts.precommit_timeout": {
    "description": "The timeout (seconds) for a precommit.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.prevote_timeout": {
    "description": "The timeout (seconds) for a prevote.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.proposal_timeout": {
    "description": "The timeout (seconds) for a proposal.",
    "privacy": "Public",
    "value": 3.0
  },
  "consensus_manager_config.consensus_config.validator_id": {
    "description": "The validator id of the node.",
    "privacy": "Public",
    "value": "0x0"
  },
  "gateway_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "privacy": "Public",
    "value": "0x0"
  },
  "gateway_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "privacy": "Public",
    "value": "0x0"
  },
  "gateway_config.stateful_tx_validator_config.max_nonce_for_validation_skip": {
    "description": "Maximum nonce for which the validation is skipped.",
    "privacy": "Public",
    "value": "0x1"
  },
  "gateway_config.stateful_tx_validator_config.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "privacy": "Public",
    "value": 50
  },
  "gateway_config.stateful_tx_validator_config.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to take.",
    "privacy": "Public",
    "value": 1000000
  },
  "gateway_config.stateless_tx_validator_config.max_calldata_length": {
    "description": "Limitation of calldata length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.max_contract_class_object_size": {
    "description": "Limitation of contract class object size.",
    "privacy": "Public",
    "value": 4089446
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 5
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "gateway_config.stateless_tx_validator_config.max_signature_length": {
    "description": "Limitation of signature length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 0
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l1_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L1 resource bounds.",
    "privacy": "Public",
    "value": true
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l2_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L2 resource bounds.",
    "privacy": "Public",
    "value": false
  },
  "http_server_config.ip": {
    "description": "The http server ip.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "http_server_config.port": {
    "description": "The http server port.",
    "privacy": "Public",
    "value": 8080
  },
  "mempool_p2p_config.network_buffer_size": {
    "description": "Network buffer size.",
    "privacy": "Public",
    "value": 0
  },
  "mempool_p2p_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_p2p_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 31536000
  },
  "mempool_p2p_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "mempool_p2p_config.network_config.quic_port": {
    "description": "The port that the node listens on for incoming quic connections.",
    "privacy": "Public",
    "value": 10001
  },
  "mempool_p2p_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "mempool_p2p_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.tcp_port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 10000
  },
  "monitoring_endpoint_config.ip": {
    "description": "The monitoring endpoint ip address.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "monitoring_endpoint_config.port": {
    "description": "The monitoring endpoint port.",
    "privacy": "Public",
    "value": 8082
  },
  "rpc_state_reader_config.json_rpc_version": {
    "description": "The json rpc version.",
    "privacy": "Public",
    "value": ""
  },
  "rpc_state_reader_config.url": {
    "description": "The url of the rpc server.",
    "privacy": "Public",
    "value": ""
  }
}
