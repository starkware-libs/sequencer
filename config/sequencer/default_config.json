{
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.l1_gas": {
    "description": "An upper bound on the total l1_gas used in a block.",
    "privacy": "Public",
    "value": 2500000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.message_segment_length": {
    "description": "An upper bound on the message segment length in a block.",
    "privacy": "Public",
    "value": 3700
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_events": {
    "description": "An upper bound on the total number of events generated in a block.",
    "privacy": "Public",
    "value": 5000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.proving_gas": {
    "description": "An upper bound on the total builtins and steps gas usage used in a block.",
    "privacy": "Public",
    "value": 5000000000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.sierra_gas": {
    "description": "An upper bound on the total sierra_gas used in a block.",
    "privacy": "Public",
    "value": 4000000000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.state_diff_size": {
    "description": "An upper bound on the total state diff size in a block.",
    "privacy": "Public",
    "value": 4000
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.add_mod": {
    "description": "Add_mod gas weight.",
    "privacy": "Public",
    "value": 250
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.bitwise": {
    "description": "Bitwise gas weight.",
    "privacy": "Public",
    "value": 583
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.ec_op": {
    "description": "Ec_op gas weight.",
    "privacy": "Public",
    "value": 714875
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.ecdsa": {
    "description": "Ecdsa gas weight.",
    "privacy": "Public",
    "value": 1666666
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.keccak": {
    "description": "Keccak gas weight.",
    "privacy": "Public",
    "value": 510707
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.mul_mod": {
    "description": "Mul_mod gas weight.",
    "privacy": "Public",
    "value": 604
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.pedersen": {
    "description": "Pedersen gas weight.",
    "privacy": "Public",
    "value": 10125
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.poseidon": {
    "description": "Poseidon gas weight.",
    "privacy": "Public",
    "value": 6250
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.range_check": {
    "description": "Range_check gas weight.",
    "privacy": "Public",
    "value": 70
  },
  "batcher_config.block_builder_config.bouncer_config.builtin_weights.range_check96": {
    "description": "range_check96 gas weight.",
    "privacy": "Public",
    "value": 56
  },
  "batcher_config.block_builder_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.chunk_size": {
    "description": "The size of the transaction chunk executed in parallel.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.enabled": {
    "description": "Enables concurrency of transaction execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.n_workers": {
    "description": "Number of parallel transaction execution workers.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.execute_config.stack_size": {
    "description": "The thread stack size (proportional to the maximal gas of a transaction).",
    "privacy": "Public",
    "value": 62914560
  },
  "batcher_config.block_builder_config.tx_chunk_size": {
    "description": "The size of the transaction chunk.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.channel_size": {
    "description": "The size of the compilation request channel.",
    "privacy": "Public",
    "value": 2000
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.native_classes_whitelist": {
    "description": "Contracts for Cairo Specifies whether to execute all class hashes or only a limited selection using Cairo native contracts. If limited, a specific list of class hashes is provided. compilation.",
    "privacy": "Public",
    "value": "All"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.panic_on_compilation_failure": {
    "description": "Whether to panic on compilation failure.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.run_cairo_native": {
    "description": "Enables Cairo native execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.wait_on_native_compilation": {
    "description": "Block Sequencer main program while compiling sierra, for testing.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.contract_cache_size": {
    "description": "The size of the global contract cache.",
    "privacy": "Public",
    "value": 600
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.compiler_binary_path": {
    "description": "The path to the Sierra-to-Native compiler binary.",
    "privacy": "Public",
    "value": ""
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.compiler_binary_path.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_cpu_time": {
    "description": "Limitation of compilation cpu time (seconds).",
    "privacy": "Public",
    "value": 20
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_cpu_time.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_file_size": {
    "description": "Limitation of compiled Cairo Native file size (bytes).",
    "privacy": "Public",
    "value": 15728640
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_file_size.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_memory_usage": {
    "description": "Limitation of compilation process's virtual memory (bytes).",
    "privacy": "Public",
    "value": 5368709120
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_memory_usage.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.optimization_level": {
    "description": "The level of optimization to apply during compilation.",
    "privacy": "Public",
    "value": 2
  },
  "batcher_config.input_stream_content_buffer_size": {
    "description": "Sets the buffer size for the input transaction channel. Adding more transactions beyond this limit will block until space is available.",
    "privacy": "Public",
    "value": 400
  },
  "batcher_config.max_l1_handler_txs_per_block_proposal": {
    "description": "The maximum number of L1 handler transactions to include in a block proposal.",
    "privacy": "Public",
    "value": 3
  },
  "batcher_config.outstream_content_buffer_size": {
    "description": "The maximum number of items to include in a single get_proposal_content response.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.storage.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.storage.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": true
  },
  "batcher_config.storage.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "batcher_config.storage.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "batcher_config.storage.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "."
  },
  "batcher_config.storage.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "batcher_config.storage.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "batcher_config.storage.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "StateOnly"
  },
  "chain_id": {
    "description": "A required param! The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "param_type": "String",
    "privacy": "TemporaryValue"
  },
  "compiler_config.max_bytecode_size": {
    "description": "Limitation of compiled CASM bytecode size (felts).",
    "privacy": "Public",
    "value": 81920
  },
  "components.batcher.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.batcher.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.batcher.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.batcher.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.batcher.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.batcher.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.batcher.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.batcher.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.batcher.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.batcher.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.consensus_manager.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.consensus_manager.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.consensus_manager.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.consensus_manager.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.consensus_manager.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.consensus_manager.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.gateway.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.gateway.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.gateway.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.gateway.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.gateway.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.gateway.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.gateway.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.gateway.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.gateway.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.gateway.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.http_server.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.http_server.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.http_server.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.http_server.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.http_server.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.http_server.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.l1_provider.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_provider.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.l1_provider.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.l1_provider.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.l1_provider.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.l1_provider.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.l1_provider.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.l1_provider.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.l1_provider.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.l1_provider.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.mempool.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool_p2p.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool_p2p.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.mempool_p2p.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool_p2p.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool_p2p.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool_p2p.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool_p2p.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool_p2p.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.mempool_p2p.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.mempool_p2p.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.monitoring_endpoint.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.monitoring_endpoint.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.monitoring_endpoint.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.monitoring_endpoint.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.monitoring_endpoint.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.monitoring_endpoint.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.state_sync.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.state_sync.local_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "components.state_sync.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.state_sync.remote_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.state_sync.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.state_sync.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.state_sync.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.state_sync.remote_client_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "components.state_sync.remote_server_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.state_sync.remote_server_config.socket": {
    "description": "The remote component server socket.",
    "privacy": "Public",
    "value": "0.0.0.0:8080"
  },
  "consensus_manager_config.consensus_config.chain_id": {
    "description": "The chain id of the Starknet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.consensus_config.consensus_delay": {
    "description": "Delay (seconds) before starting consensus to give time for network peering.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.consensus_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.consensus_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.consensus_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.consensus_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.consensus_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "consensus_manager_config.consensus_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.consensus_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.consensus_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 31536000
  },
  "consensus_manager_config.consensus_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.consensus_config.network_config.quic_port": {
    "description": "The port that the node listens on for incoming quic connections.",
    "privacy": "Public",
    "value": 10101
  },
  "consensus_manager_config.consensus_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "consensus_manager_config.consensus_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.consensus_config.network_config.tcp_port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 10100
  },
  "consensus_manager_config.consensus_config.network_topic": {
    "description": "The network topic of the consensus.",
    "privacy": "Public",
    "value": "consensus"
  },
  "consensus_manager_config.consensus_config.num_validators": {
    "description": "The number of validators in the consensus.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.consensus_config.start_height": {
    "description": "The height to start the consensus from.",
    "privacy": "Public",
    "value": 0
  },
  "consensus_manager_config.consensus_config.timeouts.precommit_timeout": {
    "description": "The timeout (seconds) for a precommit.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.prevote_timeout": {
    "description": "The timeout (seconds) for a prevote.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.proposal_timeout": {
    "description": "The timeout (seconds) for a proposal.",
    "privacy": "Public",
    "value": 3.0
  },
  "consensus_manager_config.consensus_config.validator_id": {
    "description": "The validator id of the node.",
    "pointer_target": "validator_id",
    "privacy": "Public"
  },
  "eth_fee_token_address": {
    "description": "A required param! Address of the ETH fee token.",
    "param_type": "String",
    "privacy": "TemporaryValue"
  },
  "gateway_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.max_nonce_for_validation_skip": {
    "description": "Maximum nonce for which the validation is skipped.",
    "privacy": "Public",
    "value": "0x1"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateless_tx_validator_config.max_calldata_length": {
    "description": "Limitation of calldata length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.max_contract_class_object_size": {
    "description": "Limitation of contract class object size.",
    "privacy": "Public",
    "value": 4089446
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 5
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "gateway_config.stateless_tx_validator_config.max_signature_length": {
    "description": "Limitation of signature length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 0
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l1_data_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L1 Data (Blob) resource bounds.",
    "privacy": "Public",
    "value": false
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l1_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L1 resource bounds.",
    "privacy": "Public",
    "value": true
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l2_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L2 resource bounds.",
    "privacy": "Public",
    "value": false
  },
  "http_server_config.ip": {
    "description": "The http server ip.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "http_server_config.port": {
    "description": "The http server port.",
    "privacy": "Public",
    "value": 8080
  },
  "l1_provider_config._poll_interval": {
    "description": "Interval in milliseconds between each scraping attempt of L1.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_p2p_config.network_buffer_size": {
    "description": "Network buffer size.",
    "privacy": "Public",
    "value": 10000
  },
  "mempool_p2p_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_p2p_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 31536000
  },
  "mempool_p2p_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "mempool_p2p_config.network_config.quic_port": {
    "description": "The port that the node listens on for incoming quic connections.",
    "privacy": "Public",
    "value": 10001
  },
  "mempool_p2p_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "mempool_p2p_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.tcp_port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 10000
  },
  "monitoring_endpoint_config.collect_metrics": {
    "description": "If true, collect and return metrics in the monitoring endpoint.",
    "privacy": "Public",
    "value": false
  },
  "monitoring_endpoint_config.ip": {
    "description": "The monitoring endpoint ip address.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "monitoring_endpoint_config.port": {
    "description": "The monitoring endpoint port.",
    "privacy": "Public",
    "value": 8082
  },
  "rpc_state_reader_config.json_rpc_version": {
    "description": "The json rpc version.",
    "privacy": "Public",
    "value": "2.0"
  },
  "rpc_state_reader_config.url": {
    "description": "The url of the rpc server.",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 31536000
  },
  "state_sync_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.network_config.quic_port": {
    "description": "The port that the node listens on for incoming quic connections.",
    "privacy": "Public",
    "value": 10001
  },
  "state_sync_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "state_sync_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.network_config.tcp_port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 12345
  },
  "state_sync_config.p2p_sync_client_config.buffer_size": {
    "description": "Size of the buffer for read from the storage and for incoming responses.",
    "privacy": "Public",
    "value": 100000
  },
  "state_sync_config.p2p_sync_client_config.num_block_classes_per_query": {
    "description": "The maximum amount of block's classes to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_state_diffs_per_query": {
    "description": "The maximum amount of block's state diffs to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_transactions_per_query": {
    "description": "The maximum amount of blocks to ask their transactions from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_headers_per_query": {
    "description": "The maximum amount of headers to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 10000
  },
  "state_sync_config.p2p_sync_client_config.wait_period_for_new_data": {
    "description": "Time in millisseconds to wait when a query returned with partial data before sending a new query",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.storage_config.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.storage_config.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.storage_config.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "state_sync_config.storage_config.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "state_sync_config.storage_config.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "./sequencer_data"
  },
  "state_sync_config.storage_config.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "state_sync_config.storage_config.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "state_sync_config.storage_config.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "FullArchive"
  },
  "strk_fee_token_address": {
    "description": "A required param! Address of the STRK fee token.",
    "param_type": "String",
    "privacy": "TemporaryValue"
  },
  "validator_id": {
    "description": "A required param! The ID of the validator. Also the address of this validator as a starknet contract.",
    "param_type": "String",
    "privacy": "TemporaryValue"
  },
  "versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 10000000
  },
  "versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "privacy": "TemporaryValue",
    "value": 1000
  },
  "versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "privacy": "TemporaryValue",
    "value": 50
  },
  "versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 1000000
  }
}
