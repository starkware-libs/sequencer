{
  "base_layer_config.node_url": {
    "description": "Ethereum node URL. A schema to match to Infura node: https://mainnet.infura.io/v3/<your_api_key>, but any other node can be used.",
    "privacy": "Private",
    "value": "https://mainnet.infura.io/v3/%3Cyour_api_key%3E"
  },
  "base_layer_config.prague_blob_gas_calc": {
    "description": "If true use the blob gas calculcation from the Pectra upgrade. If false use the EIP 4844 calculation.",
    "privacy": "Public",
    "value": true
  },
  "base_layer_config.starknet_contract_address": {
    "description": "Starknet contract address in ethereum.",
    "privacy": "Public",
    "value": "0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4"
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.l1_gas": {
    "description": "An upper bound on the total l1_gas used in a block.",
    "privacy": "Public",
    "value": 2500000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.message_segment_length": {
    "description": "An upper bound on the message segment length in a block.",
    "privacy": "Public",
    "value": 3700
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.n_events": {
    "description": "An upper bound on the total number of events generated in a block.",
    "privacy": "Public",
    "value": 5000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.sierra_gas": {
    "description": "An upper bound on the total sierra_gas used in a block.",
    "privacy": "Public",
    "value": 400000000
  },
  "batcher_config.block_builder_config.bouncer_config.block_max_capacity.state_diff_size": {
    "description": "An upper bound on the total state diff size in a block.",
    "privacy": "Public",
    "value": 4000
  },
  "batcher_config.block_builder_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.chunk_size": {
    "description": "The size of the transaction chunk executed in parallel.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.enabled": {
    "description": "Enables concurrency of transaction execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.block_builder_config.execute_config.concurrency_config.n_workers": {
    "description": "Number of parallel transaction execution workers.",
    "privacy": "Public",
    "value": 0
  },
  "batcher_config.block_builder_config.execute_config.stack_size": {
    "description": "The thread stack size (proportional to the maximal gas of a transaction).",
    "privacy": "Public",
    "value": 62914560
  },
  "batcher_config.block_builder_config.tx_chunk_size": {
    "description": "Number of transactions in each request from the tx_provider.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "batcher_config.block_builder_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.channel_size": {
    "description": "The size of the compilation request channel.",
    "privacy": "Public",
    "value": 2000
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.native_classes_whitelist": {
    "description": "Contracts for Cairo Specifies whether to execute all class hashes or only a limited selection using Cairo native contracts. If limited, a specific list of class hashes is provided. compilation.",
    "privacy": "Public",
    "value": "All"
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.run_cairo_native": {
    "description": "Enables Cairo native execution.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.cairo_native_run_config.wait_on_native_compilation": {
    "description": "Block Sequencer main program while compiling sierra, for testing.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.contract_cache_size": {
    "description": "The size of the global contract cache.",
    "privacy": "Public",
    "value": 600
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_casm_bytecode_size": {
    "description": "Limitation of compiled casm bytecode size.",
    "privacy": "Public",
    "value": 81920
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_cpu_time": {
    "description": "Limitation of compilation cpu time (seconds).",
    "privacy": "Public",
    "value": 20
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_memory_usage": {
    "description": "Limitation of compilation process's virtual memory (bytes).",
    "privacy": "Public",
    "value": 5368709120
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.max_native_bytecode_size": {
    "description": "Limitation of compiled native bytecode size.",
    "privacy": "Public",
    "value": 15728640
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.optimization_level": {
    "description": "The level of optimization to apply during compilation.",
    "privacy": "Public",
    "value": 2
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.panic_on_compilation_failure": {
    "description": "Whether to panic on compilation failure.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.sierra_to_native_compiler_path": {
    "description": "The path to the Sierra-to-Native compiler binary.",
    "privacy": "Public",
    "value": ""
  },
  "batcher_config.contract_class_manager_config.native_compiler_config.sierra_to_native_compiler_path.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "batcher_config.input_stream_content_buffer_size": {
    "description": "Sets the buffer size for the input transaction channel. Adding more transactions beyond this limit will block until space is available.",
    "privacy": "Public",
    "value": 400
  },
  "batcher_config.max_l1_handler_txs_per_block_proposal": {
    "description": "The maximum number of L1 handler transactions to include in a block proposal.",
    "privacy": "Public",
    "value": 3
  },
  "batcher_config.outstream_content_buffer_size": {
    "description": "The maximum number of items to include in a single get_proposal_content response.",
    "privacy": "Public",
    "value": 100
  },
  "batcher_config.storage.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "batcher_config.storage.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "batcher_config.storage.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "batcher_config.storage.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "batcher_config.storage.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "/data/batcher"
  },
  "batcher_config.storage.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "batcher_config.storage.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "batcher_config.storage.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "batcher_config.storage.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "StateOnly"
  },
  "chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "class_manager_config.class_manager_config.cached_class_storage_config.class_cache_size": {
    "description": "Contract classes cache size.",
    "privacy": "Public",
    "value": 10
  },
  "class_manager_config.class_manager_config.cached_class_storage_config.deprecated_class_cache_size": {
    "description": "Deprecated contract classes cache size.",
    "privacy": "Public",
    "value": 10
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.enforce_file_exists": {
    "description": "Whether to enforce that the above path exists.",
    "privacy": "Public",
    "value": false
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.max_size": {
    "description": "The maximum size of the class hash storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "class_manager_config.class_storage_config.class_hash_storage_config.path_prefix": {
    "description": "Prefix of the path of class hash storage directory.",
    "privacy": "Public",
    "value": "/data/class_hash_storage"
  },
  "class_manager_config.class_storage_config.persistent_root": {
    "description": "Path to the node's class storage directory.",
    "privacy": "Public",
    "value": "/data/classes"
  },
  "compiler_config.max_casm_bytecode_size": {
    "description": "Limitation of compiled casm bytecode size.",
    "privacy": "Public",
    "value": 81920
  },
  "compiler_config.max_cpu_time": {
    "description": "Limitation of compilation cpu time (seconds).",
    "privacy": "Public",
    "value": 20
  },
  "compiler_config.max_memory_usage": {
    "description": "Limitation of compilation process's virtual memory (bytes).",
    "privacy": "Public",
    "value": 5368709120
  },
  "compiler_config.max_native_bytecode_size": {
    "description": "Limitation of compiled native bytecode size.",
    "privacy": "Public",
    "value": 15728640
  },
  "compiler_config.optimization_level": {
    "description": "The level of optimization to apply during compilation.",
    "privacy": "Public",
    "value": 2
  },
  "compiler_config.panic_on_compilation_failure": {
    "description": "Whether to panic on compilation failure.",
    "privacy": "Public",
    "value": false
  },
  "compiler_config.sierra_to_native_compiler_path": {
    "description": "The path to the Sierra-to-Native compiler binary.",
    "privacy": "Public",
    "value": ""
  },
  "compiler_config.sierra_to_native_compiler_path.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "components.batcher.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.batcher.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.batcher.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.batcher.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.batcher.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.batcher.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.batcher.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.batcher.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.batcher.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.batcher.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.class_manager.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.class_manager.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.class_manager.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.class_manager.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.class_manager.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.class_manager.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.class_manager.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.class_manager.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.class_manager.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.class_manager.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.consensus_manager.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.gateway.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.gateway.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.gateway.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.gateway.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.gateway.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.gateway.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.gateway.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.gateway.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.gateway.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.gateway.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.http_server.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.l1_gas_price_provider.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_gas_price_provider.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.l1_gas_price_provider.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.l1_gas_price_provider.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_gas_price_provider.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.l1_gas_price_provider.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.l1_gas_price_provider.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.l1_gas_price_provider.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.l1_gas_price_provider.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.l1_gas_price_provider.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.l1_gas_price_scraper.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.l1_provider.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.l1_provider.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.l1_provider.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.l1_provider.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.l1_provider.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.l1_provider.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.l1_provider.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.l1_provider.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.l1_provider.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.l1_provider.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.l1_scraper.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.mempool.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.mempool.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.mempool.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.mempool_p2p.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.mempool_p2p.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.mempool_p2p.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.mempool_p2p.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.mempool_p2p.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.mempool_p2p.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.mempool_p2p.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.mempool_p2p.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool_p2p.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.mempool_p2p.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.monitoring_endpoint.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "Enabled"
  },
  "components.sierra_compiler.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.sierra_compiler.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.sierra_compiler.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.sierra_compiler.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.sierra_compiler.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.sierra_compiler.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.sierra_compiler.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.sierra_compiler.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.sierra_compiler.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.sierra_compiler.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "components.state_sync.execution_mode": {
    "description": "The component execution mode.",
    "privacy": "Public",
    "value": "LocalExecutionWithRemoteDisabled"
  },
  "components.state_sync.ip": {
    "description": "Binding address of the remote component server.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "components.state_sync.local_server_config.channel_buffer_size": {
    "description": "The communication channel buffer size.",
    "privacy": "Public",
    "value": 32
  },
  "components.state_sync.max_concurrency": {
    "description": "The maximum number of concurrent requests handling.",
    "privacy": "Public",
    "value": 10
  },
  "components.state_sync.port": {
    "description": "Listening port of the remote component server.",
    "privacy": "Public",
    "value": 0
  },
  "components.state_sync.remote_client_config.idle_connections": {
    "description": "The maximum number of idle connections to keep alive.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "components.state_sync.remote_client_config.idle_timeout": {
    "description": "The duration in seconds to keep an idle connection open before closing.",
    "privacy": "Public",
    "value": 90
  },
  "components.state_sync.remote_client_config.retries": {
    "description": "The max number of retries for sending a message.",
    "privacy": "Public",
    "value": 3
  },
  "components.state_sync.remote_client_config.retry_interval": {
    "description": "The duration in seconds to wait between remote connection retries.",
    "privacy": "Public",
    "value": 3
  },
  "components.state_sync.url": {
    "description": "URL of the remote component server.",
    "privacy": "Public",
    "value": "localhost"
  },
  "consensus_manager_config.broadcast_buffer_size": {
    "description": "The buffer size for the broadcast channel.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.cende_config.recorder_url": {
    "description": "The URL of the Pythonic cende_recorder",
    "pointer_target": "recorder_url",
    "privacy": "Private"
  },
  "consensus_manager_config.cende_config.skip_write_height": {
    "description": "A height that the consensus can skip writing to Aerospike. Needed for booting up (no previous height blob to write) or to handle extreme cases (all the nodes failed).",
    "privacy": "Private",
    "value": 0
  },
  "consensus_manager_config.cende_config.skip_write_height.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.consensus_config.future_height_limit": {
    "description": "How many heights in the future should we cache.",
    "privacy": "Public",
    "value": 10
  },
  "consensus_manager_config.consensus_config.future_height_round_limit": {
    "description": "How many rounds should we cache for future heights.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.consensus_config.future_round_limit": {
    "description": "How many rounds in the future (for current height) should we cache.",
    "privacy": "Public",
    "value": 10
  },
  "consensus_manager_config.consensus_config.startup_delay": {
    "description": "Delay (seconds) before starting consensus to give time for network peering.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.consensus_config.sync_retry_interval": {
    "description": "The duration (seconds) between sync attempts.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.precommit_timeout": {
    "description": "The timeout (seconds) for a precommit.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.prevote_timeout": {
    "description": "The timeout (seconds) for a prevote.",
    "privacy": "Public",
    "value": 1.0
  },
  "consensus_manager_config.consensus_config.timeouts.proposal_timeout": {
    "description": "The timeout (seconds) for a proposal.",
    "privacy": "Public",
    "value": 3.0
  },
  "consensus_manager_config.consensus_config.validator_id": {
    "description": "The validator id of the node.",
    "pointer_target": "validator_id",
    "privacy": "Public"
  },
  "consensus_manager_config.context_config.block_timestamp_window": {
    "description": "Maximum allowed deviation (seconds) of a proposed block's timestamp from the current time.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.context_config.build_proposal_margin": {
    "description": "Safety margin (in ms) to make sure that the batcher completes building the proposal with enough time for the Fin to be checked by validators.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.context_config.builder_address": {
    "description": "The address of the contract that builds the block.",
    "privacy": "Public",
    "value": "0x0"
  },
  "consensus_manager_config.context_config.chain_id": {
    "description": "The chain id of the Starknet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.context_config.l1_da_mode": {
    "description": "The data availability mode, true: Blob, false: Calldata.",
    "privacy": "Public",
    "value": true
  },
  "consensus_manager_config.context_config.num_validators": {
    "description": "The number of validators.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.context_config.proposal_buffer_size": {
    "description": "The buffer size for streaming outbound proposals.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.context_config.validate_proposal_margin": {
    "description": "Safety margin (in ms) to make sure that consensus determines when to timeout validating a proposal.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.eth_to_strk_oracle_config.base_url": {
    "description": "URL to query. This must end with the query parameter `timestamp=` as we append a UNIX timestamp.",
    "privacy": "Private",
    "value": "https://example.com/api?timestamp="
  },
  "consensus_manager_config.eth_to_strk_oracle_config.headers": {
    "description": "HTTP headers for the eth to strk oracle, formatted as 'k1:v1 k2:v2 ...'.",
    "privacy": "Private",
    "value": ""
  },
  "consensus_manager_config.eth_to_strk_oracle_config.lag_margin_seconds": {
    "description": "The time margin (in seconds) to adjust the timestamp before querying the conversion rate. Ensures a stable timestamp from providers. Should be configured in alignment with relevant query parameters in `base_url`, if required.",
    "privacy": "Private",
    "value": 0
  },
  "consensus_manager_config.immediate_active_height": {
    "description": "The height at which the node may actively participate in consensus.",
    "privacy": "Public",
    "value": 0
  },
  "consensus_manager_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "consensus_manager_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "consensus_manager_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "consensus_manager_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "consensus_manager_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "consensus_manager_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "consensus_manager_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 10000
  },
  "consensus_manager_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "consensus_manager_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "consensus_manager_config.proposals_topic": {
    "description": "The topic for consensus proposals.",
    "privacy": "Public",
    "value": "consensus_proposals"
  },
  "consensus_manager_config.revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "pointer_target": "revert_config.revert_up_to_and_including",
    "privacy": "Public"
  },
  "consensus_manager_config.revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "pointer_target": "revert_config.should_revert",
    "privacy": "Public"
  },
  "consensus_manager_config.votes_topic": {
    "description": "The topic for consensus votes.",
    "privacy": "Public",
    "value": "consensus_votes"
  },
  "eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "gateway_config.chain_info.chain_id": {
    "description": "The chain ID of the StarkNet chain.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.eth_fee_token_address": {
    "description": "Address of the ETH fee token.",
    "pointer_target": "eth_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.chain_info.fee_token_addresses.strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "pointer_target": "strk_fee_token_address",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.max_allowed_nonce_gap": {
    "description": "The maximum allowed gap between the account nonce and the transaction nonce.",
    "privacy": "Public",
    "value": 50
  },
  "gateway_config.stateful_tx_validator_config.max_nonce_for_validation_skip": {
    "description": "Maximum nonce for which the validation is skipped.",
    "privacy": "Public",
    "value": "0x1"
  },
  "gateway_config.stateful_tx_validator_config.reject_future_declare_txs": {
    "description": "If true, rejects declare transactions with future nonces.",
    "privacy": "Public",
    "value": true
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.invoke_tx_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "pointer_target": "versioned_constants_overrides.max_n_events",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "pointer_target": "versioned_constants_overrides.max_recursion_depth",
    "privacy": "Public"
  },
  "gateway_config.stateful_tx_validator_config.versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "pointer_target": "versioned_constants_overrides.validate_max_n_steps",
    "privacy": "Public"
  },
  "gateway_config.stateless_tx_validator_config.max_calldata_length": {
    "description": "Limitation of calldata length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.max_contract_class_object_size": {
    "description": "Limitation of contract class object size.",
    "privacy": "Public",
    "value": 4089446
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 5
  },
  "gateway_config.stateless_tx_validator_config.max_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 18446744073709551615
  },
  "gateway_config.stateless_tx_validator_config.max_signature_length": {
    "description": "Limitation of signature length.",
    "privacy": "Public",
    "value": 4000
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.major": {
    "description": "The major version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.minor": {
    "description": "The minor version of the configuration.",
    "privacy": "Public",
    "value": 1
  },
  "gateway_config.stateless_tx_validator_config.min_sierra_version.patch": {
    "description": "The patch version of the configuration.",
    "privacy": "Public",
    "value": 0
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l1_data_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L1 Data (Blob) resource bounds.",
    "privacy": "Public",
    "value": false
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l1_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L1 resource bounds.",
    "privacy": "Public",
    "value": true
  },
  "gateway_config.stateless_tx_validator_config.validate_non_zero_l2_gas_fee": {
    "description": "If true, validates that a transaction has non-zero L2 resource bounds.",
    "privacy": "Public",
    "value": false
  },
  "http_server_config.ip": {
    "description": "The http server ip.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "http_server_config.port": {
    "description": "The http server port.",
    "privacy": "Public",
    "value": 8080
  },
  "l1_gas_price_provider_config.lag_margin_seconds": {
    "description": "Difference between the time of the block from L1 used to calculate the gas price and the time of the L2 block this price is used in",
    "privacy": "Public",
    "value": 60
  },
  "l1_gas_price_provider_config.number_of_blocks_for_mean": {
    "description": "Number of blocks to use for the mean gas price calculation",
    "privacy": "Public",
    "value": 300
  },
  "l1_gas_price_provider_config.storage_limit": {
    "description": "Maximum number of L1 blocks to keep cached",
    "privacy": "Public",
    "value": 3000
  },
  "l1_gas_price_scraper_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "l1_gas_price_scraper_config.finality": {
    "description": "Number of blocks to wait for finality in L1",
    "privacy": "Public",
    "value": 0
  },
  "l1_gas_price_scraper_config.number_of_blocks_for_mean": {
    "description": "Number of blocks to use for the mean gas price calculation",
    "privacy": "Public",
    "value": 300
  },
  "l1_gas_price_scraper_config.polling_interval": {
    "description": "The duration (seconds) between each scraping attempt of L1",
    "privacy": "Public",
    "value": 1
  },
  "l1_gas_price_scraper_config.starting_block": {
    "description": "Starting block to scrape from",
    "privacy": "Public",
    "value": 0
  },
  "l1_gas_price_scraper_config.starting_block.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_provider_config.bootstrap_catch_up_height_override": {
    "description": "Override height at which the provider should catch up to the bootstrapper.",
    "privacy": "Public",
    "value": 0
  },
  "l1_provider_config.bootstrap_catch_up_height_override.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_provider_config.provider_startup_height_override": {
    "description": "Override height at which the provider should start",
    "privacy": "Public",
    "value": 0
  },
  "l1_provider_config.provider_startup_height_override.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "l1_provider_config.startup_sync_sleep_retry_interval": {
    "description": "Interval in seconds between each retry of syncing with L2 during startup.",
    "privacy": "Public",
    "value": 0.0
  },
  "l1_scraper_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "l1_scraper_config.finality": {
    "description": "Number of blocks to wait for finality",
    "privacy": "Public",
    "value": 0
  },
  "l1_scraper_config.polling_interval": {
    "description": "Interval in Seconds between each scraping attempt of L1.",
    "privacy": "Public",
    "value": 1
  },
  "l1_scraper_config.startup_rewind_time": {
    "description": "Duration to rewind from latest L1 block when starting scraping.",
    "privacy": "Public",
    "value": 0
  },
  "mempool_config.committed_nonce_retention_block_count": {
    "description": "Number of latest committed blocks for which committed account nonces are retained.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_config.declare_delay": {
    "description": "Time to wait before allowing a Declare transaction to be returned, in seconds.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_config.enable_fee_escalation": {
    "description": "If true, transactions can be replaced with higher fee transactions.",
    "privacy": "Public",
    "value": true
  },
  "mempool_config.fee_escalation_percentage": {
    "description": "Percentage increase for tip and max gas price to enable transaction replacement.",
    "privacy": "Public",
    "value": 10
  },
  "mempool_config.transaction_ttl": {
    "description": "Time-to-live for transactions in the mempool, in seconds.",
    "privacy": "Public",
    "value": 60
  },
  "mempool_config.capacity_in_bytes": {
    "description": "Maximum size of the mempool, in bytes.",
    "privacy": "Public",
    "value": 1073741824
  },
  "mempool_p2p_config.max_transaction_batch_size": {
    "description": "Maximum number of transactions in each batch.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_p2p_config.network_buffer_size": {
    "description": "Network buffer size.",
    "privacy": "Public",
    "value": 10000
  },
  "mempool_p2p_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "mempool_p2p_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "mempool_p2p_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "mempool_p2p_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "mempool_p2p_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "mempool_p2p_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "mempool_p2p_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 11111
  },
  "mempool_p2p_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "mempool_p2p_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "mempool_p2p_config.transaction_batch_rate_millis": {
    "description": "Maximum time until a transaction batch is closed and propagated in milliseconds.",
    "privacy": "Public",
    "value": 1000
  },
  "monitoring_config.collect_metrics": {
    "description": "Indicating if metrics should be recorded.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_config.collect_profiling_metrics": {
    "description": "Indicating if profiling metrics should be collected.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.collect_metrics": {
    "description": "If true, collect and return metrics in the monitoring endpoint.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.collect_profiling_metrics": {
    "description": "If true, collect and return profiling metrics in the monitoring endpoint.",
    "privacy": "Public",
    "value": true
  },
  "monitoring_endpoint_config.ip": {
    "description": "The monitoring endpoint ip address.",
    "privacy": "Public",
    "value": "0.0.0.0"
  },
  "monitoring_endpoint_config.port": {
    "description": "The monitoring endpoint port.",
    "privacy": "Public",
    "value": 8082
  },
  "recorder_url": {
    "description": "The URL of the Pythonic cende_recorder",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "privacy": "TemporaryValue",
    "value": 18446744073709551615
  },
  "revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "state_sync_config.central_sync_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.central_sync_client_config.central_source_config.class_cache_size": {
    "description": "Size of class cache, must be a positive integer.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.central_sync_client_config.central_source_config.concurrent_requests": {
    "description": "Maximum number of concurrent requests to Starknet feeder-gateway for getting a type of data (for example, blocks).",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.central_source_config.http_headers": {
    "description": "'k1:v1 k2:v2 ...' headers for SN-client.",
    "privacy": "Private",
    "value": ""
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_classes_to_download": {
    "description": "Maximum number of classes to download at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_state_updates_to_download": {
    "description": "Maximum number of state updates to download at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.max_state_updates_to_store_in_memory": {
    "description": "Maximum number of state updates to store in memory at a given time.",
    "privacy": "Public",
    "value": 20
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.max_retries": {
    "description": "Maximum number of retries before the node stops retrying.",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.retry_base_millis": {
    "description": "Base waiting time after a failed request. After that, the time increases exponentially.",
    "privacy": "Public",
    "value": 30
  },
  "state_sync_config.central_sync_client_config.central_source_config.retry_config.retry_max_delay_millis": {
    "description": "Max waiting time after a failed request.",
    "privacy": "Public",
    "value": 30000
  },
  "state_sync_config.central_sync_client_config.central_source_config.starknet_url": {
    "description": "Starknet feeder-gateway URL. It should match chain_id.",
    "privacy": "Public",
    "value": "https://alpha-mainnet.starknet.io/"
  },
  "state_sync_config.central_sync_client_config.sync_config.base_layer_propagation_sleep_duration": {
    "description": "Time in seconds to poll the base layer to get the latest proved block.",
    "privacy": "Public",
    "value": 10
  },
  "state_sync_config.central_sync_client_config.sync_config.block_propagation_sleep_duration": {
    "description": "Time in seconds before checking for a new block after the node is synchronized.",
    "privacy": "Public",
    "value": 2
  },
  "state_sync_config.central_sync_client_config.sync_config.blocks_max_stream_size": {
    "description": "Max amount of blocks to download in a stream.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.central_sync_client_config.sync_config.collect_pending_data": {
    "description": "Whether to collect data on pending blocks.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.central_sync_client_config.sync_config.recoverable_error_sleep_duration": {
    "description": "Waiting time in seconds before restarting synchronization after a recoverable error.",
    "privacy": "Public",
    "value": 3
  },
  "state_sync_config.central_sync_client_config.sync_config.state_updates_max_stream_size": {
    "description": "Max amount of state updates to download in a stream.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.central_sync_client_config.sync_config.store_sierras_and_casms": {
    "description": "Whether to store sierras and casms to the storage. This allows maintaining backward-compatibility with native-blockifier",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.central_sync_client_config.sync_config.verify_blocks": {
    "description": "Whether to verify incoming blocks.",
    "privacy": "Public",
    "value": true
  },
  "state_sync_config.network_config.advertised_multiaddr": {
    "description": "The external address other peers see this node. If this is set, the node will not try to find out which addresses it has and will write this address as external instead",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.advertised_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr": {
    "description": "The multiaddress of the peer node. It should include the peer's id. For more info: https://docs.libp2p.io/concepts/fundamentals/peers/",
    "privacy": "Public",
    "value": ""
  },
  "state_sync_config.network_config.bootstrap_peer_multiaddr.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": true
  },
  "state_sync_config.network_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.base_delay_millis": {
    "description": "The base delay in milliseconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 2
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.factor": {
    "description": "The factor for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.bootstrap_dial_retry_config.max_delay_seconds": {
    "description": "The maximum delay in seconds for the exponential backoff strategy.",
    "privacy": "Public",
    "value": 5
  },
  "state_sync_config.network_config.discovery_config.heartbeat_interval": {
    "description": "The interval between each discovery (Kademlia) query in milliseconds.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.network_config.idle_connection_timeout": {
    "description": "Amount of time in seconds that a connection with no active sessions will stay alive.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.network_config.peer_manager_config.malicious_timeout_seconds": {
    "description": "The duration in seconds a peer is blacklisted after being marked as malicious.",
    "privacy": "Public",
    "value": 1
  },
  "state_sync_config.network_config.peer_manager_config.unstable_timeout_millis": {
    "description": "The duration in milliseconds a peer blacklisted after being reported as unstable.",
    "privacy": "Public",
    "value": 1000
  },
  "state_sync_config.network_config.port": {
    "description": "The port that the node listens on for incoming tcp connections.",
    "privacy": "Public",
    "value": 12345
  },
  "state_sync_config.network_config.secret_key": {
    "description": "The secret key used for building the peer id. If it's an empty string a random one will be used.",
    "privacy": "Private",
    "value": ""
  },
  "state_sync_config.network_config.session_timeout": {
    "description": "Maximal time in seconds that each session can take before failing on timeout.",
    "privacy": "Public",
    "value": 120
  },
  "state_sync_config.p2p_sync_client_config.#is_none": {
    "description": "Flag for an optional field.",
    "privacy": "TemporaryValue",
    "value": false
  },
  "state_sync_config.p2p_sync_client_config.buffer_size": {
    "description": "Size of the buffer for read from the storage and for incoming responses.",
    "privacy": "Public",
    "value": 100000
  },
  "state_sync_config.p2p_sync_client_config.num_block_classes_per_query": {
    "description": "The maximum amount of block's classes to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_state_diffs_per_query": {
    "description": "The maximum amount of block's state diffs to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_block_transactions_per_query": {
    "description": "The maximum amount of blocks to ask their transactions from peers in each iteration.",
    "privacy": "Public",
    "value": 100
  },
  "state_sync_config.p2p_sync_client_config.num_headers_per_query": {
    "description": "The maximum amount of headers to ask from peers in each iteration.",
    "privacy": "Public",
    "value": 10000
  },
  "state_sync_config.p2p_sync_client_config.wait_period_for_new_data": {
    "description": "Time in millisseconds to wait when a query returned with partial data before sending a new query",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.p2p_sync_client_config.wait_period_for_other_protocol": {
    "description": "Time in millisseconds to wait for a dependency protocol to advance (e.g.state diff sync depends on header sync)",
    "privacy": "Public",
    "value": 50
  },
  "state_sync_config.revert_config.revert_up_to_and_including": {
    "description": "The component will revert blocks up to this block number (including).",
    "pointer_target": "revert_config.revert_up_to_and_including",
    "privacy": "Public"
  },
  "state_sync_config.revert_config.should_revert": {
    "description": "If set true, the component would revert blocks and do nothing else.",
    "pointer_target": "revert_config.should_revert",
    "privacy": "Public"
  },
  "state_sync_config.storage_config.db_config.chain_id": {
    "description": "The chain to follow. For more details see https://docs.starknet.io/documentation/architecture_and_concepts/Blocks/transactions/#chain-id.",
    "pointer_target": "chain_id",
    "privacy": "Public"
  },
  "state_sync_config.storage_config.db_config.enforce_file_exists": {
    "description": "Whether to enforce that the path exists. If true, `open_env` fails when the mdbx.dat file does not exist.",
    "privacy": "Public",
    "value": false
  },
  "state_sync_config.storage_config.db_config.growth_step": {
    "description": "The growth step in bytes, must be greater than zero to allow the database to grow.",
    "privacy": "Public",
    "value": 4294967296
  },
  "state_sync_config.storage_config.db_config.max_size": {
    "description": "The maximum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.db_config.min_size": {
    "description": "The minimum size of the node's storage in bytes.",
    "privacy": "Public",
    "value": 1048576
  },
  "state_sync_config.storage_config.db_config.path_prefix": {
    "description": "Prefix of the path of the node's storage directory, the storage file path will be <path_prefix>/<chain_id>. The path is not created automatically.",
    "privacy": "Public",
    "value": "/data/state_sync"
  },
  "state_sync_config.storage_config.mmap_file_config.growth_step": {
    "description": "The growth step in bytes, must be greater than max_object_size.",
    "privacy": "Public",
    "value": 1073741824
  },
  "state_sync_config.storage_config.mmap_file_config.max_object_size": {
    "description": "The maximum size of a single object in the file in bytes",
    "privacy": "Public",
    "value": 268435456
  },
  "state_sync_config.storage_config.mmap_file_config.max_size": {
    "description": "The maximum size of a memory mapped file in bytes. Must be greater than growth_step.",
    "privacy": "Public",
    "value": 1099511627776
  },
  "state_sync_config.storage_config.scope": {
    "description": "The categories of data saved in storage.",
    "privacy": "Public",
    "value": "FullArchive"
  },
  "strk_fee_token_address": {
    "description": "Address of the STRK fee token.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "validator_id": {
    "description": "The ID of the validator. Also the address of this validator as a starknet contract.",
    "privacy": "TemporaryValue",
    "value": "PointerTarget"
  },
  "versioned_constants_overrides.invoke_tx_max_n_steps": {
    "description": "Maximum number of steps the invoke function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 10000000
  },
  "versioned_constants_overrides.max_n_events": {
    "description": "Maximum number of events that can be emitted from the transation.",
    "privacy": "TemporaryValue",
    "value": 1000
  },
  "versioned_constants_overrides.max_recursion_depth": {
    "description": "Maximum recursion depth for nested calls during blockifier validation.",
    "privacy": "TemporaryValue",
    "value": 50
  },
  "versioned_constants_overrides.validate_max_n_steps": {
    "description": "Maximum number of steps the validation function is allowed to run.",
    "privacy": "TemporaryValue",
    "value": 1000000
  }
}
